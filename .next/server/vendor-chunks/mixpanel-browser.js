"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/mixpanel-browser";
exports.ids = ["vendor-chunks/mixpanel-browser"];
exports.modules = {

/***/ "(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js":
/*!***************************************************************!*\
  !*** ./node_modules/mixpanel-browser/dist/mixpanel.module.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ mixpanel)\n/* harmony export */ });\nvar NodeType;\r\n(function (NodeType) {\r\n    NodeType[NodeType[\"Document\"] = 0] = \"Document\";\r\n    NodeType[NodeType[\"DocumentType\"] = 1] = \"DocumentType\";\r\n    NodeType[NodeType[\"Element\"] = 2] = \"Element\";\r\n    NodeType[NodeType[\"Text\"] = 3] = \"Text\";\r\n    NodeType[NodeType[\"CDATA\"] = 4] = \"CDATA\";\r\n    NodeType[NodeType[\"Comment\"] = 5] = \"Comment\";\r\n})(NodeType || (NodeType = {}));\n\nfunction isElement(n) {\r\n    return n.nodeType === n.ELEMENT_NODE;\r\n}\r\nfunction isShadowRoot(n) {\r\n    const host = n === null || n === void 0 ? void 0 : n.host;\r\n    return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n);\r\n}\r\nfunction isNativeShadowDom(shadowRoot) {\r\n    return Object.prototype.toString.call(shadowRoot) === '[object ShadowRoot]';\r\n}\r\nfunction fixBrowserCompatibilityIssuesInCSS(cssText) {\r\n    if (cssText.includes(' background-clip: text;') &&\r\n        !cssText.includes(' -webkit-background-clip: text;')) {\r\n        cssText = cssText.replace(' background-clip: text;', ' -webkit-background-clip: text; background-clip: text;');\r\n    }\r\n    return cssText;\r\n}\r\nfunction escapeImportStatement(rule) {\r\n    const { cssText } = rule;\r\n    if (cssText.split('\"').length < 3)\r\n        return cssText;\r\n    const statement = ['@import', `url(${JSON.stringify(rule.href)})`];\r\n    if (rule.layerName === '') {\r\n        statement.push(`layer`);\r\n    }\r\n    else if (rule.layerName) {\r\n        statement.push(`layer(${rule.layerName})`);\r\n    }\r\n    if (rule.supportsText) {\r\n        statement.push(`supports(${rule.supportsText})`);\r\n    }\r\n    if (rule.media.length) {\r\n        statement.push(rule.media.mediaText);\r\n    }\r\n    return statement.join(' ') + ';';\r\n}\r\nfunction stringifyStylesheet(s) {\r\n    try {\r\n        const rules = s.rules || s.cssRules;\r\n        return rules\r\n            ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join(''))\r\n            : null;\r\n    }\r\n    catch (error) {\r\n        return null;\r\n    }\r\n}\r\nfunction stringifyRule(rule) {\r\n    let importStringified;\r\n    if (isCSSImportRule(rule)) {\r\n        try {\r\n            importStringified =\r\n                stringifyStylesheet(rule.styleSheet) ||\r\n                    escapeImportStatement(rule);\r\n        }\r\n        catch (error) {\r\n        }\r\n    }\r\n    else if (isCSSStyleRule(rule) && rule.selectorText.includes(':')) {\r\n        return fixSafariColons(rule.cssText);\r\n    }\r\n    return importStringified || rule.cssText;\r\n}\r\nfunction fixSafariColons(cssStringified) {\r\n    const regex = /(\\[(?:[\\w-]+)[^\\\\])(:(?:[\\w-]+)\\])/gm;\r\n    return cssStringified.replace(regex, '$1\\\\$2');\r\n}\r\nfunction isCSSImportRule(rule) {\r\n    return 'styleSheet' in rule;\r\n}\r\nfunction isCSSStyleRule(rule) {\r\n    return 'selectorText' in rule;\r\n}\r\nclass Mirror {\r\n    constructor() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n    getId(n) {\r\n        var _a;\r\n        if (!n)\r\n            return -1;\r\n        const id = (_a = this.getMeta(n)) === null || _a === void 0 ? void 0 : _a.id;\r\n        return id !== null && id !== void 0 ? id : -1;\r\n    }\r\n    getNode(id) {\r\n        return this.idNodeMap.get(id) || null;\r\n    }\r\n    getIds() {\r\n        return Array.from(this.idNodeMap.keys());\r\n    }\r\n    getMeta(n) {\r\n        return this.nodeMetaMap.get(n) || null;\r\n    }\r\n    removeNodeFromMap(n) {\r\n        const id = this.getId(n);\r\n        this.idNodeMap.delete(id);\r\n        if (n.childNodes) {\r\n            n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));\r\n        }\r\n    }\r\n    has(id) {\r\n        return this.idNodeMap.has(id);\r\n    }\r\n    hasNode(node) {\r\n        return this.nodeMetaMap.has(node);\r\n    }\r\n    add(n, meta) {\r\n        const id = meta.id;\r\n        this.idNodeMap.set(id, n);\r\n        this.nodeMetaMap.set(n, meta);\r\n    }\r\n    replace(id, n) {\r\n        const oldNode = this.getNode(id);\r\n        if (oldNode) {\r\n            const meta = this.nodeMetaMap.get(oldNode);\r\n            if (meta)\r\n                this.nodeMetaMap.set(n, meta);\r\n        }\r\n        this.idNodeMap.set(id, n);\r\n    }\r\n    reset() {\r\n        this.idNodeMap = new Map();\r\n        this.nodeMetaMap = new WeakMap();\r\n    }\r\n}\r\nfunction createMirror() {\r\n    return new Mirror();\r\n}\r\nfunction maskInputValue({ element, maskInputOptions, tagName, type, value, maskInputFn, }) {\r\n    let text = value || '';\r\n    const actualType = type && toLowerCase(type);\r\n    if (maskInputOptions[tagName.toLowerCase()] ||\r\n        (actualType && maskInputOptions[actualType])) {\r\n        if (maskInputFn) {\r\n            text = maskInputFn(text, element);\r\n        }\r\n        else {\r\n            text = '*'.repeat(text.length);\r\n        }\r\n    }\r\n    return text;\r\n}\r\nfunction toLowerCase(str) {\r\n    return str.toLowerCase();\r\n}\r\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\r\nfunction is2DCanvasBlank(canvas) {\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx)\r\n        return true;\r\n    const chunkSize = 50;\r\n    for (let x = 0; x < canvas.width; x += chunkSize) {\r\n        for (let y = 0; y < canvas.height; y += chunkSize) {\r\n            const getImageData = ctx.getImageData;\r\n            const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData\r\n                ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\r\n                : getImageData;\r\n            const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);\r\n            if (pixelBuffer.some((pixel) => pixel !== 0))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction getInputType(element) {\r\n    const type = element.type;\r\n    return element.hasAttribute('data-rr-is-password')\r\n        ? 'password'\r\n        : type\r\n            ?\r\n                toLowerCase(type)\r\n            : null;\r\n}\r\nfunction extractFileExtension(path, baseURL) {\r\n    var _a;\r\n    let url;\r\n    try {\r\n        url = new URL(path, baseURL !== null && baseURL !== void 0 ? baseURL : window.location.href);\r\n    }\r\n    catch (err) {\r\n        return null;\r\n    }\r\n    const regex = /\\.([0-9a-z]+)(?:$)/i;\r\n    const match = url.pathname.match(regex);\r\n    return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : null;\r\n}\n\nlet _id = 1;\r\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\r\nconst IGNORED_NODE = -2;\r\nfunction genId() {\r\n    return _id++;\r\n}\r\nfunction getValidTagName(element) {\r\n    if (element instanceof HTMLFormElement) {\r\n        return 'form';\r\n    }\r\n    const processedTagName = toLowerCase(element.tagName);\r\n    if (tagNameRegex.test(processedTagName)) {\r\n        return 'div';\r\n    }\r\n    return processedTagName;\r\n}\r\nfunction extractOrigin(url) {\r\n    let origin = '';\r\n    if (url.indexOf('//') > -1) {\r\n        origin = url.split('/').slice(0, 3).join('/');\r\n    }\r\n    else {\r\n        origin = url.split('/')[0];\r\n    }\r\n    origin = origin.split('?')[0];\r\n    return origin;\r\n}\r\nlet canvasService;\r\nlet canvasCtx;\r\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\r\nconst URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\\/\\//i;\r\nconst URL_WWW_MATCH = /^www\\..*/i;\r\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\r\nfunction absoluteToStylesheet(cssText, href) {\r\n    return (cssText || '').replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {\r\n        const filePath = path1 || path2 || path3;\r\n        const maybeQuote = quote1 || quote2 || '';\r\n        if (!filePath) {\r\n            return origin;\r\n        }\r\n        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (DATA_URI.test(filePath)) {\r\n            return `url(${maybeQuote}${filePath}${maybeQuote})`;\r\n        }\r\n        if (filePath[0] === '/') {\r\n            return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;\r\n        }\r\n        const stack = href.split('/');\r\n        const parts = filePath.split('/');\r\n        stack.pop();\r\n        for (const part of parts) {\r\n            if (part === '.') {\r\n                continue;\r\n            }\r\n            else if (part === '..') {\r\n                stack.pop();\r\n            }\r\n            else {\r\n                stack.push(part);\r\n            }\r\n        }\r\n        return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\r\n    });\r\n}\r\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/;\r\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\r\nfunction getAbsoluteSrcsetString(doc, attributeValue) {\r\n    if (attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    let pos = 0;\r\n    function collectCharacters(regEx) {\r\n        let chars;\r\n        const match = regEx.exec(attributeValue.substring(pos));\r\n        if (match) {\r\n            chars = match[0];\r\n            pos += chars.length;\r\n            return chars;\r\n        }\r\n        return '';\r\n    }\r\n    const output = [];\r\n    while (true) {\r\n        collectCharacters(SRCSET_COMMAS_OR_SPACES);\r\n        if (pos >= attributeValue.length) {\r\n            break;\r\n        }\r\n        let url = collectCharacters(SRCSET_NOT_SPACES);\r\n        if (url.slice(-1) === ',') {\r\n            url = absoluteToDoc(doc, url.substring(0, url.length - 1));\r\n            output.push(url);\r\n        }\r\n        else {\r\n            let descriptorsStr = '';\r\n            url = absoluteToDoc(doc, url);\r\n            let inParens = false;\r\n            while (true) {\r\n                const c = attributeValue.charAt(pos);\r\n                if (c === '') {\r\n                    output.push((url + descriptorsStr).trim());\r\n                    break;\r\n                }\r\n                else if (!inParens) {\r\n                    if (c === ',') {\r\n                        pos += 1;\r\n                        output.push((url + descriptorsStr).trim());\r\n                        break;\r\n                    }\r\n                    else if (c === '(') {\r\n                        inParens = true;\r\n                    }\r\n                }\r\n                else {\r\n                    if (c === ')') {\r\n                        inParens = false;\r\n                    }\r\n                }\r\n                descriptorsStr += c;\r\n                pos += 1;\r\n            }\r\n        }\r\n    }\r\n    return output.join(', ');\r\n}\r\nfunction absoluteToDoc(doc, attributeValue) {\r\n    if (!attributeValue || attributeValue.trim() === '') {\r\n        return attributeValue;\r\n    }\r\n    const a = doc.createElement('a');\r\n    a.href = attributeValue;\r\n    return a.href;\r\n}\r\nfunction isSVGElement(el) {\r\n    return Boolean(el.tagName === 'svg' || el.ownerSVGElement);\r\n}\r\nfunction getHref() {\r\n    const a = document.createElement('a');\r\n    a.href = '';\r\n    return a.href;\r\n}\r\nfunction transformAttribute(doc, tagName, name, value) {\r\n    if (!value) {\r\n        return value;\r\n    }\r\n    if (name === 'src' ||\r\n        (name === 'href' && !(tagName === 'use' && value[0] === '#'))) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'xlink:href' && value[0] !== '#') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'background' &&\r\n        (tagName === 'table' || tagName === 'td' || tagName === 'th')) {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    else if (name === 'srcset') {\r\n        return getAbsoluteSrcsetString(doc, value);\r\n    }\r\n    else if (name === 'style') {\r\n        return absoluteToStylesheet(value, getHref());\r\n    }\r\n    else if (tagName === 'object' && name === 'data') {\r\n        return absoluteToDoc(doc, value);\r\n    }\r\n    return value;\r\n}\r\nfunction ignoreAttribute(tagName, name, _value) {\r\n    return (tagName === 'video' || tagName === 'audio') && name === 'autoplay';\r\n}\r\nfunction _isBlockedElement(element, blockClass, blockSelector) {\r\n    try {\r\n        if (typeof blockClass === 'string') {\r\n            if (element.classList.contains(blockClass)) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            for (let eIndex = element.classList.length; eIndex--;) {\r\n                const className = element.classList[eIndex];\r\n                if (blockClass.test(className)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        if (blockSelector) {\r\n            return element.matches(blockSelector);\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction classMatchesRegex(node, regex, checkAncestors) {\r\n    if (!node)\r\n        return false;\r\n    if (node.nodeType !== node.ELEMENT_NODE) {\r\n        if (!checkAncestors)\r\n            return false;\r\n        return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n    }\r\n    for (let eIndex = node.classList.length; eIndex--;) {\r\n        const className = node.classList[eIndex];\r\n        if (regex.test(className)) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!checkAncestors)\r\n        return false;\r\n    return classMatchesRegex(node.parentNode, regex, checkAncestors);\r\n}\r\nfunction needMaskingText(node, maskTextClass, maskTextSelector, checkAncestors) {\r\n    try {\r\n        const el = node.nodeType === node.ELEMENT_NODE\r\n            ? node\r\n            : node.parentElement;\r\n        if (el === null)\r\n            return false;\r\n        if (typeof maskTextClass === 'string') {\r\n            if (checkAncestors) {\r\n                if (el.closest(`.${maskTextClass}`))\r\n                    return true;\r\n            }\r\n            else {\r\n                if (el.classList.contains(maskTextClass))\r\n                    return true;\r\n            }\r\n        }\r\n        else {\r\n            if (classMatchesRegex(el, maskTextClass, checkAncestors))\r\n                return true;\r\n        }\r\n        if (maskTextSelector) {\r\n            if (checkAncestors) {\r\n                if (el.closest(maskTextSelector))\r\n                    return true;\r\n            }\r\n            else {\r\n                if (el.matches(maskTextSelector))\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    return false;\r\n}\r\nfunction onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {\r\n    const win = iframeEl.contentWindow;\r\n    if (!win) {\r\n        return;\r\n    }\r\n    let fired = false;\r\n    let readyState;\r\n    try {\r\n        readyState = win.document.readyState;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (readyState !== 'complete') {\r\n        const timer = setTimeout(() => {\r\n            if (!fired) {\r\n                listener();\r\n                fired = true;\r\n            }\r\n        }, iframeLoadTimeout);\r\n        iframeEl.addEventListener('load', () => {\r\n            clearTimeout(timer);\r\n            fired = true;\r\n            listener();\r\n        });\r\n        return;\r\n    }\r\n    const blankUrl = 'about:blank';\r\n    if (win.location.href !== blankUrl ||\r\n        iframeEl.src === blankUrl ||\r\n        iframeEl.src === '') {\r\n        setTimeout(listener, 0);\r\n        return iframeEl.addEventListener('load', listener);\r\n    }\r\n    iframeEl.addEventListener('load', listener);\r\n}\r\nfunction onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {\r\n    let fired = false;\r\n    let styleSheetLoaded;\r\n    try {\r\n        styleSheetLoaded = link.sheet;\r\n    }\r\n    catch (error) {\r\n        return;\r\n    }\r\n    if (styleSheetLoaded)\r\n        return;\r\n    const timer = setTimeout(() => {\r\n        if (!fired) {\r\n            listener();\r\n            fired = true;\r\n        }\r\n    }, styleSheetLoadTimeout);\r\n    link.addEventListener('load', () => {\r\n        clearTimeout(timer);\r\n        fired = true;\r\n        listener();\r\n    });\r\n}\r\nfunction serializeNode(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, needsMask, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, } = options;\r\n    const rootId = getRootId(doc, mirror);\r\n    switch (n.nodeType) {\r\n        case n.DOCUMENT_NODE:\r\n            if (n.compatMode !== 'CSS1Compat') {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                    compatMode: n.compatMode,\r\n                };\r\n            }\r\n            else {\r\n                return {\r\n                    type: NodeType.Document,\r\n                    childNodes: [],\r\n                };\r\n            }\r\n        case n.DOCUMENT_TYPE_NODE:\r\n            return {\r\n                type: NodeType.DocumentType,\r\n                name: n.name,\r\n                publicId: n.publicId,\r\n                systemId: n.systemId,\r\n                rootId,\r\n            };\r\n        case n.ELEMENT_NODE:\r\n            return serializeElementNode(n, {\r\n                doc,\r\n                blockClass,\r\n                blockSelector,\r\n                inlineStylesheet,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n                dataURLOptions,\r\n                inlineImages,\r\n                recordCanvas,\r\n                keepIframeSrcFn,\r\n                newlyAddedElement,\r\n                rootId,\r\n            });\r\n        case n.TEXT_NODE:\r\n            return serializeTextNode(n, {\r\n                needsMask,\r\n                maskTextFn,\r\n                rootId,\r\n            });\r\n        case n.CDATA_SECTION_NODE:\r\n            return {\r\n                type: NodeType.CDATA,\r\n                textContent: '',\r\n                rootId,\r\n            };\r\n        case n.COMMENT_NODE:\r\n            return {\r\n                type: NodeType.Comment,\r\n                textContent: n.textContent || '',\r\n                rootId,\r\n            };\r\n        default:\r\n            return false;\r\n    }\r\n}\r\nfunction getRootId(doc, mirror) {\r\n    if (!mirror.hasNode(doc))\r\n        return undefined;\r\n    const docId = mirror.getId(doc);\r\n    return docId === 1 ? undefined : docId;\r\n}\r\nfunction serializeTextNode(n, options) {\r\n    var _a;\r\n    const { needsMask, maskTextFn, rootId } = options;\r\n    const parentTagName = n.parentNode && n.parentNode.tagName;\r\n    let textContent = n.textContent;\r\n    const isStyle = parentTagName === 'STYLE' ? true : undefined;\r\n    const isScript = parentTagName === 'SCRIPT' ? true : undefined;\r\n    if (isStyle && textContent) {\r\n        try {\r\n            if (n.nextSibling || n.previousSibling) {\r\n            }\r\n            else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {\r\n                textContent = stringifyStylesheet(n.parentNode.sheet);\r\n            }\r\n        }\r\n        catch (err) {\r\n            console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);\r\n        }\r\n        textContent = absoluteToStylesheet(textContent, getHref());\r\n    }\r\n    if (isScript) {\r\n        textContent = 'SCRIPT_PLACEHOLDER';\r\n    }\r\n    if (!isStyle && !isScript && textContent && needsMask) {\r\n        textContent = maskTextFn\r\n            ? maskTextFn(textContent, n.parentElement)\r\n            : textContent.replace(/[\\S]/g, '*');\r\n    }\r\n    return {\r\n        type: NodeType.Text,\r\n        textContent: textContent || '',\r\n        isStyle,\r\n        rootId,\r\n    };\r\n}\r\nfunction serializeElementNode(n, options) {\r\n    const { doc, blockClass, blockSelector, inlineStylesheet, maskInputOptions = {}, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId, } = options;\r\n    const needBlock = _isBlockedElement(n, blockClass, blockSelector);\r\n    const tagName = getValidTagName(n);\r\n    let attributes = {};\r\n    const len = n.attributes.length;\r\n    for (let i = 0; i < len; i++) {\r\n        const attr = n.attributes[i];\r\n        if (!ignoreAttribute(tagName, attr.name, attr.value)) {\r\n            attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);\r\n        }\r\n    }\r\n    if (tagName === 'link' && inlineStylesheet) {\r\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\r\n            return s.href === n.href;\r\n        });\r\n        let cssText = null;\r\n        if (stylesheet) {\r\n            cssText = stringifyStylesheet(stylesheet);\r\n        }\r\n        if (cssText) {\r\n            delete attributes.rel;\r\n            delete attributes.href;\r\n            attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);\r\n        }\r\n    }\r\n    if (tagName === 'style' &&\r\n        n.sheet &&\r\n        !(n.innerText || n.textContent || '').trim().length) {\r\n        const cssText = stringifyStylesheet(n.sheet);\r\n        if (cssText) {\r\n            attributes._cssText = absoluteToStylesheet(cssText, getHref());\r\n        }\r\n    }\r\n    if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {\r\n        const value = n.value;\r\n        const checked = n.checked;\r\n        if (attributes.type !== 'radio' &&\r\n            attributes.type !== 'checkbox' &&\r\n            attributes.type !== 'submit' &&\r\n            attributes.type !== 'button' &&\r\n            value) {\r\n            attributes.value = maskInputValue({\r\n                element: n,\r\n                type: getInputType(n),\r\n                tagName,\r\n                value,\r\n                maskInputOptions,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        else if (checked) {\r\n            attributes.checked = checked;\r\n        }\r\n    }\r\n    if (tagName === 'option') {\r\n        if (n.selected && !maskInputOptions['select']) {\r\n            attributes.selected = true;\r\n        }\r\n        else {\r\n            delete attributes.selected;\r\n        }\r\n    }\r\n    if (tagName === 'canvas' && recordCanvas) {\r\n        if (n.__context === '2d') {\r\n            if (!is2DCanvasBlank(n)) {\r\n                attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n        }\r\n        else if (!('__context' in n)) {\r\n            const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            const blankCanvas = document.createElement('canvas');\r\n            blankCanvas.width = n.width;\r\n            blankCanvas.height = n.height;\r\n            const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            if (canvasDataURL !== blankCanvasDataURL) {\r\n                attributes.rr_dataURL = canvasDataURL;\r\n            }\r\n        }\r\n    }\r\n    if (tagName === 'img' && inlineImages) {\r\n        if (!canvasService) {\r\n            canvasService = doc.createElement('canvas');\r\n            canvasCtx = canvasService.getContext('2d');\r\n        }\r\n        const image = n;\r\n        const oldValue = image.crossOrigin;\r\n        image.crossOrigin = 'anonymous';\r\n        const recordInlineImage = () => {\r\n            image.removeEventListener('load', recordInlineImage);\r\n            try {\r\n                canvasService.width = image.naturalWidth;\r\n                canvasService.height = image.naturalHeight;\r\n                canvasCtx.drawImage(image, 0, 0);\r\n                attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);\r\n            }\r\n            catch (err) {\r\n                console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);\r\n            }\r\n            oldValue\r\n                ? (attributes.crossOrigin = oldValue)\r\n                : image.removeAttribute('crossorigin');\r\n        };\r\n        if (image.complete && image.naturalWidth !== 0)\r\n            recordInlineImage();\r\n        else\r\n            image.addEventListener('load', recordInlineImage);\r\n    }\r\n    if (tagName === 'audio' || tagName === 'video') {\r\n        const mediaAttributes = attributes;\r\n        mediaAttributes.rr_mediaState = n.paused\r\n            ? 'paused'\r\n            : 'played';\r\n        mediaAttributes.rr_mediaCurrentTime = n.currentTime;\r\n        mediaAttributes.rr_mediaPlaybackRate = n.playbackRate;\r\n        mediaAttributes.rr_mediaMuted = n.muted;\r\n        mediaAttributes.rr_mediaLoop = n.loop;\r\n        mediaAttributes.rr_mediaVolume = n.volume;\r\n    }\r\n    if (!newlyAddedElement) {\r\n        if (n.scrollLeft) {\r\n            attributes.rr_scrollLeft = n.scrollLeft;\r\n        }\r\n        if (n.scrollTop) {\r\n            attributes.rr_scrollTop = n.scrollTop;\r\n        }\r\n    }\r\n    if (needBlock) {\r\n        const { width, height } = n.getBoundingClientRect();\r\n        attributes = {\r\n            class: attributes.class,\r\n            rr_width: `${width}px`,\r\n            rr_height: `${height}px`,\r\n        };\r\n    }\r\n    if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src)) {\r\n        if (!n.contentDocument) {\r\n            attributes.rr_src = attributes.src;\r\n        }\r\n        delete attributes.src;\r\n    }\r\n    let isCustomElement;\r\n    try {\r\n        if (customElements.get(tagName))\r\n            isCustomElement = true;\r\n    }\r\n    catch (e) {\r\n    }\r\n    return {\r\n        type: NodeType.Element,\r\n        tagName,\r\n        attributes,\r\n        childNodes: [],\r\n        isSVG: isSVGElement(n) || undefined,\r\n        needBlock,\r\n        rootId,\r\n        isCustom: isCustomElement,\r\n    };\r\n}\r\nfunction lowerIfExists(maybeAttr) {\r\n    if (maybeAttr === undefined || maybeAttr === null) {\r\n        return '';\r\n    }\r\n    else {\r\n        return maybeAttr.toLowerCase();\r\n    }\r\n}\r\nfunction slimDOMExcluded(sn, slimDOMOptions) {\r\n    if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\r\n        return true;\r\n    }\r\n    else if (sn.type === NodeType.Element) {\r\n        if (slimDOMOptions.script &&\r\n            (sn.tagName === 'script' ||\r\n                (sn.tagName === 'link' &&\r\n                    (sn.attributes.rel === 'preload' ||\r\n                        sn.attributes.rel === 'modulepreload') &&\r\n                    sn.attributes.as === 'script') ||\r\n                (sn.tagName === 'link' &&\r\n                    sn.attributes.rel === 'prefetch' &&\r\n                    typeof sn.attributes.href === 'string' &&\r\n                    extractFileExtension(sn.attributes.href) === 'js'))) {\r\n            return true;\r\n        }\r\n        else if (slimDOMOptions.headFavicon &&\r\n            ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\r\n                (sn.tagName === 'meta' &&\r\n                    (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) ||\r\n                        lowerIfExists(sn.attributes.name) === 'application-name' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\r\n                        lowerIfExists(sn.attributes.rel) === 'shortcut icon')))) {\r\n            return true;\r\n        }\r\n        else if (sn.tagName === 'meta') {\r\n            if (slimDOMOptions.headMetaDescKeywords &&\r\n                lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaSocial &&\r\n                (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) ||\r\n                    lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\r\n                    lowerIfExists(sn.attributes.name) === 'pinterest')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaRobots &&\r\n                (lowerIfExists(sn.attributes.name) === 'robots' ||\r\n                    lowerIfExists(sn.attributes.name) === 'googlebot' ||\r\n                    lowerIfExists(sn.attributes.name) === 'bingbot')) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaHttpEquiv &&\r\n                sn.attributes['http-equiv'] !== undefined) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaAuthorship &&\r\n                (lowerIfExists(sn.attributes.name) === 'author' ||\r\n                    lowerIfExists(sn.attributes.name) === 'generator' ||\r\n                    lowerIfExists(sn.attributes.name) === 'framework' ||\r\n                    lowerIfExists(sn.attributes.name) === 'publisher' ||\r\n                    lowerIfExists(sn.attributes.name) === 'progid' ||\r\n                    lowerIfExists(sn.attributes.property).match(/^article:/) ||\r\n                    lowerIfExists(sn.attributes.property).match(/^product:/))) {\r\n                return true;\r\n            }\r\n            else if (slimDOMOptions.headMetaVerification &&\r\n                (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'csrf-token' ||\r\n                    lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verify-v1' ||\r\n                    lowerIfExists(sn.attributes.name) === 'verification' ||\r\n                    lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction serializeNodeWithId(n, options) {\r\n    const { doc, mirror, blockClass, blockSelector, maskTextClass, maskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5000, onStylesheetLoad, stylesheetLoadTimeout = 5000, keepIframeSrcFn = () => false, newlyAddedElement = false, } = options;\r\n    let { needsMask } = options;\r\n    let { preserveWhiteSpace = true } = options;\r\n    if (!needsMask &&\r\n        n.childNodes) {\r\n        const checkAncestors = needsMask === undefined;\r\n        needsMask = needMaskingText(n, maskTextClass, maskTextSelector, checkAncestors);\r\n    }\r\n    const _serializedNode = serializeNode(n, {\r\n        doc,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        needsMask,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement,\r\n    });\r\n    if (!_serializedNode) {\r\n        console.warn(n, 'not serialized');\r\n        return null;\r\n    }\r\n    let id;\r\n    if (mirror.hasNode(n)) {\r\n        id = mirror.getId(n);\r\n    }\r\n    else if (slimDOMExcluded(_serializedNode, slimDOMOptions) ||\r\n        (!preserveWhiteSpace &&\r\n            _serializedNode.type === NodeType.Text &&\r\n            !_serializedNode.isStyle &&\r\n            !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)) {\r\n        id = IGNORED_NODE;\r\n    }\r\n    else {\r\n        id = genId();\r\n    }\r\n    const serializedNode = Object.assign(_serializedNode, { id });\r\n    mirror.add(n, serializedNode);\r\n    if (id === IGNORED_NODE) {\r\n        return null;\r\n    }\r\n    if (onSerialize) {\r\n        onSerialize(n);\r\n    }\r\n    let recordChild = !skipChild;\r\n    if (serializedNode.type === NodeType.Element) {\r\n        recordChild = recordChild && !serializedNode.needBlock;\r\n        delete serializedNode.needBlock;\r\n        const shadowRoot = n.shadowRoot;\r\n        if (shadowRoot && isNativeShadowDom(shadowRoot))\r\n            serializedNode.isShadowHost = true;\r\n    }\r\n    if ((serializedNode.type === NodeType.Document ||\r\n        serializedNode.type === NodeType.Element) &&\r\n        recordChild) {\r\n        if (slimDOMOptions.headWhitespace &&\r\n            serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'head') {\r\n            preserveWhiteSpace = false;\r\n        }\r\n        const bypassOptions = {\r\n            doc,\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            needsMask,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            skipChild,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            slimDOMOptions,\r\n            dataURLOptions,\r\n            inlineImages,\r\n            recordCanvas,\r\n            preserveWhiteSpace,\r\n            onSerialize,\r\n            onIframeLoad,\r\n            iframeLoadTimeout,\r\n            onStylesheetLoad,\r\n            stylesheetLoadTimeout,\r\n            keepIframeSrcFn,\r\n        };\r\n        if (serializedNode.type === NodeType.Element &&\r\n            serializedNode.tagName === 'textarea' &&\r\n            serializedNode.attributes.value !== undefined) ;\r\n        else {\r\n            for (const childN of Array.from(n.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n        if (isElement(n) && n.shadowRoot) {\r\n            for (const childN of Array.from(n.shadowRoot.childNodes)) {\r\n                const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\r\n                if (serializedChildNode) {\r\n                    isNativeShadowDom(n.shadowRoot) &&\r\n                        (serializedChildNode.isShadow = true);\r\n                    serializedNode.childNodes.push(serializedChildNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (n.parentNode &&\r\n        isShadowRoot(n.parentNode) &&\r\n        isNativeShadowDom(n.parentNode)) {\r\n        serializedNode.isShadow = true;\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'iframe') {\r\n        onceIframeLoaded(n, () => {\r\n            const iframeDoc = n.contentDocument;\r\n            if (iframeDoc && onIframeLoad) {\r\n                const serializedIframeNode = serializeNodeWithId(iframeDoc, {\r\n                    doc: iframeDoc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    needsMask,\r\n                    maskTextClass,\r\n                    maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedIframeNode) {\r\n                    onIframeLoad(n, serializedIframeNode);\r\n                }\r\n            }\r\n        }, iframeLoadTimeout);\r\n    }\r\n    if (serializedNode.type === NodeType.Element &&\r\n        serializedNode.tagName === 'link' &&\r\n        typeof serializedNode.attributes.rel === 'string' &&\r\n        (serializedNode.attributes.rel === 'stylesheet' ||\r\n            (serializedNode.attributes.rel === 'preload' &&\r\n                typeof serializedNode.attributes.href === 'string' &&\r\n                extractFileExtension(serializedNode.attributes.href) === 'css'))) {\r\n        onceStylesheetLoaded(n, () => {\r\n            if (onStylesheetLoad) {\r\n                const serializedLinkNode = serializeNodeWithId(n, {\r\n                    doc,\r\n                    mirror,\r\n                    blockClass,\r\n                    blockSelector,\r\n                    needsMask,\r\n                    maskTextClass,\r\n                    maskTextSelector,\r\n                    skipChild: false,\r\n                    inlineStylesheet,\r\n                    maskInputOptions,\r\n                    maskTextFn,\r\n                    maskInputFn,\r\n                    slimDOMOptions,\r\n                    dataURLOptions,\r\n                    inlineImages,\r\n                    recordCanvas,\r\n                    preserveWhiteSpace,\r\n                    onSerialize,\r\n                    onIframeLoad,\r\n                    iframeLoadTimeout,\r\n                    onStylesheetLoad,\r\n                    stylesheetLoadTimeout,\r\n                    keepIframeSrcFn,\r\n                });\r\n                if (serializedLinkNode) {\r\n                    onStylesheetLoad(n, serializedLinkNode);\r\n                }\r\n            }\r\n        }, stylesheetLoadTimeout);\r\n    }\r\n    return serializedNode;\r\n}\r\nfunction snapshot(n, options) {\r\n    const { mirror = new Mirror(), blockClass = 'rr-block', blockSelector = null, maskTextClass = 'rr-mask', maskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false, } = options || {};\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            password: true,\r\n        }\r\n        : maskAllInputs === false\r\n            ? {\r\n                password: true,\r\n            }\r\n            : maskAllInputs;\r\n    const slimDOMOptions = slimDOM === true || slimDOM === 'all'\r\n        ?\r\n            {\r\n                script: true,\r\n                comment: true,\r\n                headFavicon: true,\r\n                headWhitespace: true,\r\n                headMetaDescKeywords: slimDOM === 'all',\r\n                headMetaSocial: true,\r\n                headMetaRobots: true,\r\n                headMetaHttpEquiv: true,\r\n                headMetaAuthorship: true,\r\n                headMetaVerification: true,\r\n            }\r\n        : slimDOM === false\r\n            ? {}\r\n            : slimDOM;\r\n    return serializeNodeWithId(n, {\r\n        doc: n,\r\n        mirror,\r\n        blockClass,\r\n        blockSelector,\r\n        maskTextClass,\r\n        maskTextSelector,\r\n        skipChild: false,\r\n        inlineStylesheet,\r\n        maskInputOptions,\r\n        maskTextFn,\r\n        maskInputFn,\r\n        slimDOMOptions,\r\n        dataURLOptions,\r\n        inlineImages,\r\n        recordCanvas,\r\n        preserveWhiteSpace,\r\n        onSerialize,\r\n        onIframeLoad,\r\n        iframeLoadTimeout,\r\n        onStylesheetLoad,\r\n        stylesheetLoadTimeout,\r\n        keepIframeSrcFn,\r\n        newlyAddedElement: false,\r\n    });\r\n}\n\nfunction on(type, fn, target = document) {\r\n    const options = { capture: true, passive: true };\r\n    target.addEventListener(type, fn, options);\r\n    return () => target.removeEventListener(type, fn, options);\r\n}\r\nconst DEPARTED_MIRROR_ACCESS_WARNING = 'Please stop import mirror directly. Instead of that,' +\r\n    '\\r\\n' +\r\n    'now you can use replayer.getMirror() to access the mirror instance of a replayer,' +\r\n    '\\r\\n' +\r\n    'or you can use record.mirror to access the mirror instance during recording.';\r\nlet _mirror = {\r\n    map: {},\r\n    getId() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return -1;\r\n    },\r\n    getNode() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return null;\r\n    },\r\n    removeNodeFromMap() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n    has() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n        return false;\r\n    },\r\n    reset() {\r\n        console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n    },\r\n};\r\nif (typeof window !== 'undefined' && window.Proxy && window.Reflect) {\r\n    _mirror = new Proxy(_mirror, {\r\n        get(target, prop, receiver) {\r\n            if (prop === 'map') {\r\n                console.error(DEPARTED_MIRROR_ACCESS_WARNING);\r\n            }\r\n            return Reflect.get(target, prop, receiver);\r\n        },\r\n    });\r\n}\r\nfunction throttle(func, wait, options = {}) {\r\n    let timeout = null;\r\n    let previous = 0;\r\n    return function (...args) {\r\n        const now = Date.now();\r\n        if (!previous && options.leading === false) {\r\n            previous = now;\r\n        }\r\n        const remaining = wait - (now - previous);\r\n        const context = this;\r\n        if (remaining <= 0 || remaining > wait) {\r\n            if (timeout) {\r\n                clearTimeout(timeout);\r\n                timeout = null;\r\n            }\r\n            previous = now;\r\n            func.apply(context, args);\r\n        }\r\n        else if (!timeout && options.trailing !== false) {\r\n            timeout = setTimeout(() => {\r\n                previous = options.leading === false ? 0 : Date.now();\r\n                timeout = null;\r\n                func.apply(context, args);\r\n            }, remaining);\r\n        }\r\n    };\r\n}\r\nfunction hookSetter(target, key, d, isRevoked, win = window) {\r\n    const original = win.Object.getOwnPropertyDescriptor(target, key);\r\n    win.Object.defineProperty(target, key, isRevoked\r\n        ? d\r\n        : {\r\n            set(value) {\r\n                setTimeout(() => {\r\n                    d.set.call(this, value);\r\n                }, 0);\r\n                if (original && original.set) {\r\n                    original.set.call(this, value);\r\n                }\r\n            },\r\n        });\r\n    return () => hookSetter(target, key, original || {}, true);\r\n}\r\nfunction patch(source, name, replacement) {\r\n    try {\r\n        if (!(name in source)) {\r\n            return () => {\r\n            };\r\n        }\r\n        const original = source[name];\r\n        const wrapped = replacement(original);\r\n        if (typeof wrapped === 'function') {\r\n            wrapped.prototype = wrapped.prototype || {};\r\n            Object.defineProperties(wrapped, {\r\n                __rrweb_original__: {\r\n                    enumerable: false,\r\n                    value: original,\r\n                },\r\n            });\r\n        }\r\n        source[name] = wrapped;\r\n        return () => {\r\n            source[name] = original;\r\n        };\r\n    }\r\n    catch (_a) {\r\n        return () => {\r\n        };\r\n    }\r\n}\r\nlet nowTimestamp = Date.now;\r\nif (!(/[1-9][0-9]{12}/.test(Date.now().toString()))) {\r\n    nowTimestamp = () => new Date().getTime();\r\n}\r\nfunction getWindowScroll(win) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const doc = win.document;\r\n    return {\r\n        left: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollLeft\r\n            : win.pageXOffset !== undefined\r\n                ? win.pageXOffset\r\n                : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollLeft) ||\r\n                    ((_b = (_a = doc === null || doc === void 0 ? void 0 : doc.body) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.scrollLeft) ||\r\n                    ((_c = doc === null || doc === void 0 ? void 0 : doc.body) === null || _c === void 0 ? void 0 : _c.scrollLeft) ||\r\n                    0,\r\n        top: doc.scrollingElement\r\n            ? doc.scrollingElement.scrollTop\r\n            : win.pageYOffset !== undefined\r\n                ? win.pageYOffset\r\n                : (doc === null || doc === void 0 ? void 0 : doc.documentElement.scrollTop) ||\r\n                    ((_e = (_d = doc === null || doc === void 0 ? void 0 : doc.body) === null || _d === void 0 ? void 0 : _d.parentElement) === null || _e === void 0 ? void 0 : _e.scrollTop) ||\r\n                    ((_f = doc === null || doc === void 0 ? void 0 : doc.body) === null || _f === void 0 ? void 0 : _f.scrollTop) ||\r\n                    0,\r\n    };\r\n}\r\nfunction getWindowHeight() {\r\n    return (window.innerHeight ||\r\n        (document.documentElement && document.documentElement.clientHeight) ||\r\n        (document.body && document.body.clientHeight));\r\n}\r\nfunction getWindowWidth() {\r\n    return (window.innerWidth ||\r\n        (document.documentElement && document.documentElement.clientWidth) ||\r\n        (document.body && document.body.clientWidth));\r\n}\r\nfunction closestElementOfNode(node) {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    const el = node.nodeType === node.ELEMENT_NODE\r\n        ? node\r\n        : node.parentElement;\r\n    return el;\r\n}\r\nfunction isBlocked(node, blockClass, blockSelector, checkAncestors) {\r\n    if (!node) {\r\n        return false;\r\n    }\r\n    const el = closestElementOfNode(node);\r\n    if (!el) {\r\n        return false;\r\n    }\r\n    try {\r\n        if (typeof blockClass === 'string') {\r\n            if (el.classList.contains(blockClass))\r\n                return true;\r\n            if (checkAncestors && el.closest('.' + blockClass) !== null)\r\n                return true;\r\n        }\r\n        else {\r\n            if (classMatchesRegex(el, blockClass, checkAncestors))\r\n                return true;\r\n        }\r\n    }\r\n    catch (e) {\r\n    }\r\n    if (blockSelector) {\r\n        if (el.matches(blockSelector))\r\n            return true;\r\n        if (checkAncestors && el.closest(blockSelector) !== null)\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction isSerialized(n, mirror) {\r\n    return mirror.getId(n) !== -1;\r\n}\r\nfunction isIgnored(n, mirror) {\r\n    return mirror.getId(n) === IGNORED_NODE;\r\n}\r\nfunction isAncestorRemoved(target, mirror) {\r\n    if (isShadowRoot(target)) {\r\n        return false;\r\n    }\r\n    const id = mirror.getId(target);\r\n    if (!mirror.has(id)) {\r\n        return true;\r\n    }\r\n    if (target.parentNode &&\r\n        target.parentNode.nodeType === target.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    if (!target.parentNode) {\r\n        return true;\r\n    }\r\n    return isAncestorRemoved(target.parentNode, mirror);\r\n}\r\nfunction legacy_isTouchEvent(event) {\r\n    return Boolean(event.changedTouches);\r\n}\r\nfunction polyfill(win = window) {\r\n    if ('NodeList' in win && !win.NodeList.prototype.forEach) {\r\n        win.NodeList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if ('DOMTokenList' in win && !win.DOMTokenList.prototype.forEach) {\r\n        win.DOMTokenList.prototype.forEach = Array.prototype\r\n            .forEach;\r\n    }\r\n    if (!Node.prototype.contains) {\r\n        Node.prototype.contains = (...args) => {\r\n            let node = args[0];\r\n            if (!(0 in args)) {\r\n                throw new TypeError('1 argument is required');\r\n            }\r\n            do {\r\n                if (this === node) {\r\n                    return true;\r\n                }\r\n            } while ((node = node && node.parentNode));\r\n            return false;\r\n        };\r\n    }\r\n}\r\nfunction isSerializedIframe(n, mirror) {\r\n    return Boolean(n.nodeName === 'IFRAME' && mirror.getMeta(n));\r\n}\r\nfunction isSerializedStylesheet(n, mirror) {\r\n    return Boolean(n.nodeName === 'LINK' &&\r\n        n.nodeType === n.ELEMENT_NODE &&\r\n        n.getAttribute &&\r\n        n.getAttribute('rel') === 'stylesheet' &&\r\n        mirror.getMeta(n));\r\n}\r\nfunction hasShadowRoot(n) {\r\n    return Boolean(n === null || n === void 0 ? void 0 : n.shadowRoot);\r\n}\r\nclass StyleSheetMirror {\r\n    constructor() {\r\n        this.id = 1;\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n    }\r\n    getId(stylesheet) {\r\n        var _a;\r\n        return (_a = this.styleIDMap.get(stylesheet)) !== null && _a !== void 0 ? _a : -1;\r\n    }\r\n    has(stylesheet) {\r\n        return this.styleIDMap.has(stylesheet);\r\n    }\r\n    add(stylesheet, id) {\r\n        if (this.has(stylesheet))\r\n            return this.getId(stylesheet);\r\n        let newId;\r\n        if (id === undefined) {\r\n            newId = this.id++;\r\n        }\r\n        else\r\n            newId = id;\r\n        this.styleIDMap.set(stylesheet, newId);\r\n        this.idStyleMap.set(newId, stylesheet);\r\n        return newId;\r\n    }\r\n    getStyle(id) {\r\n        return this.idStyleMap.get(id) || null;\r\n    }\r\n    reset() {\r\n        this.styleIDMap = new WeakMap();\r\n        this.idStyleMap = new Map();\r\n        this.id = 1;\r\n    }\r\n    generateId() {\r\n        return this.id++;\r\n    }\r\n}\r\nfunction getShadowHost(n) {\r\n    var _a, _b;\r\n    let shadowHost = null;\r\n    if (((_b = (_a = n.getRootNode) === null || _a === void 0 ? void 0 : _a.call(n)) === null || _b === void 0 ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE &&\r\n        n.getRootNode().host)\r\n        shadowHost = n.getRootNode().host;\r\n    return shadowHost;\r\n}\r\nfunction getRootShadowHost(n) {\r\n    let rootShadowHost = n;\r\n    let shadowHost;\r\n    while ((shadowHost = getShadowHost(rootShadowHost)))\r\n        rootShadowHost = shadowHost;\r\n    return rootShadowHost;\r\n}\r\nfunction shadowHostInDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    const shadowHost = getRootShadowHost(n);\r\n    return doc.contains(shadowHost);\r\n}\r\nfunction inDom(n) {\r\n    const doc = n.ownerDocument;\r\n    if (!doc)\r\n        return false;\r\n    return doc.contains(n) || shadowHostInDom(n);\r\n}\n\nvar EventType$1 = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType$1 || {});\nvar IncrementalSource$1 = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource$1 || {});\nvar MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {\n  MouseInteractions2[MouseInteractions2[\"MouseUp\"] = 0] = \"MouseUp\";\n  MouseInteractions2[MouseInteractions2[\"MouseDown\"] = 1] = \"MouseDown\";\n  MouseInteractions2[MouseInteractions2[\"Click\"] = 2] = \"Click\";\n  MouseInteractions2[MouseInteractions2[\"ContextMenu\"] = 3] = \"ContextMenu\";\n  MouseInteractions2[MouseInteractions2[\"DblClick\"] = 4] = \"DblClick\";\n  MouseInteractions2[MouseInteractions2[\"Focus\"] = 5] = \"Focus\";\n  MouseInteractions2[MouseInteractions2[\"Blur\"] = 6] = \"Blur\";\n  MouseInteractions2[MouseInteractions2[\"TouchStart\"] = 7] = \"TouchStart\";\n  MouseInteractions2[MouseInteractions2[\"TouchMove_Departed\"] = 8] = \"TouchMove_Departed\";\n  MouseInteractions2[MouseInteractions2[\"TouchEnd\"] = 9] = \"TouchEnd\";\n  MouseInteractions2[MouseInteractions2[\"TouchCancel\"] = 10] = \"TouchCancel\";\n  return MouseInteractions2;\n})(MouseInteractions || {});\nvar PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {\n  PointerTypes2[PointerTypes2[\"Mouse\"] = 0] = \"Mouse\";\n  PointerTypes2[PointerTypes2[\"Pen\"] = 1] = \"Pen\";\n  PointerTypes2[PointerTypes2[\"Touch\"] = 2] = \"Touch\";\n  return PointerTypes2;\n})(PointerTypes || {});\nvar CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {\n  CanvasContext2[CanvasContext2[\"2D\"] = 0] = \"2D\";\n  CanvasContext2[CanvasContext2[\"WebGL\"] = 1] = \"WebGL\";\n  CanvasContext2[CanvasContext2[\"WebGL2\"] = 2] = \"WebGL2\";\n  return CanvasContext2;\n})(CanvasContext || {});\n\nfunction isNodeInLinkedList(n) {\r\n    return '__ln' in n;\r\n}\r\nclass DoubleLinkedList {\r\n    constructor() {\r\n        this.length = 0;\r\n        this.head = null;\r\n        this.tail = null;\r\n    }\r\n    get(position) {\r\n        if (position >= this.length) {\r\n            throw new Error('Position outside of list range');\r\n        }\r\n        let current = this.head;\r\n        for (let index = 0; index < position; index++) {\r\n            current = (current === null || current === void 0 ? void 0 : current.next) || null;\r\n        }\r\n        return current;\r\n    }\r\n    addNode(n) {\r\n        const node = {\r\n            value: n,\r\n            previous: null,\r\n            next: null,\r\n        };\r\n        n.__ln = node;\r\n        if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {\r\n            const current = n.previousSibling.__ln.next;\r\n            node.next = current;\r\n            node.previous = n.previousSibling.__ln;\r\n            n.previousSibling.__ln.next = node;\r\n            if (current) {\r\n                current.previous = node;\r\n            }\r\n        }\r\n        else if (n.nextSibling &&\r\n            isNodeInLinkedList(n.nextSibling) &&\r\n            n.nextSibling.__ln.previous) {\r\n            const current = n.nextSibling.__ln.previous;\r\n            node.previous = current;\r\n            node.next = n.nextSibling.__ln;\r\n            n.nextSibling.__ln.previous = node;\r\n            if (current) {\r\n                current.next = node;\r\n            }\r\n        }\r\n        else {\r\n            if (this.head) {\r\n                this.head.previous = node;\r\n            }\r\n            node.next = this.head;\r\n            this.head = node;\r\n        }\r\n        if (node.next === null) {\r\n            this.tail = node;\r\n        }\r\n        this.length++;\r\n    }\r\n    removeNode(n) {\r\n        const current = n.__ln;\r\n        if (!this.head) {\r\n            return;\r\n        }\r\n        if (!current.previous) {\r\n            this.head = current.next;\r\n            if (this.head) {\r\n                this.head.previous = null;\r\n            }\r\n            else {\r\n                this.tail = null;\r\n            }\r\n        }\r\n        else {\r\n            current.previous.next = current.next;\r\n            if (current.next) {\r\n                current.next.previous = current.previous;\r\n            }\r\n            else {\r\n                this.tail = current.previous;\r\n            }\r\n        }\r\n        if (n.__ln) {\r\n            delete n.__ln;\r\n        }\r\n        this.length--;\r\n    }\r\n}\r\nconst moveKey = (id, parentId) => `${id}@${parentId}`;\r\nclass MutationBuffer {\r\n    constructor() {\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.texts = [];\r\n        this.attributes = [];\r\n        this.attributeMap = new WeakMap();\r\n        this.removes = [];\r\n        this.mapRemoves = [];\r\n        this.movedMap = {};\r\n        this.addedSet = new Set();\r\n        this.movedSet = new Set();\r\n        this.droppedSet = new Set();\r\n        this.processMutations = (mutations) => {\r\n            mutations.forEach(this.processMutation);\r\n            this.emit();\r\n        };\r\n        this.emit = () => {\r\n            if (this.frozen || this.locked) {\r\n                return;\r\n            }\r\n            const adds = [];\r\n            const addedIds = new Set();\r\n            const addList = new DoubleLinkedList();\r\n            const getNextId = (n) => {\r\n                let ns = n;\r\n                let nextId = IGNORED_NODE;\r\n                while (nextId === IGNORED_NODE) {\r\n                    ns = ns && ns.nextSibling;\r\n                    nextId = ns && this.mirror.getId(ns);\r\n                }\r\n                return nextId;\r\n            };\r\n            const pushAdd = (n) => {\r\n                if (!n.parentNode ||\r\n                    !inDom(n) ||\r\n                    n.parentNode.tagName === 'TEXTAREA') {\r\n                    return;\r\n                }\r\n                const parentId = isShadowRoot(n.parentNode)\r\n                    ? this.mirror.getId(getShadowHost(n))\r\n                    : this.mirror.getId(n.parentNode);\r\n                const nextId = getNextId(n);\r\n                if (parentId === -1 || nextId === -1) {\r\n                    return addList.addNode(n);\r\n                }\r\n                const sn = serializeNodeWithId(n, {\r\n                    doc: this.doc,\r\n                    mirror: this.mirror,\r\n                    blockClass: this.blockClass,\r\n                    blockSelector: this.blockSelector,\r\n                    maskTextClass: this.maskTextClass,\r\n                    maskTextSelector: this.maskTextSelector,\r\n                    skipChild: true,\r\n                    newlyAddedElement: true,\r\n                    inlineStylesheet: this.inlineStylesheet,\r\n                    maskInputOptions: this.maskInputOptions,\r\n                    maskTextFn: this.maskTextFn,\r\n                    maskInputFn: this.maskInputFn,\r\n                    slimDOMOptions: this.slimDOMOptions,\r\n                    dataURLOptions: this.dataURLOptions,\r\n                    recordCanvas: this.recordCanvas,\r\n                    inlineImages: this.inlineImages,\r\n                    onSerialize: (currentN) => {\r\n                        if (isSerializedIframe(currentN, this.mirror)) {\r\n                            this.iframeManager.addIframe(currentN);\r\n                        }\r\n                        if (isSerializedStylesheet(currentN, this.mirror)) {\r\n                            this.stylesheetManager.trackLinkElement(currentN);\r\n                        }\r\n                        if (hasShadowRoot(n)) {\r\n                            this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);\r\n                        }\r\n                    },\r\n                    onIframeLoad: (iframe, childSn) => {\r\n                        this.iframeManager.attachIframe(iframe, childSn);\r\n                        this.shadowDomManager.observeAttachShadow(iframe);\r\n                    },\r\n                    onStylesheetLoad: (link, childSn) => {\r\n                        this.stylesheetManager.attachLinkElement(link, childSn);\r\n                    },\r\n                });\r\n                if (sn) {\r\n                    adds.push({\r\n                        parentId,\r\n                        nextId,\r\n                        node: sn,\r\n                    });\r\n                    addedIds.add(sn.id);\r\n                }\r\n            };\r\n            while (this.mapRemoves.length) {\r\n                this.mirror.removeNodeFromMap(this.mapRemoves.shift());\r\n            }\r\n            for (const n of this.movedSet) {\r\n                if (isParentRemoved(this.removes, n, this.mirror) &&\r\n                    !this.movedSet.has(n.parentNode)) {\r\n                    continue;\r\n                }\r\n                pushAdd(n);\r\n            }\r\n            for (const n of this.addedSet) {\r\n                if (!isAncestorInSet(this.droppedSet, n) &&\r\n                    !isParentRemoved(this.removes, n, this.mirror)) {\r\n                    pushAdd(n);\r\n                }\r\n                else if (isAncestorInSet(this.movedSet, n)) {\r\n                    pushAdd(n);\r\n                }\r\n                else {\r\n                    this.droppedSet.add(n);\r\n                }\r\n            }\r\n            let candidate = null;\r\n            while (addList.length) {\r\n                let node = null;\r\n                if (candidate) {\r\n                    const parentId = this.mirror.getId(candidate.value.parentNode);\r\n                    const nextId = getNextId(candidate.value);\r\n                    if (parentId !== -1 && nextId !== -1) {\r\n                        node = candidate;\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    let tailNode = addList.tail;\r\n                    while (tailNode) {\r\n                        const _node = tailNode;\r\n                        tailNode = tailNode.previous;\r\n                        if (_node) {\r\n                            const parentId = this.mirror.getId(_node.value.parentNode);\r\n                            const nextId = getNextId(_node.value);\r\n                            if (nextId === -1)\r\n                                continue;\r\n                            else if (parentId !== -1) {\r\n                                node = _node;\r\n                                break;\r\n                            }\r\n                            else {\r\n                                const unhandledNode = _node.value;\r\n                                if (unhandledNode.parentNode &&\r\n                                    unhandledNode.parentNode.nodeType ===\r\n                                        Node.DOCUMENT_FRAGMENT_NODE) {\r\n                                    const shadowHost = unhandledNode.parentNode\r\n                                        .host;\r\n                                    const parentId = this.mirror.getId(shadowHost);\r\n                                    if (parentId !== -1) {\r\n                                        node = _node;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (!node) {\r\n                    while (addList.head) {\r\n                        addList.removeNode(addList.head.value);\r\n                    }\r\n                    break;\r\n                }\r\n                candidate = node.previous;\r\n                addList.removeNode(node.value);\r\n                pushAdd(node.value);\r\n            }\r\n            const payload = {\r\n                texts: this.texts\r\n                    .map((text) => {\r\n                    const n = text.node;\r\n                    if (n.parentNode &&\r\n                        n.parentNode.tagName === 'TEXTAREA') {\r\n                        this.genTextAreaValueMutation(n.parentNode);\r\n                    }\r\n                    return {\r\n                        id: this.mirror.getId(n),\r\n                        value: text.value,\r\n                    };\r\n                })\r\n                    .filter((text) => !addedIds.has(text.id))\r\n                    .filter((text) => this.mirror.has(text.id)),\r\n                attributes: this.attributes\r\n                    .map((attribute) => {\r\n                    const { attributes } = attribute;\r\n                    if (typeof attributes.style === 'string') {\r\n                        const diffAsStr = JSON.stringify(attribute.styleDiff);\r\n                        const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);\r\n                        if (diffAsStr.length < attributes.style.length) {\r\n                            if ((diffAsStr + unchangedAsStr).split('var(').length ===\r\n                                attributes.style.split('var(').length) {\r\n                                attributes.style = attribute.styleDiff;\r\n                            }\r\n                        }\r\n                    }\r\n                    return {\r\n                        id: this.mirror.getId(attribute.node),\r\n                        attributes: attributes,\r\n                    };\r\n                })\r\n                    .filter((attribute) => !addedIds.has(attribute.id))\r\n                    .filter((attribute) => this.mirror.has(attribute.id)),\r\n                removes: this.removes,\r\n                adds,\r\n            };\r\n            if (!payload.texts.length &&\r\n                !payload.attributes.length &&\r\n                !payload.removes.length &&\r\n                !payload.adds.length) {\r\n                return;\r\n            }\r\n            this.texts = [];\r\n            this.attributes = [];\r\n            this.attributeMap = new WeakMap();\r\n            this.removes = [];\r\n            this.addedSet = new Set();\r\n            this.movedSet = new Set();\r\n            this.droppedSet = new Set();\r\n            this.movedMap = {};\r\n            this.mutationCb(payload);\r\n        };\r\n        this.genTextAreaValueMutation = (textarea) => {\r\n            let item = this.attributeMap.get(textarea);\r\n            if (!item) {\r\n                item = {\r\n                    node: textarea,\r\n                    attributes: {},\r\n                    styleDiff: {},\r\n                    _unchangedStyles: {},\r\n                };\r\n                this.attributes.push(item);\r\n                this.attributeMap.set(textarea, item);\r\n            }\r\n            item.attributes.value = Array.from(textarea.childNodes, (cn) => cn.textContent || '').join('');\r\n        };\r\n        this.processMutation = (m) => {\r\n            if (isIgnored(m.target, this.mirror)) {\r\n                return;\r\n            }\r\n            switch (m.type) {\r\n                case 'characterData': {\r\n                    const value = m.target.textContent;\r\n                    if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) &&\r\n                        value !== m.oldValue) {\r\n                        this.texts.push({\r\n                            value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, true) && value\r\n                                ? this.maskTextFn\r\n                                    ? this.maskTextFn(value, closestElementOfNode(m.target))\r\n                                    : value.replace(/[\\S]/g, '*')\r\n                                : value,\r\n                            node: m.target,\r\n                        });\r\n                    }\r\n                    break;\r\n                }\r\n                case 'attributes': {\r\n                    const target = m.target;\r\n                    let attributeName = m.attributeName;\r\n                    let value = m.target.getAttribute(attributeName);\r\n                    if (attributeName === 'value') {\r\n                        const type = getInputType(target);\r\n                        value = maskInputValue({\r\n                            element: target,\r\n                            maskInputOptions: this.maskInputOptions,\r\n                            tagName: target.tagName,\r\n                            type,\r\n                            value,\r\n                            maskInputFn: this.maskInputFn,\r\n                        });\r\n                    }\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||\r\n                        value === m.oldValue) {\r\n                        return;\r\n                    }\r\n                    let item = this.attributeMap.get(m.target);\r\n                    if (target.tagName === 'IFRAME' &&\r\n                        attributeName === 'src' &&\r\n                        !this.keepIframeSrcFn(value)) {\r\n                        if (!target.contentDocument) {\r\n                            attributeName = 'rr_src';\r\n                        }\r\n                        else {\r\n                            return;\r\n                        }\r\n                    }\r\n                    if (!item) {\r\n                        item = {\r\n                            node: m.target,\r\n                            attributes: {},\r\n                            styleDiff: {},\r\n                            _unchangedStyles: {},\r\n                        };\r\n                        this.attributes.push(item);\r\n                        this.attributeMap.set(m.target, item);\r\n                    }\r\n                    if (attributeName === 'type' &&\r\n                        target.tagName === 'INPUT' &&\r\n                        (m.oldValue || '').toLowerCase() === 'password') {\r\n                        target.setAttribute('data-rr-is-password', 'true');\r\n                    }\r\n                    if (!ignoreAttribute(target.tagName, attributeName)) {\r\n                        item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value);\r\n                        if (attributeName === 'style') {\r\n                            if (!this.unattachedDoc) {\r\n                                try {\r\n                                    this.unattachedDoc =\r\n                                        document.implementation.createHTMLDocument();\r\n                                }\r\n                                catch (e) {\r\n                                    this.unattachedDoc = this.doc;\r\n                                }\r\n                            }\r\n                            const old = this.unattachedDoc.createElement('span');\r\n                            if (m.oldValue) {\r\n                                old.setAttribute('style', m.oldValue);\r\n                            }\r\n                            for (const pname of Array.from(target.style)) {\r\n                                const newValue = target.style.getPropertyValue(pname);\r\n                                const newPriority = target.style.getPropertyPriority(pname);\r\n                                if (newValue !== old.style.getPropertyValue(pname) ||\r\n                                    newPriority !== old.style.getPropertyPriority(pname)) {\r\n                                    if (newPriority === '') {\r\n                                        item.styleDiff[pname] = newValue;\r\n                                    }\r\n                                    else {\r\n                                        item.styleDiff[pname] = [newValue, newPriority];\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    item._unchangedStyles[pname] = [newValue, newPriority];\r\n                                }\r\n                            }\r\n                            for (const pname of Array.from(old.style)) {\r\n                                if (target.style.getPropertyValue(pname) === '') {\r\n                                    item.styleDiff[pname] = false;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n                case 'childList': {\r\n                    if (isBlocked(m.target, this.blockClass, this.blockSelector, true))\r\n                        return;\r\n                    if (m.target.tagName === 'TEXTAREA') {\r\n                        this.genTextAreaValueMutation(m.target);\r\n                        return;\r\n                    }\r\n                    m.addedNodes.forEach((n) => this.genAdds(n, m.target));\r\n                    m.removedNodes.forEach((n) => {\r\n                        const nodeId = this.mirror.getId(n);\r\n                        const parentId = isShadowRoot(m.target)\r\n                            ? this.mirror.getId(m.target.host)\r\n                            : this.mirror.getId(m.target);\r\n                        if (isBlocked(m.target, this.blockClass, this.blockSelector, false) ||\r\n                            isIgnored(n, this.mirror) ||\r\n                            !isSerialized(n, this.mirror)) {\r\n                            return;\r\n                        }\r\n                        if (this.addedSet.has(n)) {\r\n                            deepDelete(this.addedSet, n);\r\n                            this.droppedSet.add(n);\r\n                        }\r\n                        else if (this.addedSet.has(m.target) && nodeId === -1) ;\r\n                        else if (isAncestorRemoved(m.target, this.mirror)) ;\r\n                        else if (this.movedSet.has(n) &&\r\n                            this.movedMap[moveKey(nodeId, parentId)]) {\r\n                            deepDelete(this.movedSet, n);\r\n                        }\r\n                        else {\r\n                            this.removes.push({\r\n                                parentId,\r\n                                id: nodeId,\r\n                                isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target)\r\n                                    ? true\r\n                                    : undefined,\r\n                            });\r\n                        }\r\n                        this.mapRemoves.push(n);\r\n                    });\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n        this.genAdds = (n, target) => {\r\n            if (this.processedNodeManager.inOtherBuffer(n, this))\r\n                return;\r\n            if (this.addedSet.has(n) || this.movedSet.has(n))\r\n                return;\r\n            if (this.mirror.hasNode(n)) {\r\n                if (isIgnored(n, this.mirror)) {\r\n                    return;\r\n                }\r\n                this.movedSet.add(n);\r\n                let targetId = null;\r\n                if (target && this.mirror.hasNode(target)) {\r\n                    targetId = this.mirror.getId(target);\r\n                }\r\n                if (targetId && targetId !== -1) {\r\n                    this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;\r\n                }\r\n            }\r\n            else {\r\n                this.addedSet.add(n);\r\n                this.droppedSet.delete(n);\r\n            }\r\n            if (!isBlocked(n, this.blockClass, this.blockSelector, false)) {\r\n                n.childNodes.forEach((childN) => this.genAdds(childN));\r\n                if (hasShadowRoot(n)) {\r\n                    n.shadowRoot.childNodes.forEach((childN) => {\r\n                        this.processedNodeManager.add(childN, this);\r\n                        this.genAdds(childN, n);\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    }\r\n    init(options) {\r\n        [\r\n            'mutationCb',\r\n            'blockClass',\r\n            'blockSelector',\r\n            'maskTextClass',\r\n            'maskTextSelector',\r\n            'inlineStylesheet',\r\n            'maskInputOptions',\r\n            'maskTextFn',\r\n            'maskInputFn',\r\n            'keepIframeSrcFn',\r\n            'recordCanvas',\r\n            'inlineImages',\r\n            'slimDOMOptions',\r\n            'dataURLOptions',\r\n            'doc',\r\n            'mirror',\r\n            'iframeManager',\r\n            'stylesheetManager',\r\n            'shadowDomManager',\r\n            'canvasManager',\r\n            'processedNodeManager',\r\n        ].forEach((key) => {\r\n            this[key] = options[key];\r\n        });\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n        this.canvasManager.freeze();\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n        this.canvasManager.unfreeze();\r\n        this.emit();\r\n    }\r\n    isFrozen() {\r\n        return this.frozen;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n        this.canvasManager.lock();\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n        this.canvasManager.unlock();\r\n        this.emit();\r\n    }\r\n    reset() {\r\n        this.shadowDomManager.reset();\r\n        this.canvasManager.reset();\r\n    }\r\n}\r\nfunction deepDelete(addsSet, n) {\r\n    addsSet.delete(n);\r\n    n.childNodes.forEach((childN) => deepDelete(addsSet, childN));\r\n}\r\nfunction isParentRemoved(removes, n, mirror) {\r\n    if (removes.length === 0)\r\n        return false;\r\n    return _isParentRemoved(removes, n, mirror);\r\n}\r\nfunction _isParentRemoved(removes, n, mirror) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    const parentId = mirror.getId(parentNode);\r\n    if (removes.some((r) => r.id === parentId)) {\r\n        return true;\r\n    }\r\n    return _isParentRemoved(removes, parentNode, mirror);\r\n}\r\nfunction isAncestorInSet(set, n) {\r\n    if (set.size === 0)\r\n        return false;\r\n    return _isAncestorInSet(set, n);\r\n}\r\nfunction _isAncestorInSet(set, n) {\r\n    const { parentNode } = n;\r\n    if (!parentNode) {\r\n        return false;\r\n    }\r\n    if (set.has(parentNode)) {\r\n        return true;\r\n    }\r\n    return _isAncestorInSet(set, parentNode);\r\n}\n\nlet errorHandler;\r\nfunction registerErrorHandler(handler) {\r\n    errorHandler = handler;\r\n}\r\nfunction unregisterErrorHandler() {\r\n    errorHandler = undefined;\r\n}\r\nconst callbackWrapper = (cb) => {\r\n    if (!errorHandler) {\r\n        return cb;\r\n    }\r\n    const rrwebWrapped = ((...rest) => {\r\n        try {\r\n            return cb(...rest);\r\n        }\r\n        catch (error) {\r\n            if (errorHandler && errorHandler(error) === true) {\r\n                return;\r\n            }\r\n            throw error;\r\n        }\r\n    });\r\n    return rrwebWrapped;\r\n};\n\nconst mutationBuffers = [];\r\nfunction getEventTarget(event) {\r\n    try {\r\n        if ('composedPath' in event) {\r\n            const path = event.composedPath();\r\n            if (path.length) {\r\n                return path[0];\r\n            }\r\n        }\r\n        else if ('path' in event && event.path.length) {\r\n            return event.path[0];\r\n        }\r\n    }\r\n    catch (_a) {\r\n    }\r\n    return event && event.target;\r\n}\r\nfunction initMutationObserver(options, rootEl) {\r\n    var _a, _b;\r\n    const mutationBuffer = new MutationBuffer();\r\n    mutationBuffers.push(mutationBuffer);\r\n    mutationBuffer.init(options);\r\n    let mutationObserverCtor = window.MutationObserver ||\r\n        window.__rrMutationObserver;\r\n    const angularZoneSymbol = (_b = (_a = window === null || window === void 0 ? void 0 : window.Zone) === null || _a === void 0 ? void 0 : _a.__symbol__) === null || _b === void 0 ? void 0 : _b.call(_a, 'MutationObserver');\r\n    if (angularZoneSymbol &&\r\n        window[angularZoneSymbol]) {\r\n        mutationObserverCtor = window[angularZoneSymbol];\r\n    }\r\n    const observer = new mutationObserverCtor(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));\r\n    observer.observe(rootEl, {\r\n        attributes: true,\r\n        attributeOldValue: true,\r\n        characterData: true,\r\n        characterDataOldValue: true,\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\r\nfunction initMoveObserver({ mousemoveCb, sampling, doc, mirror, }) {\r\n    if (sampling.mousemove === false) {\r\n        return () => {\r\n        };\r\n    }\r\n    const threshold = typeof sampling.mousemove === 'number' ? sampling.mousemove : 50;\r\n    const callbackThreshold = typeof sampling.mousemoveCallback === 'number'\r\n        ? sampling.mousemoveCallback\r\n        : 500;\r\n    let positions = [];\r\n    let timeBaseline;\r\n    const wrappedCb = throttle(callbackWrapper((source) => {\r\n        const totalOffset = Date.now() - timeBaseline;\r\n        mousemoveCb(positions.map((p) => {\r\n            p.timeOffset -= totalOffset;\r\n            return p;\r\n        }), source);\r\n        positions = [];\r\n        timeBaseline = null;\r\n    }), callbackThreshold);\r\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {\r\n        const target = getEventTarget(evt);\r\n        const { clientX, clientY } = legacy_isTouchEvent(evt)\r\n            ? evt.changedTouches[0]\r\n            : evt;\r\n        if (!timeBaseline) {\r\n            timeBaseline = nowTimestamp();\r\n        }\r\n        positions.push({\r\n            x: clientX,\r\n            y: clientY,\r\n            id: mirror.getId(target),\r\n            timeOffset: nowTimestamp() - timeBaseline,\r\n        });\r\n        wrappedCb(typeof DragEvent !== 'undefined' && evt instanceof DragEvent\r\n            ? IncrementalSource$1.Drag\r\n            : evt instanceof MouseEvent\r\n                ? IncrementalSource$1.MouseMove\r\n                : IncrementalSource$1.TouchMove);\r\n    }), threshold, {\r\n        trailing: false,\r\n    }));\r\n    const handlers = [\r\n        on('mousemove', updatePosition, doc),\r\n        on('touchmove', updatePosition, doc),\r\n        on('drag', updatePosition, doc),\r\n    ];\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initMouseInteractionObserver({ mouseInteractionCb, doc, mirror, blockClass, blockSelector, sampling, }) {\r\n    if (sampling.mouseInteraction === false) {\r\n        return () => {\r\n        };\r\n    }\r\n    const disableMap = sampling.mouseInteraction === true ||\r\n        sampling.mouseInteraction === undefined\r\n        ? {}\r\n        : sampling.mouseInteraction;\r\n    const handlers = [];\r\n    let currentPointerType = null;\r\n    const getHandler = (eventKey) => {\r\n        return (event) => {\r\n            const target = getEventTarget(event);\r\n            if (isBlocked(target, blockClass, blockSelector, true)) {\r\n                return;\r\n            }\r\n            let pointerType = null;\r\n            let thisEventKey = eventKey;\r\n            if ('pointerType' in event) {\r\n                switch (event.pointerType) {\r\n                    case 'mouse':\r\n                        pointerType = PointerTypes.Mouse;\r\n                        break;\r\n                    case 'touch':\r\n                        pointerType = PointerTypes.Touch;\r\n                        break;\r\n                    case 'pen':\r\n                        pointerType = PointerTypes.Pen;\r\n                        break;\r\n                }\r\n                if (pointerType === PointerTypes.Touch) {\r\n                    if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {\r\n                        thisEventKey = 'TouchStart';\r\n                    }\r\n                    else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {\r\n                        thisEventKey = 'TouchEnd';\r\n                    }\r\n                }\r\n                else if (pointerType === PointerTypes.Pen) ;\r\n            }\r\n            else if (legacy_isTouchEvent(event)) {\r\n                pointerType = PointerTypes.Touch;\r\n            }\r\n            if (pointerType !== null) {\r\n                currentPointerType = pointerType;\r\n                if ((thisEventKey.startsWith('Touch') &&\r\n                    pointerType === PointerTypes.Touch) ||\r\n                    (thisEventKey.startsWith('Mouse') &&\r\n                        pointerType === PointerTypes.Mouse)) {\r\n                    pointerType = null;\r\n                }\r\n            }\r\n            else if (MouseInteractions[eventKey] === MouseInteractions.Click) {\r\n                pointerType = currentPointerType;\r\n                currentPointerType = null;\r\n            }\r\n            const e = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;\r\n            if (!e) {\r\n                return;\r\n            }\r\n            const id = mirror.getId(target);\r\n            const { clientX, clientY } = e;\r\n            callbackWrapper(mouseInteractionCb)(Object.assign({ type: MouseInteractions[thisEventKey], id, x: clientX, y: clientY }, (pointerType !== null && { pointerType })));\r\n        };\r\n    };\r\n    Object.keys(MouseInteractions)\r\n        .filter((key) => Number.isNaN(Number(key)) &&\r\n        !key.endsWith('_Departed') &&\r\n        disableMap[key] !== false)\r\n        .forEach((eventKey) => {\r\n        let eventName = toLowerCase(eventKey);\r\n        const handler = getHandler(eventKey);\r\n        if (window.PointerEvent) {\r\n            switch (MouseInteractions[eventKey]) {\r\n                case MouseInteractions.MouseDown:\r\n                case MouseInteractions.MouseUp:\r\n                    eventName = eventName.replace('mouse', 'pointer');\r\n                    break;\r\n                case MouseInteractions.TouchStart:\r\n                case MouseInteractions.TouchEnd:\r\n                    return;\r\n            }\r\n        }\r\n        handlers.push(on(eventName, handler, doc));\r\n    });\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initScrollObserver({ scrollCb, doc, mirror, blockClass, blockSelector, sampling, }) {\r\n    const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {\r\n        const target = getEventTarget(evt);\r\n        if (!target ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        const id = mirror.getId(target);\r\n        if (target === doc && doc.defaultView) {\r\n            const scrollLeftTop = getWindowScroll(doc.defaultView);\r\n            scrollCb({\r\n                id,\r\n                x: scrollLeftTop.left,\r\n                y: scrollLeftTop.top,\r\n            });\r\n        }\r\n        else {\r\n            scrollCb({\r\n                id,\r\n                x: target.scrollLeft,\r\n                y: target.scrollTop,\r\n            });\r\n        }\r\n    }), sampling.scroll || 100));\r\n    return on('scroll', updatePosition, doc);\r\n}\r\nfunction initViewportResizeObserver({ viewportResizeCb }, { win }) {\r\n    let lastH = -1;\r\n    let lastW = -1;\r\n    const updateDimension = callbackWrapper(throttle(callbackWrapper(() => {\r\n        const height = getWindowHeight();\r\n        const width = getWindowWidth();\r\n        if (lastH !== height || lastW !== width) {\r\n            viewportResizeCb({\r\n                width: Number(width),\r\n                height: Number(height),\r\n            });\r\n            lastH = height;\r\n            lastW = width;\r\n        }\r\n    }), 200));\r\n    return on('resize', updateDimension, win);\r\n}\r\nconst INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];\r\nconst lastInputValueMap = new WeakMap();\r\nfunction initInputObserver({ inputCb, doc, mirror, blockClass, blockSelector, ignoreClass, ignoreSelector, maskInputOptions, maskInputFn, sampling, userTriggeredOnInput, }) {\r\n    function eventHandler(event) {\r\n        let target = getEventTarget(event);\r\n        const userTriggered = event.isTrusted;\r\n        const tagName = target && target.tagName;\r\n        if (target && tagName === 'OPTION') {\r\n            target = target.parentElement;\r\n        }\r\n        if (!target ||\r\n            !tagName ||\r\n            INPUT_TAGS.indexOf(tagName) < 0 ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        if (target.classList.contains(ignoreClass) ||\r\n            (ignoreSelector && target.matches(ignoreSelector))) {\r\n            return;\r\n        }\r\n        let text = target.value;\r\n        let isChecked = false;\r\n        const type = getInputType(target) || '';\r\n        if (type === 'radio' || type === 'checkbox') {\r\n            isChecked = target.checked;\r\n        }\r\n        else if (maskInputOptions[tagName.toLowerCase()] ||\r\n            maskInputOptions[type]) {\r\n            text = maskInputValue({\r\n                element: target,\r\n                maskInputOptions,\r\n                tagName,\r\n                type,\r\n                value: text,\r\n                maskInputFn,\r\n            });\r\n        }\r\n        cbWithDedup(target, userTriggeredOnInput\r\n            ? { text, isChecked, userTriggered }\r\n            : { text, isChecked });\r\n        const name = target.name;\r\n        if (type === 'radio' && name && isChecked) {\r\n            doc\r\n                .querySelectorAll(`input[type=\"radio\"][name=\"${name}\"]`)\r\n                .forEach((el) => {\r\n                if (el !== target) {\r\n                    const text = el.value;\r\n                    cbWithDedup(el, userTriggeredOnInput\r\n                        ? { text, isChecked: !isChecked, userTriggered: false }\r\n                        : { text, isChecked: !isChecked });\r\n                }\r\n            });\r\n        }\r\n    }\r\n    function cbWithDedup(target, v) {\r\n        const lastInputValue = lastInputValueMap.get(target);\r\n        if (!lastInputValue ||\r\n            lastInputValue.text !== v.text ||\r\n            lastInputValue.isChecked !== v.isChecked) {\r\n            lastInputValueMap.set(target, v);\r\n            const id = mirror.getId(target);\r\n            callbackWrapper(inputCb)(Object.assign(Object.assign({}, v), { id }));\r\n        }\r\n    }\r\n    const events = sampling.input === 'last' ? ['change'] : ['input', 'change'];\r\n    const handlers = events.map((eventName) => on(eventName, callbackWrapper(eventHandler), doc));\r\n    const currentWindow = doc.defaultView;\r\n    if (!currentWindow) {\r\n        return () => {\r\n            handlers.forEach((h) => h());\r\n        };\r\n    }\r\n    const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, 'value');\r\n    const hookProperties = [\r\n        [currentWindow.HTMLInputElement.prototype, 'value'],\r\n        [currentWindow.HTMLInputElement.prototype, 'checked'],\r\n        [currentWindow.HTMLSelectElement.prototype, 'value'],\r\n        [currentWindow.HTMLTextAreaElement.prototype, 'value'],\r\n        [currentWindow.HTMLSelectElement.prototype, 'selectedIndex'],\r\n        [currentWindow.HTMLOptionElement.prototype, 'selected'],\r\n    ];\r\n    if (propertyDescriptor && propertyDescriptor.set) {\r\n        handlers.push(...hookProperties.map((p) => hookSetter(p[0], p[1], {\r\n            set() {\r\n                callbackWrapper(eventHandler)({\r\n                    target: this,\r\n                    isTrusted: false,\r\n                });\r\n            },\r\n        }, false, currentWindow)));\r\n    }\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction getNestedCSSRulePositions(rule) {\r\n    const positions = [];\r\n    function recurse(childRule, pos) {\r\n        if ((hasNestedCSSRule('CSSGroupingRule') &&\r\n            childRule.parentRule instanceof CSSGroupingRule) ||\r\n            (hasNestedCSSRule('CSSMediaRule') &&\r\n                childRule.parentRule instanceof CSSMediaRule) ||\r\n            (hasNestedCSSRule('CSSSupportsRule') &&\r\n                childRule.parentRule instanceof CSSSupportsRule) ||\r\n            (hasNestedCSSRule('CSSConditionRule') &&\r\n                childRule.parentRule instanceof CSSConditionRule)) {\r\n            const rules = Array.from(childRule.parentRule.cssRules);\r\n            const index = rules.indexOf(childRule);\r\n            pos.unshift(index);\r\n        }\r\n        else if (childRule.parentStyleSheet) {\r\n            const rules = Array.from(childRule.parentStyleSheet.cssRules);\r\n            const index = rules.indexOf(childRule);\r\n            pos.unshift(index);\r\n        }\r\n        return pos;\r\n    }\r\n    return recurse(rule, positions);\r\n}\r\nfunction getIdAndStyleId(sheet, mirror, styleMirror) {\r\n    let id, styleId;\r\n    if (!sheet)\r\n        return {};\r\n    if (sheet.ownerNode)\r\n        id = mirror.getId(sheet.ownerNode);\r\n    else\r\n        styleId = styleMirror.getId(sheet);\r\n    return {\r\n        styleId,\r\n        id,\r\n    };\r\n}\r\nfunction initStyleSheetObserver({ styleSheetRuleCb, mirror, stylesheetManager }, { win }) {\r\n    if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {\r\n        return () => {\r\n        };\r\n    }\r\n    const insertRule = win.CSSStyleSheet.prototype.insertRule;\r\n    win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [rule, index] = argumentsList;\r\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleSheetRuleCb({\r\n                    id,\r\n                    styleId,\r\n                    adds: [{ rule, index }],\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    const deleteRule = win.CSSStyleSheet.prototype.deleteRule;\r\n    win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            const [index] = argumentsList;\r\n            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleSheetRuleCb({\r\n                    id,\r\n                    styleId,\r\n                    removes: [{ index }],\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    let replace;\r\n    if (win.CSSStyleSheet.prototype.replace) {\r\n        replace = win.CSSStyleSheet.prototype.replace;\r\n        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [text] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        replace: text,\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    }\r\n    let replaceSync;\r\n    if (win.CSSStyleSheet.prototype.replaceSync) {\r\n        replaceSync = win.CSSStyleSheet.prototype.replaceSync;\r\n        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [text] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        replaceSync: text,\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    }\r\n    const supportedNestedCSSRuleTypes = {};\r\n    if (canMonkeyPatchNestedCSSRule('CSSGroupingRule')) {\r\n        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;\r\n    }\r\n    else {\r\n        if (canMonkeyPatchNestedCSSRule('CSSMediaRule')) {\r\n            supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;\r\n        }\r\n        if (canMonkeyPatchNestedCSSRule('CSSConditionRule')) {\r\n            supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;\r\n        }\r\n        if (canMonkeyPatchNestedCSSRule('CSSSupportsRule')) {\r\n            supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;\r\n        }\r\n    }\r\n    const unmodifiedFunctions = {};\r\n    Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\r\n        unmodifiedFunctions[typeKey] = {\r\n            insertRule: type.prototype.insertRule,\r\n            deleteRule: type.prototype.deleteRule,\r\n        };\r\n        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [rule, index] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        adds: [\r\n                            {\r\n                                rule,\r\n                                index: [\r\n                                    ...getNestedCSSRulePositions(thisArg),\r\n                                    index || 0,\r\n                                ],\r\n                            },\r\n                        ],\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {\r\n            apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n                const [index] = argumentsList;\r\n                const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n                if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                    styleSheetRuleCb({\r\n                        id,\r\n                        styleId,\r\n                        removes: [\r\n                            { index: [...getNestedCSSRulePositions(thisArg), index] },\r\n                        ],\r\n                    });\r\n                }\r\n                return target.apply(thisArg, argumentsList);\r\n            }),\r\n        });\r\n    });\r\n    return callbackWrapper(() => {\r\n        win.CSSStyleSheet.prototype.insertRule = insertRule;\r\n        win.CSSStyleSheet.prototype.deleteRule = deleteRule;\r\n        replace && (win.CSSStyleSheet.prototype.replace = replace);\r\n        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);\r\n        Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {\r\n            type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;\r\n            type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;\r\n        });\r\n    });\r\n}\r\nfunction initAdoptedStyleSheetObserver({ mirror, stylesheetManager, }, host) {\r\n    var _a, _b, _c;\r\n    let hostId = null;\r\n    if (host.nodeName === '#document')\r\n        hostId = mirror.getId(host);\r\n    else\r\n        hostId = mirror.getId(host.host);\r\n    const patchTarget = host.nodeName === '#document'\r\n        ? (_a = host.defaultView) === null || _a === void 0 ? void 0 : _a.Document\r\n        : (_c = (_b = host.ownerDocument) === null || _b === void 0 ? void 0 : _b.defaultView) === null || _c === void 0 ? void 0 : _c.ShadowRoot;\r\n    const originalPropertyDescriptor = (patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype)\r\n        ? Object.getOwnPropertyDescriptor(patchTarget === null || patchTarget === void 0 ? void 0 : patchTarget.prototype, 'adoptedStyleSheets')\r\n        : undefined;\r\n    if (hostId === null ||\r\n        hostId === -1 ||\r\n        !patchTarget ||\r\n        !originalPropertyDescriptor)\r\n        return () => {\r\n        };\r\n    Object.defineProperty(host, 'adoptedStyleSheets', {\r\n        configurable: originalPropertyDescriptor.configurable,\r\n        enumerable: originalPropertyDescriptor.enumerable,\r\n        get() {\r\n            var _a;\r\n            return (_a = originalPropertyDescriptor.get) === null || _a === void 0 ? void 0 : _a.call(this);\r\n        },\r\n        set(sheets) {\r\n            var _a;\r\n            const result = (_a = originalPropertyDescriptor.set) === null || _a === void 0 ? void 0 : _a.call(this, sheets);\r\n            if (hostId !== null && hostId !== -1) {\r\n                try {\r\n                    stylesheetManager.adoptStyleSheets(sheets, hostId);\r\n                }\r\n                catch (e) {\r\n                }\r\n            }\r\n            return result;\r\n        },\r\n    });\r\n    return callbackWrapper(() => {\r\n        Object.defineProperty(host, 'adoptedStyleSheets', {\r\n            configurable: originalPropertyDescriptor.configurable,\r\n            enumerable: originalPropertyDescriptor.enumerable,\r\n            get: originalPropertyDescriptor.get,\r\n            set: originalPropertyDescriptor.set,\r\n        });\r\n    });\r\n}\r\nfunction initStyleDeclarationObserver({ styleDeclarationCb, mirror, ignoreCSSAttributes, stylesheetManager, }, { win }) {\r\n    const setProperty = win.CSSStyleDeclaration.prototype.setProperty;\r\n    win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            var _a;\r\n            const [property, value, priority] = argumentsList;\r\n            if (ignoreCSSAttributes.has(property)) {\r\n                return setProperty.apply(thisArg, [property, value, priority]);\r\n            }\r\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleDeclarationCb({\r\n                    id,\r\n                    styleId,\r\n                    set: {\r\n                        property,\r\n                        value,\r\n                        priority,\r\n                    },\r\n                    index: getNestedCSSRulePositions(thisArg.parentRule),\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;\r\n    win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {\r\n        apply: callbackWrapper((target, thisArg, argumentsList) => {\r\n            var _a;\r\n            const [property] = argumentsList;\r\n            if (ignoreCSSAttributes.has(property)) {\r\n                return removeProperty.apply(thisArg, [property]);\r\n            }\r\n            const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) === null || _a === void 0 ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);\r\n            if ((id && id !== -1) || (styleId && styleId !== -1)) {\r\n                styleDeclarationCb({\r\n                    id,\r\n                    styleId,\r\n                    remove: {\r\n                        property,\r\n                    },\r\n                    index: getNestedCSSRulePositions(thisArg.parentRule),\r\n                });\r\n            }\r\n            return target.apply(thisArg, argumentsList);\r\n        }),\r\n    });\r\n    return callbackWrapper(() => {\r\n        win.CSSStyleDeclaration.prototype.setProperty = setProperty;\r\n        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;\r\n    });\r\n}\r\nfunction initMediaInteractionObserver({ mediaInteractionCb, blockClass, blockSelector, mirror, sampling, doc, }) {\r\n    const handler = callbackWrapper((type) => throttle(callbackWrapper((event) => {\r\n        const target = getEventTarget(event);\r\n        if (!target ||\r\n            isBlocked(target, blockClass, blockSelector, true)) {\r\n            return;\r\n        }\r\n        const { currentTime, volume, muted, playbackRate, loop } = target;\r\n        mediaInteractionCb({\r\n            type,\r\n            id: mirror.getId(target),\r\n            currentTime,\r\n            volume,\r\n            muted,\r\n            playbackRate,\r\n            loop,\r\n        });\r\n    }), sampling.media || 500));\r\n    const handlers = [\r\n        on('play', handler(0), doc),\r\n        on('pause', handler(1), doc),\r\n        on('seeked', handler(2), doc),\r\n        on('volumechange', handler(3), doc),\r\n        on('ratechange', handler(4), doc),\r\n    ];\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initFontObserver({ fontCb, doc }) {\r\n    const win = doc.defaultView;\r\n    if (!win) {\r\n        return () => {\r\n        };\r\n    }\r\n    const handlers = [];\r\n    const fontMap = new WeakMap();\r\n    const originalFontFace = win.FontFace;\r\n    win.FontFace = function FontFace(family, source, descriptors) {\r\n        const fontFace = new originalFontFace(family, source, descriptors);\r\n        fontMap.set(fontFace, {\r\n            family,\r\n            buffer: typeof source !== 'string',\r\n            descriptors,\r\n            fontSource: typeof source === 'string'\r\n                ? source\r\n                : JSON.stringify(Array.from(new Uint8Array(source))),\r\n        });\r\n        return fontFace;\r\n    };\r\n    const restoreHandler = patch(doc.fonts, 'add', function (original) {\r\n        return function (fontFace) {\r\n            setTimeout(callbackWrapper(() => {\r\n                const p = fontMap.get(fontFace);\r\n                if (p) {\r\n                    fontCb(p);\r\n                    fontMap.delete(fontFace);\r\n                }\r\n            }), 0);\r\n            return original.apply(this, [fontFace]);\r\n        };\r\n    });\r\n    handlers.push(() => {\r\n        win.FontFace = originalFontFace;\r\n    });\r\n    handlers.push(restoreHandler);\r\n    return callbackWrapper(() => {\r\n        handlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction initSelectionObserver(param) {\r\n    const { doc, mirror, blockClass, blockSelector, selectionCb } = param;\r\n    let collapsed = true;\r\n    const updateSelection = callbackWrapper(() => {\r\n        const selection = doc.getSelection();\r\n        if (!selection || (collapsed && (selection === null || selection === void 0 ? void 0 : selection.isCollapsed)))\r\n            return;\r\n        collapsed = selection.isCollapsed || false;\r\n        const ranges = [];\r\n        const count = selection.rangeCount || 0;\r\n        for (let i = 0; i < count; i++) {\r\n            const range = selection.getRangeAt(i);\r\n            const { startContainer, startOffset, endContainer, endOffset } = range;\r\n            const blocked = isBlocked(startContainer, blockClass, blockSelector, true) ||\r\n                isBlocked(endContainer, blockClass, blockSelector, true);\r\n            if (blocked)\r\n                continue;\r\n            ranges.push({\r\n                start: mirror.getId(startContainer),\r\n                startOffset,\r\n                end: mirror.getId(endContainer),\r\n                endOffset,\r\n            });\r\n        }\r\n        selectionCb({ ranges });\r\n    });\r\n    updateSelection();\r\n    return on('selectionchange', updateSelection);\r\n}\r\nfunction initCustomElementObserver({ doc, customElementCb, }) {\r\n    const win = doc.defaultView;\r\n    if (!win || !win.customElements)\r\n        return () => { };\r\n    const restoreHandler = patch(win.customElements, 'define', function (original) {\r\n        return function (name, constructor, options) {\r\n            try {\r\n                customElementCb({\r\n                    define: {\r\n                        name,\r\n                    },\r\n                });\r\n            }\r\n            catch (e) {\r\n                console.warn(`Custom element callback failed for ${name}`);\r\n            }\r\n            return original.apply(this, [name, constructor, options]);\r\n        };\r\n    });\r\n    return restoreHandler;\r\n}\r\nfunction mergeHooks(o, hooks) {\r\n    const { mutationCb, mousemoveCb, mouseInteractionCb, scrollCb, viewportResizeCb, inputCb, mediaInteractionCb, styleSheetRuleCb, styleDeclarationCb, canvasMutationCb, fontCb, selectionCb, customElementCb, } = o;\r\n    o.mutationCb = (...p) => {\r\n        if (hooks.mutation) {\r\n            hooks.mutation(...p);\r\n        }\r\n        mutationCb(...p);\r\n    };\r\n    o.mousemoveCb = (...p) => {\r\n        if (hooks.mousemove) {\r\n            hooks.mousemove(...p);\r\n        }\r\n        mousemoveCb(...p);\r\n    };\r\n    o.mouseInteractionCb = (...p) => {\r\n        if (hooks.mouseInteraction) {\r\n            hooks.mouseInteraction(...p);\r\n        }\r\n        mouseInteractionCb(...p);\r\n    };\r\n    o.scrollCb = (...p) => {\r\n        if (hooks.scroll) {\r\n            hooks.scroll(...p);\r\n        }\r\n        scrollCb(...p);\r\n    };\r\n    o.viewportResizeCb = (...p) => {\r\n        if (hooks.viewportResize) {\r\n            hooks.viewportResize(...p);\r\n        }\r\n        viewportResizeCb(...p);\r\n    };\r\n    o.inputCb = (...p) => {\r\n        if (hooks.input) {\r\n            hooks.input(...p);\r\n        }\r\n        inputCb(...p);\r\n    };\r\n    o.mediaInteractionCb = (...p) => {\r\n        if (hooks.mediaInteaction) {\r\n            hooks.mediaInteaction(...p);\r\n        }\r\n        mediaInteractionCb(...p);\r\n    };\r\n    o.styleSheetRuleCb = (...p) => {\r\n        if (hooks.styleSheetRule) {\r\n            hooks.styleSheetRule(...p);\r\n        }\r\n        styleSheetRuleCb(...p);\r\n    };\r\n    o.styleDeclarationCb = (...p) => {\r\n        if (hooks.styleDeclaration) {\r\n            hooks.styleDeclaration(...p);\r\n        }\r\n        styleDeclarationCb(...p);\r\n    };\r\n    o.canvasMutationCb = (...p) => {\r\n        if (hooks.canvasMutation) {\r\n            hooks.canvasMutation(...p);\r\n        }\r\n        canvasMutationCb(...p);\r\n    };\r\n    o.fontCb = (...p) => {\r\n        if (hooks.font) {\r\n            hooks.font(...p);\r\n        }\r\n        fontCb(...p);\r\n    };\r\n    o.selectionCb = (...p) => {\r\n        if (hooks.selection) {\r\n            hooks.selection(...p);\r\n        }\r\n        selectionCb(...p);\r\n    };\r\n    o.customElementCb = (...c) => {\r\n        if (hooks.customElement) {\r\n            hooks.customElement(...c);\r\n        }\r\n        customElementCb(...c);\r\n    };\r\n}\r\nfunction initObservers(o, hooks = {}) {\r\n    const currentWindow = o.doc.defaultView;\r\n    if (!currentWindow) {\r\n        return () => {\r\n        };\r\n    }\r\n    mergeHooks(o, hooks);\r\n    let mutationObserver;\r\n    if (o.recordDOM) {\r\n        mutationObserver = initMutationObserver(o, o.doc);\r\n    }\r\n    const mousemoveHandler = initMoveObserver(o);\r\n    const mouseInteractionHandler = initMouseInteractionObserver(o);\r\n    const scrollHandler = initScrollObserver(o);\r\n    const viewportResizeHandler = initViewportResizeObserver(o, {\r\n        win: currentWindow,\r\n    });\r\n    const inputHandler = initInputObserver(o);\r\n    const mediaInteractionHandler = initMediaInteractionObserver(o);\r\n    let styleSheetObserver = () => { };\r\n    let adoptedStyleSheetObserver = () => { };\r\n    let styleDeclarationObserver = () => { };\r\n    let fontObserver = () => { };\r\n    if (o.recordDOM) {\r\n        styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });\r\n        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);\r\n        styleDeclarationObserver = initStyleDeclarationObserver(o, {\r\n            win: currentWindow,\r\n        });\r\n        if (o.collectFonts) {\r\n            fontObserver = initFontObserver(o);\r\n        }\r\n    }\r\n    const selectionObserver = initSelectionObserver(o);\r\n    const customElementObserver = initCustomElementObserver(o);\r\n    const pluginHandlers = [];\r\n    for (const plugin of o.plugins) {\r\n        pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));\r\n    }\r\n    return callbackWrapper(() => {\r\n        mutationBuffers.forEach((b) => b.reset());\r\n        mutationObserver === null || mutationObserver === void 0 ? void 0 : mutationObserver.disconnect();\r\n        mousemoveHandler();\r\n        mouseInteractionHandler();\r\n        scrollHandler();\r\n        viewportResizeHandler();\r\n        inputHandler();\r\n        mediaInteractionHandler();\r\n        styleSheetObserver();\r\n        adoptedStyleSheetObserver();\r\n        styleDeclarationObserver();\r\n        fontObserver();\r\n        selectionObserver();\r\n        customElementObserver();\r\n        pluginHandlers.forEach((h) => h());\r\n    });\r\n}\r\nfunction hasNestedCSSRule(prop) {\r\n    return typeof window[prop] !== 'undefined';\r\n}\r\nfunction canMonkeyPatchNestedCSSRule(prop) {\r\n    return Boolean(typeof window[prop] !== 'undefined' &&\r\n        window[prop].prototype &&\r\n        'insertRule' in window[prop].prototype &&\r\n        'deleteRule' in window[prop].prototype);\r\n}\n\nclass CrossOriginIframeMirror {\r\n    constructor(generateIdFn) {\r\n        this.generateIdFn = generateIdFn;\r\n        this.iframeIdToRemoteIdMap = new WeakMap();\r\n        this.iframeRemoteIdToIdMap = new WeakMap();\r\n    }\r\n    getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {\r\n        const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);\r\n        const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);\r\n        let id = idToRemoteIdMap.get(remoteId);\r\n        if (!id) {\r\n            id = this.generateIdFn();\r\n            idToRemoteIdMap.set(remoteId, id);\r\n            remoteIdToIdMap.set(id, remoteId);\r\n        }\r\n        return id;\r\n    }\r\n    getIds(iframe, remoteId) {\r\n        const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);\r\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\r\n        return remoteId.map((id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));\r\n    }\r\n    getRemoteId(iframe, id, map) {\r\n        const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);\r\n        if (typeof id !== 'number')\r\n            return id;\r\n        const remoteId = remoteIdToIdMap.get(id);\r\n        if (!remoteId)\r\n            return -1;\r\n        return remoteId;\r\n    }\r\n    getRemoteIds(iframe, ids) {\r\n        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);\r\n        return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));\r\n    }\r\n    reset(iframe) {\r\n        if (!iframe) {\r\n            this.iframeIdToRemoteIdMap = new WeakMap();\r\n            this.iframeRemoteIdToIdMap = new WeakMap();\r\n            return;\r\n        }\r\n        this.iframeIdToRemoteIdMap.delete(iframe);\r\n        this.iframeRemoteIdToIdMap.delete(iframe);\r\n    }\r\n    getIdToRemoteIdMap(iframe) {\r\n        let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);\r\n        if (!idToRemoteIdMap) {\r\n            idToRemoteIdMap = new Map();\r\n            this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);\r\n        }\r\n        return idToRemoteIdMap;\r\n    }\r\n    getRemoteIdToIdMap(iframe) {\r\n        let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);\r\n        if (!remoteIdToIdMap) {\r\n            remoteIdToIdMap = new Map();\r\n            this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);\r\n        }\r\n        return remoteIdToIdMap;\r\n    }\r\n}\n\nclass IframeManager {\r\n    constructor(options) {\r\n        this.iframes = new WeakMap();\r\n        this.crossOriginIframeMap = new WeakMap();\r\n        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);\r\n        this.crossOriginIframeRootIdMap = new WeakMap();\r\n        this.mutationCb = options.mutationCb;\r\n        this.wrappedEmit = options.wrappedEmit;\r\n        this.stylesheetManager = options.stylesheetManager;\r\n        this.recordCrossOriginIframes = options.recordCrossOriginIframes;\r\n        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));\r\n        this.mirror = options.mirror;\r\n        if (this.recordCrossOriginIframes) {\r\n            window.addEventListener('message', this.handleMessage.bind(this));\r\n        }\r\n    }\r\n    addIframe(iframeEl) {\r\n        this.iframes.set(iframeEl, true);\r\n        if (iframeEl.contentWindow)\r\n            this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);\r\n    }\r\n    addLoadListener(cb) {\r\n        this.loadListener = cb;\r\n    }\r\n    attachIframe(iframeEl, childSn) {\r\n        var _a;\r\n        this.mutationCb({\r\n            adds: [\r\n                {\r\n                    parentId: this.mirror.getId(iframeEl),\r\n                    nextId: null,\r\n                    node: childSn,\r\n                },\r\n            ],\r\n            removes: [],\r\n            texts: [],\r\n            attributes: [],\r\n            isAttachIframe: true,\r\n        });\r\n        (_a = this.loadListener) === null || _a === void 0 ? void 0 : _a.call(this, iframeEl);\r\n        if (iframeEl.contentDocument &&\r\n            iframeEl.contentDocument.adoptedStyleSheets &&\r\n            iframeEl.contentDocument.adoptedStyleSheets.length > 0)\r\n            this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));\r\n    }\r\n    handleMessage(message) {\r\n        const crossOriginMessageEvent = message;\r\n        if (crossOriginMessageEvent.data.type !== 'rrweb' ||\r\n            crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)\r\n            return;\r\n        const iframeSourceWindow = message.source;\r\n        if (!iframeSourceWindow)\r\n            return;\r\n        const iframeEl = this.crossOriginIframeMap.get(message.source);\r\n        if (!iframeEl)\r\n            return;\r\n        const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);\r\n        if (transformedEvent)\r\n            this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);\r\n    }\r\n    transformCrossOriginEvent(iframeEl, e) {\r\n        var _a;\r\n        switch (e.type) {\r\n            case EventType$1.FullSnapshot: {\r\n                this.crossOriginIframeMirror.reset(iframeEl);\r\n                this.crossOriginIframeStyleMirror.reset(iframeEl);\r\n                this.replaceIdOnNode(e.data.node, iframeEl);\r\n                const rootId = e.data.node.id;\r\n                this.crossOriginIframeRootIdMap.set(iframeEl, rootId);\r\n                this.patchRootIdOnNode(e.data.node, rootId);\r\n                return {\r\n                    timestamp: e.timestamp,\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: {\r\n                        source: IncrementalSource$1.Mutation,\r\n                        adds: [\r\n                            {\r\n                                parentId: this.mirror.getId(iframeEl),\r\n                                nextId: null,\r\n                                node: e.data.node,\r\n                            },\r\n                        ],\r\n                        removes: [],\r\n                        texts: [],\r\n                        attributes: [],\r\n                        isAttachIframe: true,\r\n                    },\r\n                };\r\n            }\r\n            case EventType$1.Meta:\r\n            case EventType$1.Load:\r\n            case EventType$1.DomContentLoaded: {\r\n                return false;\r\n            }\r\n            case EventType$1.Plugin: {\r\n                return e;\r\n            }\r\n            case EventType$1.Custom: {\r\n                this.replaceIds(e.data.payload, iframeEl, ['id', 'parentId', 'previousId', 'nextId']);\r\n                return e;\r\n            }\r\n            case EventType$1.IncrementalSnapshot: {\r\n                switch (e.data.source) {\r\n                    case IncrementalSource$1.Mutation: {\r\n                        e.data.adds.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, [\r\n                                'parentId',\r\n                                'nextId',\r\n                                'previousId',\r\n                            ]);\r\n                            this.replaceIdOnNode(n.node, iframeEl);\r\n                            const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);\r\n                            rootId && this.patchRootIdOnNode(n.node, rootId);\r\n                        });\r\n                        e.data.removes.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['parentId', 'id']);\r\n                        });\r\n                        e.data.attributes.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['id']);\r\n                        });\r\n                        e.data.texts.forEach((n) => {\r\n                            this.replaceIds(n, iframeEl, ['id']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Drag:\r\n                    case IncrementalSource$1.TouchMove:\r\n                    case IncrementalSource$1.MouseMove: {\r\n                        e.data.positions.forEach((p) => {\r\n                            this.replaceIds(p, iframeEl, ['id']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.ViewportResize: {\r\n                        return false;\r\n                    }\r\n                    case IncrementalSource$1.MediaInteraction:\r\n                    case IncrementalSource$1.MouseInteraction:\r\n                    case IncrementalSource$1.Scroll:\r\n                    case IncrementalSource$1.CanvasMutation:\r\n                    case IncrementalSource$1.Input: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.StyleSheetRule:\r\n                    case IncrementalSource$1.StyleDeclaration: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        this.replaceStyleIds(e.data, iframeEl, ['styleId']);\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Font: {\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.Selection: {\r\n                        e.data.ranges.forEach((range) => {\r\n                            this.replaceIds(range, iframeEl, ['start', 'end']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                    case IncrementalSource$1.AdoptedStyleSheet: {\r\n                        this.replaceIds(e.data, iframeEl, ['id']);\r\n                        this.replaceStyleIds(e.data, iframeEl, ['styleIds']);\r\n                        (_a = e.data.styles) === null || _a === void 0 ? void 0 : _a.forEach((style) => {\r\n                            this.replaceStyleIds(style, iframeEl, ['styleId']);\r\n                        });\r\n                        return e;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    replace(iframeMirror, obj, iframeEl, keys) {\r\n        for (const key of keys) {\r\n            if (!Array.isArray(obj[key]) && typeof obj[key] !== 'number')\r\n                continue;\r\n            if (Array.isArray(obj[key])) {\r\n                obj[key] = iframeMirror.getIds(iframeEl, obj[key]);\r\n            }\r\n            else {\r\n                obj[key] = iframeMirror.getId(iframeEl, obj[key]);\r\n            }\r\n        }\r\n        return obj;\r\n    }\r\n    replaceIds(obj, iframeEl, keys) {\r\n        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);\r\n    }\r\n    replaceStyleIds(obj, iframeEl, keys) {\r\n        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);\r\n    }\r\n    replaceIdOnNode(node, iframeEl) {\r\n        this.replaceIds(node, iframeEl, ['id', 'rootId']);\r\n        if ('childNodes' in node) {\r\n            node.childNodes.forEach((child) => {\r\n                this.replaceIdOnNode(child, iframeEl);\r\n            });\r\n        }\r\n    }\r\n    patchRootIdOnNode(node, rootId) {\r\n        if (node.type !== NodeType.Document && !node.rootId)\r\n            node.rootId = rootId;\r\n        if ('childNodes' in node) {\r\n            node.childNodes.forEach((child) => {\r\n                this.patchRootIdOnNode(child, rootId);\r\n            });\r\n        }\r\n    }\r\n}\n\nclass ShadowDomManager {\r\n    constructor(options) {\r\n        this.shadowDoms = new WeakSet();\r\n        this.restoreHandlers = [];\r\n        this.mutationCb = options.mutationCb;\r\n        this.scrollCb = options.scrollCb;\r\n        this.bypassOptions = options.bypassOptions;\r\n        this.mirror = options.mirror;\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.reset();\r\n        this.patchAttachShadow(Element, document);\r\n    }\r\n    addShadowRoot(shadowRoot, doc) {\r\n        if (!isNativeShadowDom(shadowRoot))\r\n            return;\r\n        if (this.shadowDoms.has(shadowRoot))\r\n            return;\r\n        this.shadowDoms.add(shadowRoot);\r\n        const observer = initMutationObserver(Object.assign(Object.assign({}, this.bypassOptions), { doc, mutationCb: this.mutationCb, mirror: this.mirror, shadowDomManager: this }), shadowRoot);\r\n        this.restoreHandlers.push(() => observer.disconnect());\r\n        this.restoreHandlers.push(initScrollObserver(Object.assign(Object.assign({}, this.bypassOptions), { scrollCb: this.scrollCb, doc: shadowRoot, mirror: this.mirror })));\r\n        setTimeout(() => {\r\n            if (shadowRoot.adoptedStyleSheets &&\r\n                shadowRoot.adoptedStyleSheets.length > 0)\r\n                this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));\r\n            this.restoreHandlers.push(initAdoptedStyleSheetObserver({\r\n                mirror: this.mirror,\r\n                stylesheetManager: this.bypassOptions.stylesheetManager,\r\n            }, shadowRoot));\r\n        }, 0);\r\n    }\r\n    observeAttachShadow(iframeElement) {\r\n        if (!iframeElement.contentWindow || !iframeElement.contentDocument)\r\n            return;\r\n        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);\r\n    }\r\n    patchAttachShadow(element, doc) {\r\n        const manager = this;\r\n        this.restoreHandlers.push(patch(element.prototype, 'attachShadow', function (original) {\r\n            return function (option) {\r\n                const shadowRoot = original.call(this, option);\r\n                if (this.shadowRoot && inDom(this))\r\n                    manager.addShadowRoot(this.shadowRoot, doc);\r\n                return shadowRoot;\r\n            };\r\n        }));\r\n    }\r\n    reset() {\r\n        this.restoreHandlers.forEach((handler) => {\r\n            try {\r\n                handler();\r\n            }\r\n            catch (e) {\r\n            }\r\n        });\r\n        this.restoreHandlers = [];\r\n        this.shadowDoms = new WeakSet();\r\n    }\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/*\n * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n * Released under MIT License\n */\nvar chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nvar lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nvar encode = function (arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\n\nconst canvasVarMap = new Map();\r\nfunction variableListFor(ctx, ctor) {\r\n    let contextMap = canvasVarMap.get(ctx);\r\n    if (!contextMap) {\r\n        contextMap = new Map();\r\n        canvasVarMap.set(ctx, contextMap);\r\n    }\r\n    if (!contextMap.has(ctor)) {\r\n        contextMap.set(ctor, []);\r\n    }\r\n    return contextMap.get(ctor);\r\n}\r\nconst saveWebGLVar = (value, win, ctx) => {\r\n    if (!value ||\r\n        !(isInstanceOfWebGLObject(value, win) || typeof value === 'object'))\r\n        return;\r\n    const name = value.constructor.name;\r\n    const list = variableListFor(ctx, name);\r\n    let index = list.indexOf(value);\r\n    if (index === -1) {\r\n        index = list.length;\r\n        list.push(value);\r\n    }\r\n    return index;\r\n};\r\nfunction serializeArg(value, win, ctx) {\r\n    if (value instanceof Array) {\r\n        return value.map((arg) => serializeArg(arg, win, ctx));\r\n    }\r\n    else if (value === null) {\r\n        return value;\r\n    }\r\n    else if (value instanceof Float32Array ||\r\n        value instanceof Float64Array ||\r\n        value instanceof Int32Array ||\r\n        value instanceof Uint32Array ||\r\n        value instanceof Uint8Array ||\r\n        value instanceof Uint16Array ||\r\n        value instanceof Int16Array ||\r\n        value instanceof Int8Array ||\r\n        value instanceof Uint8ClampedArray) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [Object.values(value)],\r\n        };\r\n    }\r\n    else if (value instanceof ArrayBuffer) {\r\n        const name = value.constructor.name;\r\n        const base64 = encode(value);\r\n        return {\r\n            rr_type: name,\r\n            base64,\r\n        };\r\n    }\r\n    else if (value instanceof DataView) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [\r\n                serializeArg(value.buffer, win, ctx),\r\n                value.byteOffset,\r\n                value.byteLength,\r\n            ],\r\n        };\r\n    }\r\n    else if (value instanceof HTMLImageElement) {\r\n        const name = value.constructor.name;\r\n        const { src } = value;\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof HTMLCanvasElement) {\r\n        const name = 'HTMLImageElement';\r\n        const src = value.toDataURL();\r\n        return {\r\n            rr_type: name,\r\n            src,\r\n        };\r\n    }\r\n    else if (value instanceof ImageData) {\r\n        const name = value.constructor.name;\r\n        return {\r\n            rr_type: name,\r\n            args: [serializeArg(value.data, win, ctx), value.width, value.height],\r\n        };\r\n    }\r\n    else if (isInstanceOfWebGLObject(value, win) || typeof value === 'object') {\r\n        const name = value.constructor.name;\r\n        const index = saveWebGLVar(value, win, ctx);\r\n        return {\r\n            rr_type: name,\r\n            index: index,\r\n        };\r\n    }\r\n    return value;\r\n}\r\nconst serializeArgs = (args, win, ctx) => {\r\n    return args.map((arg) => serializeArg(arg, win, ctx));\r\n};\r\nconst isInstanceOfWebGLObject = (value, win) => {\r\n    const webGLConstructorNames = [\r\n        'WebGLActiveInfo',\r\n        'WebGLBuffer',\r\n        'WebGLFramebuffer',\r\n        'WebGLProgram',\r\n        'WebGLRenderbuffer',\r\n        'WebGLShader',\r\n        'WebGLShaderPrecisionFormat',\r\n        'WebGLTexture',\r\n        'WebGLUniformLocation',\r\n        'WebGLVertexArrayObject',\r\n        'WebGLVertexArrayObjectOES',\r\n    ];\r\n    const supportedWebGLConstructorNames = webGLConstructorNames.filter((name) => typeof win[name] === 'function');\r\n    return Boolean(supportedWebGLConstructorNames.find((name) => value instanceof win[name]));\r\n};\n\nfunction initCanvas2DMutationObserver(cb, win, blockClass, blockSelector) {\r\n    const handlers = [];\r\n    const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);\r\n    for (const prop of props2D) {\r\n        try {\r\n            if (typeof win.CanvasRenderingContext2D.prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    if (!isBlocked(this.canvas, blockClass, blockSelector, true)) {\r\n                        setTimeout(() => {\r\n                            const recordArgs = serializeArgs(args, win, this);\r\n                            cb(this.canvas, {\r\n                                type: CanvasContext['2D'],\r\n                                property: prop,\r\n                                args: recordArgs,\r\n                            });\r\n                        }, 0);\r\n                    }\r\n                    return original.apply(this, args);\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch (_a) {\r\n            const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type: CanvasContext['2D'],\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction getNormalizedContextName(contextType) {\r\n    return contextType === 'experimental-webgl' ? 'webgl' : contextType;\r\n}\r\nfunction initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {\r\n    const handlers = [];\r\n    try {\r\n        const restoreHandler = patch(win.HTMLCanvasElement.prototype, 'getContext', function (original) {\r\n            return function (contextType, ...args) {\r\n                if (!isBlocked(this, blockClass, blockSelector, true)) {\r\n                    const ctxName = getNormalizedContextName(contextType);\r\n                    if (!('__context' in this))\r\n                        this.__context = ctxName;\r\n                    if (setPreserveDrawingBufferToTrue &&\r\n                        ['webgl', 'webgl2'].includes(ctxName)) {\r\n                        if (args[0] && typeof args[0] === 'object') {\r\n                            const contextAttributes = args[0];\r\n                            if (!contextAttributes.preserveDrawingBuffer) {\r\n                                contextAttributes.preserveDrawingBuffer = true;\r\n                            }\r\n                        }\r\n                        else {\r\n                            args.splice(0, 1, {\r\n                                preserveDrawingBuffer: true,\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                return original.apply(this, [contextType, ...args]);\r\n            };\r\n        });\r\n        handlers.push(restoreHandler);\r\n    }\r\n    catch (_a) {\r\n        console.error('failed to patch HTMLCanvasElement.prototype.getContext');\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction patchGLPrototype(prototype, type, cb, blockClass, blockSelector, mirror, win) {\r\n    const handlers = [];\r\n    const props = Object.getOwnPropertyNames(prototype);\r\n    for (const prop of props) {\r\n        if ([\r\n            'isContextLost',\r\n            'canvas',\r\n            'drawingBufferWidth',\r\n            'drawingBufferHeight',\r\n        ].includes(prop)) {\r\n            continue;\r\n        }\r\n        try {\r\n            if (typeof prototype[prop] !== 'function') {\r\n                continue;\r\n            }\r\n            const restoreHandler = patch(prototype, prop, function (original) {\r\n                return function (...args) {\r\n                    const result = original.apply(this, args);\r\n                    saveWebGLVar(result, win, this);\r\n                    if ('tagName' in this.canvas &&\r\n                        !isBlocked(this.canvas, blockClass, blockSelector, true)) {\r\n                        const recordArgs = serializeArgs(args, win, this);\r\n                        const mutation = {\r\n                            type,\r\n                            property: prop,\r\n                            args: recordArgs,\r\n                        };\r\n                        cb(this.canvas, mutation);\r\n                    }\r\n                    return result;\r\n                };\r\n            });\r\n            handlers.push(restoreHandler);\r\n        }\r\n        catch (_a) {\r\n            const hookHandler = hookSetter(prototype, prop, {\r\n                set(v) {\r\n                    cb(this.canvas, {\r\n                        type,\r\n                        property: prop,\r\n                        args: [v],\r\n                        setter: true,\r\n                    });\r\n                },\r\n            });\r\n            handlers.push(hookHandler);\r\n        }\r\n    }\r\n    return handlers;\r\n}\r\nfunction initCanvasWebGLMutationObserver(cb, win, blockClass, blockSelector, mirror) {\r\n    const handlers = [];\r\n    handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass, blockSelector, mirror, win));\r\n    if (typeof win.WebGL2RenderingContext !== 'undefined') {\r\n        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass, blockSelector, mirror, win));\r\n    }\r\n    return () => {\r\n        handlers.forEach((h) => h());\r\n    };\r\n}\n\nfunction funcToSource(fn, sourcemapArg) {\n    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;\n    var source = fn.toString();\n    var lines = source.split('\\n');\n    lines.pop();\n    lines.shift();\n    var blankPrefixLength = lines[0].search(/\\S/);\n    var regex = /(['\"])__worker_loader_strict__(['\"])/g;\n    for (var i = 0, n = lines.length; i < n; ++i) {\n        lines[i] = lines[i].substring(blankPrefixLength).replace(regex, '$1use strict$2') + '\\n';\n    }\n    if (sourcemap) {\n        lines.push('\\/\\/# sourceMappingURL=' + sourcemap + '\\n');\n    }\n    return lines;\n}\n\nfunction createURL(fn, sourcemapArg) {\n    var lines = funcToSource(fn, sourcemapArg);\n    var blob = new Blob(lines, { type: 'application/javascript' });\n    return URL.createObjectURL(blob);\n}\n\nfunction createInlineWorkerFactory(fn, sourcemapArg) {\n    var url;\n    return function WorkerFactory(options) {\n        url = url || createURL(fn, sourcemapArg);\n        return new Worker(url, options);\n    };\n}\n\nvar WorkerFactory = createInlineWorkerFactory(/* rollup-plugin-web-worker-loader */function () {\n(function () {\n    '__worker_loader_strict__';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n\r\n    function __awaiter(thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    }\n\n    /*\n     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>\n     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>\n     * Released under MIT License\n     */\n    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    // Use a lookup table to find the index.\n    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n    for (var i = 0; i < chars.length; i++) {\n        lookup[chars.charCodeAt(i)] = i;\n    }\n    var encode = function (arraybuffer) {\n        var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n        for (i = 0; i < len; i += 3) {\n            base64 += chars[bytes[i] >> 2];\n            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n            base64 += chars[bytes[i + 2] & 63];\n        }\n        if (len % 3 === 2) {\n            base64 = base64.substring(0, base64.length - 1) + '=';\n        }\n        else if (len % 3 === 1) {\n            base64 = base64.substring(0, base64.length - 2) + '==';\n        }\n        return base64;\n    };\n\n    const lastBlobMap = new Map();\r\n    const transparentBlobMap = new Map();\r\n    function getTransparentBlobFor(width, height, dataURLOptions) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const id = `${width}-${height}`;\r\n            if ('OffscreenCanvas' in globalThis) {\r\n                if (transparentBlobMap.has(id))\r\n                    return transparentBlobMap.get(id);\r\n                const offscreen = new OffscreenCanvas(width, height);\r\n                offscreen.getContext('2d');\r\n                const blob = yield offscreen.convertToBlob(dataURLOptions);\r\n                const arrayBuffer = yield blob.arrayBuffer();\r\n                const base64 = encode(arrayBuffer);\r\n                transparentBlobMap.set(id, base64);\r\n                return base64;\r\n            }\r\n            else {\r\n                return '';\r\n            }\r\n        });\r\n    }\r\n    const worker = self;\r\n    worker.onmessage = function (e) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if ('OffscreenCanvas' in globalThis) {\r\n                const { id, bitmap, width, height, dataURLOptions } = e.data;\r\n                const transparentBase64 = getTransparentBlobFor(width, height, dataURLOptions);\r\n                const offscreen = new OffscreenCanvas(width, height);\r\n                const ctx = offscreen.getContext('2d');\r\n                ctx.drawImage(bitmap, 0, 0);\r\n                bitmap.close();\r\n                const blob = yield offscreen.convertToBlob(dataURLOptions);\r\n                const type = blob.type;\r\n                const arrayBuffer = yield blob.arrayBuffer();\r\n                const base64 = encode(arrayBuffer);\r\n                if (!lastBlobMap.has(id) && (yield transparentBase64) === base64) {\r\n                    lastBlobMap.set(id, base64);\r\n                    return worker.postMessage({ id });\r\n                }\r\n                if (lastBlobMap.get(id) === base64)\r\n                    return worker.postMessage({ id });\r\n                worker.postMessage({\r\n                    id,\r\n                    type,\r\n                    base64,\r\n                    width,\r\n                    height,\r\n                });\r\n                lastBlobMap.set(id, base64);\r\n            }\r\n            else {\r\n                return worker.postMessage({ id: e.data.id });\r\n            }\r\n        });\r\n    };\n\n})();\n}, null);\n\nclass CanvasManager {\r\n    reset() {\r\n        this.pendingCanvasMutations.clear();\r\n        this.resetObservers && this.resetObservers();\r\n    }\r\n    freeze() {\r\n        this.frozen = true;\r\n    }\r\n    unfreeze() {\r\n        this.frozen = false;\r\n    }\r\n    lock() {\r\n        this.locked = true;\r\n    }\r\n    unlock() {\r\n        this.locked = false;\r\n    }\r\n    constructor(options) {\r\n        this.pendingCanvasMutations = new Map();\r\n        this.rafStamps = { latestId: 0, invokeId: null };\r\n        this.frozen = false;\r\n        this.locked = false;\r\n        this.processMutation = (target, mutation) => {\r\n            const newFrame = this.rafStamps.invokeId &&\r\n                this.rafStamps.latestId !== this.rafStamps.invokeId;\r\n            if (newFrame || !this.rafStamps.invokeId)\r\n                this.rafStamps.invokeId = this.rafStamps.latestId;\r\n            if (!this.pendingCanvasMutations.has(target)) {\r\n                this.pendingCanvasMutations.set(target, []);\r\n            }\r\n            this.pendingCanvasMutations.get(target).push(mutation);\r\n        };\r\n        const { sampling = 'all', win, blockClass, blockSelector, recordCanvas, dataURLOptions, } = options;\r\n        this.mutationCb = options.mutationCb;\r\n        this.mirror = options.mirror;\r\n        if (recordCanvas && sampling === 'all')\r\n            this.initCanvasMutationObserver(win, blockClass, blockSelector);\r\n        if (recordCanvas && typeof sampling === 'number')\r\n            this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {\r\n                dataURLOptions,\r\n            });\r\n    }\r\n    initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);\r\n        const snapshotInProgressMap = new Map();\r\n        const worker = new WorkerFactory();\r\n        worker.onmessage = (e) => {\r\n            const { id } = e.data;\r\n            snapshotInProgressMap.set(id, false);\r\n            if (!('base64' in e.data))\r\n                return;\r\n            const { base64, type, width, height } = e.data;\r\n            this.mutationCb({\r\n                id,\r\n                type: CanvasContext['2D'],\r\n                commands: [\r\n                    {\r\n                        property: 'clearRect',\r\n                        args: [0, 0, width, height],\r\n                    },\r\n                    {\r\n                        property: 'drawImage',\r\n                        args: [\r\n                            {\r\n                                rr_type: 'ImageBitmap',\r\n                                args: [\r\n                                    {\r\n                                        rr_type: 'Blob',\r\n                                        data: [{ rr_type: 'ArrayBuffer', base64 }],\r\n                                        type,\r\n                                    },\r\n                                ],\r\n                            },\r\n                            0,\r\n                            0,\r\n                        ],\r\n                    },\r\n                ],\r\n            });\r\n        };\r\n        const timeBetweenSnapshots = 1000 / fps;\r\n        let lastSnapshotTime = 0;\r\n        let rafId;\r\n        const getCanvas = () => {\r\n            const matchedCanvas = [];\r\n            win.document.querySelectorAll('canvas').forEach((canvas) => {\r\n                if (!isBlocked(canvas, blockClass, blockSelector, true)) {\r\n                    matchedCanvas.push(canvas);\r\n                }\r\n            });\r\n            return matchedCanvas;\r\n        };\r\n        const takeCanvasSnapshots = (timestamp) => {\r\n            if (lastSnapshotTime &&\r\n                timestamp - lastSnapshotTime < timeBetweenSnapshots) {\r\n                rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n                return;\r\n            }\r\n            lastSnapshotTime = timestamp;\r\n            getCanvas()\r\n                .forEach((canvas) => __awaiter(this, void 0, void 0, function* () {\r\n                var _a;\r\n                const id = this.mirror.getId(canvas);\r\n                if (snapshotInProgressMap.get(id))\r\n                    return;\r\n                if (canvas.width === 0 || canvas.height === 0)\r\n                    return;\r\n                snapshotInProgressMap.set(id, true);\r\n                if (['webgl', 'webgl2'].includes(canvas.__context)) {\r\n                    const context = canvas.getContext(canvas.__context);\r\n                    if (((_a = context === null || context === void 0 ? void 0 : context.getContextAttributes()) === null || _a === void 0 ? void 0 : _a.preserveDrawingBuffer) === false) {\r\n                        context.clear(context.COLOR_BUFFER_BIT);\r\n                    }\r\n                }\r\n                const bitmap = yield createImageBitmap(canvas);\r\n                worker.postMessage({\r\n                    id,\r\n                    bitmap,\r\n                    width: canvas.width,\r\n                    height: canvas.height,\r\n                    dataURLOptions: options.dataURLOptions,\r\n                }, [bitmap]);\r\n            }));\r\n            rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n        };\r\n        rafId = requestAnimationFrame(takeCanvasSnapshots);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            cancelAnimationFrame(rafId);\r\n        };\r\n    }\r\n    initCanvasMutationObserver(win, blockClass, blockSelector) {\r\n        this.startRAFTimestamping();\r\n        this.startPendingCanvasMutationFlusher();\r\n        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);\r\n        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);\r\n        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, this.mirror);\r\n        this.resetObservers = () => {\r\n            canvasContextReset();\r\n            canvas2DReset();\r\n            canvasWebGL1and2Reset();\r\n        };\r\n    }\r\n    startPendingCanvasMutationFlusher() {\r\n        requestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    startRAFTimestamping() {\r\n        const setLatestRAFTimestamp = (timestamp) => {\r\n            this.rafStamps.latestId = timestamp;\r\n            requestAnimationFrame(setLatestRAFTimestamp);\r\n        };\r\n        requestAnimationFrame(setLatestRAFTimestamp);\r\n    }\r\n    flushPendingCanvasMutations() {\r\n        this.pendingCanvasMutations.forEach((values, canvas) => {\r\n            const id = this.mirror.getId(canvas);\r\n            this.flushPendingCanvasMutationFor(canvas, id);\r\n        });\r\n        requestAnimationFrame(() => this.flushPendingCanvasMutations());\r\n    }\r\n    flushPendingCanvasMutationFor(canvas, id) {\r\n        if (this.frozen || this.locked) {\r\n            return;\r\n        }\r\n        const valuesWithType = this.pendingCanvasMutations.get(canvas);\r\n        if (!valuesWithType || id === -1)\r\n            return;\r\n        const values = valuesWithType.map((value) => {\r\n            const rest = __rest(value, [\"type\"]);\r\n            return rest;\r\n        });\r\n        const { type } = valuesWithType[0];\r\n        this.mutationCb({ id, type, commands: values });\r\n        this.pendingCanvasMutations.delete(canvas);\r\n    }\r\n}\n\nclass StylesheetManager {\r\n    constructor(options) {\r\n        this.trackedLinkElements = new WeakSet();\r\n        this.styleMirror = new StyleSheetMirror();\r\n        this.mutationCb = options.mutationCb;\r\n        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;\r\n    }\r\n    attachLinkElement(linkEl, childSn) {\r\n        if ('_cssText' in childSn.attributes)\r\n            this.mutationCb({\r\n                adds: [],\r\n                removes: [],\r\n                texts: [],\r\n                attributes: [\r\n                    {\r\n                        id: childSn.id,\r\n                        attributes: childSn\r\n                            .attributes,\r\n                    },\r\n                ],\r\n            });\r\n        this.trackLinkElement(linkEl);\r\n    }\r\n    trackLinkElement(linkEl) {\r\n        if (this.trackedLinkElements.has(linkEl))\r\n            return;\r\n        this.trackedLinkElements.add(linkEl);\r\n        this.trackStylesheetInLinkElement(linkEl);\r\n    }\r\n    adoptStyleSheets(sheets, hostId) {\r\n        if (sheets.length === 0)\r\n            return;\r\n        const adoptedStyleSheetData = {\r\n            id: hostId,\r\n            styleIds: [],\r\n        };\r\n        const styles = [];\r\n        for (const sheet of sheets) {\r\n            let styleId;\r\n            if (!this.styleMirror.has(sheet)) {\r\n                styleId = this.styleMirror.add(sheet);\r\n                styles.push({\r\n                    styleId,\r\n                    rules: Array.from(sheet.rules || CSSRule, (r, index) => ({\r\n                        rule: stringifyRule(r),\r\n                        index,\r\n                    })),\r\n                });\r\n            }\r\n            else\r\n                styleId = this.styleMirror.getId(sheet);\r\n            adoptedStyleSheetData.styleIds.push(styleId);\r\n        }\r\n        if (styles.length > 0)\r\n            adoptedStyleSheetData.styles = styles;\r\n        this.adoptedStyleSheetCb(adoptedStyleSheetData);\r\n    }\r\n    reset() {\r\n        this.styleMirror.reset();\r\n        this.trackedLinkElements = new WeakSet();\r\n    }\r\n    trackStylesheetInLinkElement(linkEl) {\r\n    }\r\n}\n\nclass ProcessedNodeManager {\r\n    constructor() {\r\n        this.nodeMap = new WeakMap();\r\n        this.loop = true;\r\n        this.periodicallyClear();\r\n    }\r\n    periodicallyClear() {\r\n        requestAnimationFrame(() => {\r\n            this.clear();\r\n            if (this.loop)\r\n                this.periodicallyClear();\r\n        });\r\n    }\r\n    inOtherBuffer(node, thisBuffer) {\r\n        const buffers = this.nodeMap.get(node);\r\n        return (buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer));\r\n    }\r\n    add(node, buffer) {\r\n        this.nodeMap.set(node, (this.nodeMap.get(node) || new Set()).add(buffer));\r\n    }\r\n    clear() {\r\n        this.nodeMap = new WeakMap();\r\n    }\r\n    destroy() {\r\n        this.loop = false;\r\n    }\r\n}\n\nfunction wrapEvent(e) {\r\n    return Object.assign(Object.assign({}, e), { timestamp: nowTimestamp() });\r\n}\r\nlet wrappedEmit;\r\nlet takeFullSnapshot;\r\nlet canvasManager;\r\nlet recording = false;\r\nconst mirror = createMirror();\r\nfunction record(options = {}) {\r\n    const { emit, checkoutEveryNms, checkoutEveryNth, blockClass = 'rr-block', blockSelector = null, ignoreClass = 'rr-ignore', ignoreSelector = null, maskTextClass = 'rr-mask', maskTextSelector = null, inlineStylesheet = true, maskAllInputs, maskInputOptions: _maskInputOptions, slimDOMOptions: _slimDOMOptions, maskInputFn, maskTextFn, hooks, packFn, sampling = {}, dataURLOptions = {}, mousemoveWait, recordDOM = true, recordCanvas = false, recordCrossOriginIframes = false, recordAfter = options.recordAfter === 'DOMContentLoaded'\r\n        ? options.recordAfter\r\n        : 'load', userTriggeredOnInput = false, collectFonts = false, inlineImages = false, plugins, keepIframeSrcFn = () => false, ignoreCSSAttributes = new Set([]), errorHandler, } = options;\r\n    registerErrorHandler(errorHandler);\r\n    const inEmittingFrame = recordCrossOriginIframes\r\n        ? window.parent === window\r\n        : true;\r\n    let passEmitsToParent = false;\r\n    if (!inEmittingFrame) {\r\n        try {\r\n            if (window.parent.document) {\r\n                passEmitsToParent = false;\r\n            }\r\n        }\r\n        catch (e) {\r\n            passEmitsToParent = true;\r\n        }\r\n    }\r\n    if (inEmittingFrame && !emit) {\r\n        throw new Error('emit function is required');\r\n    }\r\n    if (mousemoveWait !== undefined && sampling.mousemove === undefined) {\r\n        sampling.mousemove = mousemoveWait;\r\n    }\r\n    mirror.reset();\r\n    const maskInputOptions = maskAllInputs === true\r\n        ? {\r\n            color: true,\r\n            date: true,\r\n            'datetime-local': true,\r\n            email: true,\r\n            month: true,\r\n            number: true,\r\n            range: true,\r\n            search: true,\r\n            tel: true,\r\n            text: true,\r\n            time: true,\r\n            url: true,\r\n            week: true,\r\n            textarea: true,\r\n            select: true,\r\n            password: true,\r\n        }\r\n        : _maskInputOptions !== undefined\r\n            ? _maskInputOptions\r\n            : { password: true };\r\n    const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === 'all'\r\n        ? {\r\n            script: true,\r\n            comment: true,\r\n            headFavicon: true,\r\n            headWhitespace: true,\r\n            headMetaSocial: true,\r\n            headMetaRobots: true,\r\n            headMetaHttpEquiv: true,\r\n            headMetaVerification: true,\r\n            headMetaAuthorship: _slimDOMOptions === 'all',\r\n            headMetaDescKeywords: _slimDOMOptions === 'all',\r\n        }\r\n        : _slimDOMOptions\r\n            ? _slimDOMOptions\r\n            : {};\r\n    polyfill();\r\n    let lastFullSnapshotEvent;\r\n    let incrementalSnapshotCount = 0;\r\n    const eventProcessor = (e) => {\r\n        for (const plugin of plugins || []) {\r\n            if (plugin.eventProcessor) {\r\n                e = plugin.eventProcessor(e);\r\n            }\r\n        }\r\n        if (packFn &&\r\n            !passEmitsToParent) {\r\n            e = packFn(e);\r\n        }\r\n        return e;\r\n    };\r\n    wrappedEmit = (e, isCheckout) => {\r\n        var _a;\r\n        if (((_a = mutationBuffers[0]) === null || _a === void 0 ? void 0 : _a.isFrozen()) &&\r\n            e.type !== EventType$1.FullSnapshot &&\r\n            !(e.type === EventType$1.IncrementalSnapshot &&\r\n                e.data.source === IncrementalSource$1.Mutation)) {\r\n            mutationBuffers.forEach((buf) => buf.unfreeze());\r\n        }\r\n        if (inEmittingFrame) {\r\n            emit === null || emit === void 0 ? void 0 : emit(eventProcessor(e), isCheckout);\r\n        }\r\n        else if (passEmitsToParent) {\r\n            const message = {\r\n                type: 'rrweb',\r\n                event: eventProcessor(e),\r\n                origin: window.location.origin,\r\n                isCheckout,\r\n            };\r\n            window.parent.postMessage(message, '*');\r\n        }\r\n        if (e.type === EventType$1.FullSnapshot) {\r\n            lastFullSnapshotEvent = e;\r\n            incrementalSnapshotCount = 0;\r\n        }\r\n        else if (e.type === EventType$1.IncrementalSnapshot) {\r\n            if (e.data.source === IncrementalSource$1.Mutation &&\r\n                e.data.isAttachIframe) {\r\n                return;\r\n            }\r\n            incrementalSnapshotCount++;\r\n            const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;\r\n            const exceedTime = checkoutEveryNms &&\r\n                e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;\r\n            if (exceedCount || exceedTime) {\r\n                takeFullSnapshot(true);\r\n            }\r\n        }\r\n    };\r\n    const wrappedMutationEmit = (m) => {\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.IncrementalSnapshot,\r\n            data: Object.assign({ source: IncrementalSource$1.Mutation }, m),\r\n        }));\r\n    };\r\n    const wrappedScrollEmit = (p) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.Scroll }, p),\r\n    }));\r\n    const wrappedCanvasMutationEmit = (p) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.CanvasMutation }, p),\r\n    }));\r\n    const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit(wrapEvent({\r\n        type: EventType$1.IncrementalSnapshot,\r\n        data: Object.assign({ source: IncrementalSource$1.AdoptedStyleSheet }, a),\r\n    }));\r\n    const stylesheetManager = new StylesheetManager({\r\n        mutationCb: wrappedMutationEmit,\r\n        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit,\r\n    });\r\n    const iframeManager = new IframeManager({\r\n        mirror,\r\n        mutationCb: wrappedMutationEmit,\r\n        stylesheetManager: stylesheetManager,\r\n        recordCrossOriginIframes,\r\n        wrappedEmit,\r\n    });\r\n    for (const plugin of plugins || []) {\r\n        if (plugin.getMirror)\r\n            plugin.getMirror({\r\n                nodeMirror: mirror,\r\n                crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,\r\n                crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror,\r\n            });\r\n    }\r\n    const processedNodeManager = new ProcessedNodeManager();\r\n    canvasManager = new CanvasManager({\r\n        recordCanvas,\r\n        mutationCb: wrappedCanvasMutationEmit,\r\n        win: window,\r\n        blockClass,\r\n        blockSelector,\r\n        mirror,\r\n        sampling: sampling.canvas,\r\n        dataURLOptions,\r\n    });\r\n    const shadowDomManager = new ShadowDomManager({\r\n        mutationCb: wrappedMutationEmit,\r\n        scrollCb: wrappedScrollEmit,\r\n        bypassOptions: {\r\n            blockClass,\r\n            blockSelector,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            inlineStylesheet,\r\n            maskInputOptions,\r\n            dataURLOptions,\r\n            maskTextFn,\r\n            maskInputFn,\r\n            recordCanvas,\r\n            inlineImages,\r\n            sampling,\r\n            slimDOMOptions,\r\n            iframeManager,\r\n            stylesheetManager,\r\n            canvasManager,\r\n            keepIframeSrcFn,\r\n            processedNodeManager,\r\n        },\r\n        mirror,\r\n    });\r\n    takeFullSnapshot = (isCheckout = false) => {\r\n        if (!recordDOM) {\r\n            return;\r\n        }\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.Meta,\r\n            data: {\r\n                href: window.location.href,\r\n                width: getWindowWidth(),\r\n                height: getWindowHeight(),\r\n            },\r\n        }), isCheckout);\r\n        stylesheetManager.reset();\r\n        shadowDomManager.init();\r\n        mutationBuffers.forEach((buf) => buf.lock());\r\n        const node = snapshot(document, {\r\n            mirror,\r\n            blockClass,\r\n            blockSelector,\r\n            maskTextClass,\r\n            maskTextSelector,\r\n            inlineStylesheet,\r\n            maskAllInputs: maskInputOptions,\r\n            maskTextFn,\r\n            slimDOM: slimDOMOptions,\r\n            dataURLOptions,\r\n            recordCanvas,\r\n            inlineImages,\r\n            onSerialize: (n) => {\r\n                if (isSerializedIframe(n, mirror)) {\r\n                    iframeManager.addIframe(n);\r\n                }\r\n                if (isSerializedStylesheet(n, mirror)) {\r\n                    stylesheetManager.trackLinkElement(n);\r\n                }\r\n                if (hasShadowRoot(n)) {\r\n                    shadowDomManager.addShadowRoot(n.shadowRoot, document);\r\n                }\r\n            },\r\n            onIframeLoad: (iframe, childSn) => {\r\n                iframeManager.attachIframe(iframe, childSn);\r\n                shadowDomManager.observeAttachShadow(iframe);\r\n            },\r\n            onStylesheetLoad: (linkEl, childSn) => {\r\n                stylesheetManager.attachLinkElement(linkEl, childSn);\r\n            },\r\n            keepIframeSrcFn,\r\n        });\r\n        if (!node) {\r\n            return console.warn('Failed to snapshot the document');\r\n        }\r\n        wrappedEmit(wrapEvent({\r\n            type: EventType$1.FullSnapshot,\r\n            data: {\r\n                node,\r\n                initialOffset: getWindowScroll(window),\r\n            },\r\n        }), isCheckout);\r\n        mutationBuffers.forEach((buf) => buf.unlock());\r\n        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)\r\n            stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));\r\n    };\r\n    try {\r\n        const handlers = [];\r\n        const observe = (doc) => {\r\n            var _a;\r\n            return callbackWrapper(initObservers)({\r\n                mutationCb: wrappedMutationEmit,\r\n                mousemoveCb: (positions, source) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: {\r\n                        source,\r\n                        positions,\r\n                    },\r\n                })),\r\n                mouseInteractionCb: (d) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.MouseInteraction }, d),\r\n                })),\r\n                scrollCb: wrappedScrollEmit,\r\n                viewportResizeCb: (d) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.ViewportResize }, d),\r\n                })),\r\n                inputCb: (v) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.Input }, v),\r\n                })),\r\n                mediaInteractionCb: (p) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.MediaInteraction }, p),\r\n                })),\r\n                styleSheetRuleCb: (r) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.StyleSheetRule }, r),\r\n                })),\r\n                styleDeclarationCb: (r) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.StyleDeclaration }, r),\r\n                })),\r\n                canvasMutationCb: wrappedCanvasMutationEmit,\r\n                fontCb: (p) => wrappedEmit(wrapEvent({\r\n                    type: EventType$1.IncrementalSnapshot,\r\n                    data: Object.assign({ source: IncrementalSource$1.Font }, p),\r\n                })),\r\n                selectionCb: (p) => {\r\n                    wrappedEmit(wrapEvent({\r\n                        type: EventType$1.IncrementalSnapshot,\r\n                        data: Object.assign({ source: IncrementalSource$1.Selection }, p),\r\n                    }));\r\n                },\r\n                customElementCb: (c) => {\r\n                    wrappedEmit(wrapEvent({\r\n                        type: EventType$1.IncrementalSnapshot,\r\n                        data: Object.assign({ source: IncrementalSource$1.CustomElement }, c),\r\n                    }));\r\n                },\r\n                blockClass,\r\n                ignoreClass,\r\n                ignoreSelector,\r\n                maskTextClass,\r\n                maskTextSelector,\r\n                maskInputOptions,\r\n                inlineStylesheet,\r\n                sampling,\r\n                recordDOM,\r\n                recordCanvas,\r\n                inlineImages,\r\n                userTriggeredOnInput,\r\n                collectFonts,\r\n                doc,\r\n                maskInputFn,\r\n                maskTextFn,\r\n                keepIframeSrcFn,\r\n                blockSelector,\r\n                slimDOMOptions,\r\n                dataURLOptions,\r\n                mirror,\r\n                iframeManager,\r\n                stylesheetManager,\r\n                shadowDomManager,\r\n                processedNodeManager,\r\n                canvasManager,\r\n                ignoreCSSAttributes,\r\n                plugins: ((_a = plugins === null || plugins === void 0 ? void 0 : plugins.filter((p) => p.observer)) === null || _a === void 0 ? void 0 : _a.map((p) => ({\r\n                    observer: p.observer,\r\n                    options: p.options,\r\n                    callback: (payload) => wrappedEmit(wrapEvent({\r\n                        type: EventType$1.Plugin,\r\n                        data: {\r\n                            plugin: p.name,\r\n                            payload,\r\n                        },\r\n                    })),\r\n                }))) || [],\r\n            }, hooks);\r\n        };\r\n        iframeManager.addLoadListener((iframeEl) => {\r\n            try {\r\n                handlers.push(observe(iframeEl.contentDocument));\r\n            }\r\n            catch (error) {\r\n                console.warn(error);\r\n            }\r\n        });\r\n        const init = () => {\r\n            takeFullSnapshot();\r\n            handlers.push(observe(document));\r\n            recording = true;\r\n        };\r\n        if (document.readyState === 'interactive' ||\r\n            document.readyState === 'complete') {\r\n            init();\r\n        }\r\n        else {\r\n            handlers.push(on('DOMContentLoaded', () => {\r\n                wrappedEmit(wrapEvent({\r\n                    type: EventType$1.DomContentLoaded,\r\n                    data: {},\r\n                }));\r\n                if (recordAfter === 'DOMContentLoaded')\r\n                    init();\r\n            }));\r\n            handlers.push(on('load', () => {\r\n                wrappedEmit(wrapEvent({\r\n                    type: EventType$1.Load,\r\n                    data: {},\r\n                }));\r\n                if (recordAfter === 'load')\r\n                    init();\r\n            }, window));\r\n        }\r\n        return () => {\r\n            handlers.forEach((h) => h());\r\n            processedNodeManager.destroy();\r\n            recording = false;\r\n            unregisterErrorHandler();\r\n        };\r\n    }\r\n    catch (error) {\r\n        console.warn(error);\r\n    }\r\n}\r\nrecord.addCustomEvent = (tag, payload) => {\r\n    if (!recording) {\r\n        throw new Error('please add custom event after start recording');\r\n    }\r\n    wrappedEmit(wrapEvent({\r\n        type: EventType$1.Custom,\r\n        data: {\r\n            tag,\r\n            payload,\r\n        },\r\n    }));\r\n};\r\nrecord.freezePage = () => {\r\n    mutationBuffers.forEach((buf) => buf.freeze());\r\n};\r\nrecord.takeFullSnapshot = (isCheckout) => {\r\n    if (!recording) {\r\n        throw new Error('please take full snapshot after start recording');\r\n    }\r\n    takeFullSnapshot(isCheckout);\r\n};\r\nrecord.mirror = mirror;\n\nvar EventType = /* @__PURE__ */ ((EventType2) => {\n  EventType2[EventType2[\"DomContentLoaded\"] = 0] = \"DomContentLoaded\";\n  EventType2[EventType2[\"Load\"] = 1] = \"Load\";\n  EventType2[EventType2[\"FullSnapshot\"] = 2] = \"FullSnapshot\";\n  EventType2[EventType2[\"IncrementalSnapshot\"] = 3] = \"IncrementalSnapshot\";\n  EventType2[EventType2[\"Meta\"] = 4] = \"Meta\";\n  EventType2[EventType2[\"Custom\"] = 5] = \"Custom\";\n  EventType2[EventType2[\"Plugin\"] = 6] = \"Plugin\";\n  return EventType2;\n})(EventType || {});\nvar IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {\n  IncrementalSource2[IncrementalSource2[\"Mutation\"] = 0] = \"Mutation\";\n  IncrementalSource2[IncrementalSource2[\"MouseMove\"] = 1] = \"MouseMove\";\n  IncrementalSource2[IncrementalSource2[\"MouseInteraction\"] = 2] = \"MouseInteraction\";\n  IncrementalSource2[IncrementalSource2[\"Scroll\"] = 3] = \"Scroll\";\n  IncrementalSource2[IncrementalSource2[\"ViewportResize\"] = 4] = \"ViewportResize\";\n  IncrementalSource2[IncrementalSource2[\"Input\"] = 5] = \"Input\";\n  IncrementalSource2[IncrementalSource2[\"TouchMove\"] = 6] = \"TouchMove\";\n  IncrementalSource2[IncrementalSource2[\"MediaInteraction\"] = 7] = \"MediaInteraction\";\n  IncrementalSource2[IncrementalSource2[\"StyleSheetRule\"] = 8] = \"StyleSheetRule\";\n  IncrementalSource2[IncrementalSource2[\"CanvasMutation\"] = 9] = \"CanvasMutation\";\n  IncrementalSource2[IncrementalSource2[\"Font\"] = 10] = \"Font\";\n  IncrementalSource2[IncrementalSource2[\"Log\"] = 11] = \"Log\";\n  IncrementalSource2[IncrementalSource2[\"Drag\"] = 12] = \"Drag\";\n  IncrementalSource2[IncrementalSource2[\"StyleDeclaration\"] = 13] = \"StyleDeclaration\";\n  IncrementalSource2[IncrementalSource2[\"Selection\"] = 14] = \"Selection\";\n  IncrementalSource2[IncrementalSource2[\"AdoptedStyleSheet\"] = 15] = \"AdoptedStyleSheet\";\n  IncrementalSource2[IncrementalSource2[\"CustomElement\"] = 16] = \"CustomElement\";\n  return IncrementalSource2;\n})(IncrementalSource || {});\n\nvar Config = {\n    DEBUG: false,\n    LIB_VERSION: '2.58.0'\n};\n\n// since es6 imports are static and we run unit tests from the console, window won't be defined when importing this file\nvar win;\nif (typeof(window) === 'undefined') {\n    var loc = {\n        hostname: ''\n    };\n    win = {\n        navigator: { userAgent: '', onLine: true },\n        document: {\n            location: loc,\n            referrer: ''\n        },\n        screen: { width: 0, height: 0 },\n        location: loc\n    };\n} else {\n    win = window;\n}\n\nvar setImmediate = win['setImmediate'];\nvar builtInProp, cycle, schedulingQueue,\n    ToString = Object.prototype.toString,\n    timer = (typeof setImmediate !== 'undefined') ?\n        function timer(fn) { return setImmediate(fn); } :\n        setTimeout;\n\n// dammit, IE8.\ntry {\n    Object.defineProperty({},'x',{});\n    builtInProp = function builtInProp(obj,name,val,config) {\n        return Object.defineProperty(obj,name,{\n            value: val,\n            writable: true,\n            configurable: config !== false\n        });\n    };\n}\ncatch (err) {\n    builtInProp = function builtInProp(obj,name,val) {\n        obj[name] = val;\n        return obj;\n    };\n}\n\n// Note: using a queue instead of array for efficiency\nschedulingQueue = (function Queue() {\n    var first, last, item;\n\n    function Item(fn,self) {\n        this.fn = fn;\n        this.self = self;\n        this.next = void 0;\n    }\n\n    return {\n        add: function add(fn,self) {\n            item = new Item(fn,self);\n            if (last) {\n                last.next = item;\n            }\n            else {\n                first = item;\n            }\n            last = item;\n            item = void 0;\n        },\n        drain: function drain() {\n            var f = first;\n            first = last = cycle = void 0;\n\n            while (f) {\n                f.fn.call(f.self);\n                f = f.next;\n            }\n        }\n    };\n})();\n\nfunction schedule(fn,self) {\n    schedulingQueue.add(fn,self);\n    if (!cycle) {\n        cycle = timer(schedulingQueue.drain);\n    }\n}\n\n// promise duck typing\nfunction isThenable(o) {\n    var _then, oType = typeof o;\n\n    if (o !== null && (oType === 'object' || oType === 'function')) {\n        _then = o.then;\n    }\n    return typeof _then === 'function' ? _then : false;\n}\n\nfunction notify() {\n    for (var i=0; i<this.chain.length; i++) {\n        notifyIsolated(\n            this,\n            (this.state === 1) ? this.chain[i].success : this.chain[i].failure,\n            this.chain[i]\n        );\n    }\n    this.chain.length = 0;\n}\n\n// NOTE: This is a separate function to isolate\n// the `try..catch` so that other code can be\n// optimized better\nfunction notifyIsolated(self,cb,chain) {\n    var ret, _then;\n    try {\n        if (cb === false) {\n            chain.reject(self.msg);\n        }\n        else {\n            if (cb === true) {\n                ret = self.msg;\n            }\n            else {\n                ret = cb.call(void 0,self.msg);\n            }\n\n            if (ret === chain.promise) {\n                chain.reject(TypeError('Promise-chain cycle'));\n            }\n            // eslint-disable-next-line no-cond-assign\n            else if (_then = isThenable(ret)) {\n                _then.call(ret,chain.resolve,chain.reject);\n            }\n            else {\n                chain.resolve(ret);\n            }\n        }\n    }\n    catch (err) {\n        chain.reject(err);\n    }\n}\n\nfunction resolve(msg) {\n    var _then, self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    try {\n        // eslint-disable-next-line no-cond-assign\n        if (_then = isThenable(msg)) {\n            schedule(function(){\n                var defWrapper = new MakeDefWrapper(self);\n                try {\n                    _then.call(msg,\n                        function $resolve$(){ resolve.apply(defWrapper,arguments); },\n                        function $reject$(){ reject.apply(defWrapper,arguments); }\n                    );\n                }\n                catch (err) {\n                    reject.call(defWrapper,err);\n                }\n            });\n        }\n        else {\n            self.msg = msg;\n            self.state = 1;\n            if (self.chain.length > 0) {\n                schedule(notify,self);\n            }\n        }\n    }\n    catch (err) {\n        reject.call(new MakeDefWrapper(self),err);\n    }\n}\n\nfunction reject(msg) {\n    var self = this;\n\n    // already triggered?\n    if (self.triggered) { return; }\n\n    self.triggered = true;\n\n    // unwrap\n    if (self.def) {\n        self = self.def;\n    }\n\n    self.msg = msg;\n    self.state = 2;\n    if (self.chain.length > 0) {\n        schedule(notify,self);\n    }\n}\n\nfunction iteratePromises(Constructor,arr,resolver,rejecter) {\n    for (var idx=0; idx<arr.length; idx++) {\n        (function IIFE(idx){\n            Constructor.resolve(arr[idx])\n                .then(\n                    function $resolver$(msg){\n                        resolver(idx,msg);\n                    },\n                    rejecter\n                );\n        })(idx);\n    }\n}\n\nfunction MakeDefWrapper(self) {\n    this.def = self;\n    this.triggered = false;\n}\n\nfunction MakeDef(self) {\n    this.promise = self;\n    this.state = 0;\n    this.triggered = false;\n    this.chain = [];\n    this.msg = void 0;\n}\n\nfunction NpoPromise(executor) {\n    if (typeof executor !== 'function') {\n        throw TypeError('Not a function');\n    }\n\n    if (this['__NPO__'] !== 0) {\n        throw TypeError('Not a promise');\n    }\n\n    // instance shadowing the inherited \"brand\"\n    // to signal an already \"initialized\" promise\n    this['__NPO__'] = 1;\n\n    var def = new MakeDef(this);\n\n    this['then'] = function then(success,failure) {\n        var o = {\n            success: typeof success === 'function' ? success : true,\n            failure: typeof failure === 'function' ? failure : false\n        };\n            // Note: `then(..)` itself can be borrowed to be used against\n            // a different promise constructor for making the chained promise,\n            // by substituting a different `this` binding.\n        o.promise = new this.constructor(function extractChain(resolve,reject) {\n            if (typeof resolve !== 'function' || typeof reject !== 'function') {\n                throw TypeError('Not a function');\n            }\n\n            o.resolve = resolve;\n            o.reject = reject;\n        });\n        def.chain.push(o);\n\n        if (def.state !== 0) {\n            schedule(notify,def);\n        }\n\n        return o.promise;\n    };\n    this['catch'] = function $catch$(failure) {\n        return this.then(void 0,failure);\n    };\n\n    try {\n        executor.call(\n            void 0,\n            function publicResolve(msg){\n                resolve.call(def,msg);\n            },\n            function publicReject(msg) {\n                reject.call(def,msg);\n            }\n        );\n    }\n    catch (err) {\n        reject.call(def,err);\n    }\n}\n\nvar PromisePrototype = builtInProp({},'constructor',NpoPromise,\n    /*configurable=*/false\n);\n\n    // Note: Android 4 cannot use `Object.defineProperty(..)` here\nNpoPromise.prototype = PromisePrototype;\n\n// built-in \"brand\" to signal an \"uninitialized\" promise\nbuiltInProp(PromisePrototype,'__NPO__',0,\n    /*configurable=*/false\n);\n\nbuiltInProp(NpoPromise,'resolve',function Promise$resolve(msg) {\n    var Constructor = this;\n\n    // spec mandated checks\n    // note: best \"isPromise\" check that's practical for now\n    if (msg && typeof msg === 'object' && msg['__NPO__'] === 1) {\n        return msg;\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        resolve(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'reject',function Promise$reject(msg) {\n    return new this(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        reject(msg);\n    });\n});\n\nbuiltInProp(NpoPromise,'all',function Promise$all(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n    if (arr.length === 0) {\n        return Constructor.resolve([]);\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        var len = arr.length, msgs = Array(len), count = 0;\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg) {\n            msgs[idx] = msg;\n            if (++count === len) {\n                resolve(msgs);\n            }\n        },reject);\n    });\n});\n\nbuiltInProp(NpoPromise,'race',function Promise$race(arr) {\n    var Constructor = this;\n\n    // spec mandated checks\n    if (ToString.call(arr) !== '[object Array]') {\n        return Constructor.reject(TypeError('Not an array'));\n    }\n\n    return new Constructor(function executor(resolve,reject){\n        if (typeof resolve !== 'function' || typeof reject !== 'function') {\n            throw TypeError('Not a function');\n        }\n\n        iteratePromises(Constructor,arr,function resolver(idx,msg){\n            resolve(msg);\n        },reject);\n    });\n});\n\nvar PromisePolyfill;\nif (typeof Promise !== 'undefined' && Promise.toString().indexOf('[native code]') !== -1) {\n    PromisePolyfill = Promise;\n} else {\n    PromisePolyfill = NpoPromise;\n}\n\n/* eslint camelcase: \"off\", eqeqeq: \"off\" */\n\n// Maximum allowed session recording length\nvar MAX_RECORDING_MS = 24 * 60 * 60 * 1000; // 24 hours\n// Maximum allowed value for minimum session recording length\nvar MAX_VALUE_FOR_MIN_RECORDING_MS = 8 * 1000; // 8 seconds\n\n/*\n * Saved references to long variable names, so that closure compiler can\n * minimize file size.\n */\n\nvar ArrayProto = Array.prototype,\n    FuncProto = Function.prototype,\n    ObjProto = Object.prototype,\n    slice = ArrayProto.slice,\n    toString = ObjProto.toString,\n    hasOwnProperty = ObjProto.hasOwnProperty,\n    windowConsole = win.console,\n    navigator = win.navigator,\n    document$1 = win.document,\n    windowOpera = win.opera,\n    screen = win.screen,\n    userAgent = navigator.userAgent;\n\nvar nativeBind = FuncProto.bind,\n    nativeForEach = ArrayProto.forEach,\n    nativeIndexOf = ArrayProto.indexOf,\n    nativeMap = ArrayProto.map,\n    nativeIsArray = Array.isArray,\n    breaker = {};\n\nvar _ = {\n    trim: function(str) {\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    }\n};\n\n// Console override\nvar console$1 = {\n    /** @type {function(...*)} */\n    log: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            try {\n                windowConsole.log.apply(windowConsole, arguments);\n            } catch (err) {\n                _.each(arguments, function(arg) {\n                    windowConsole.log(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    warn: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel warning:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.warn.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.warn(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    error: function() {\n        if (Config.DEBUG && !_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    },\n    /** @type {function(...*)} */\n    critical: function() {\n        if (!_.isUndefined(windowConsole) && windowConsole) {\n            var args = ['Mixpanel error:'].concat(_.toArray(arguments));\n            try {\n                windowConsole.error.apply(windowConsole, args);\n            } catch (err) {\n                _.each(args, function(arg) {\n                    windowConsole.error(arg);\n                });\n            }\n        }\n    }\n};\n\nvar log_func_with_prefix = function(func, prefix) {\n    return function() {\n        arguments[0] = '[' + prefix + '] ' + arguments[0];\n        return func.apply(console$1, arguments);\n    };\n};\nvar console_with_prefix = function(prefix) {\n    return {\n        log: log_func_with_prefix(console$1.log, prefix),\n        error: log_func_with_prefix(console$1.error, prefix),\n        critical: log_func_with_prefix(console$1.critical, prefix)\n    };\n};\n\n\n// UNDERSCORE\n// Embed part of the Underscore Library\n_.bind = function(func, context) {\n    var args, bound;\n    if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    if (!_.isFunction(func)) {\n        throw new TypeError();\n    }\n    args = slice.call(arguments, 2);\n    bound = function() {\n        if (!(this instanceof bound)) {\n            return func.apply(context, args.concat(slice.call(arguments)));\n        }\n        var ctor = {};\n        ctor.prototype = func.prototype;\n        var self = new ctor();\n        ctor.prototype = null;\n        var result = func.apply(self, args.concat(slice.call(arguments)));\n        if (Object(result) === result) {\n            return result;\n        }\n        return self;\n    };\n    return bound;\n};\n\n/**\n * @param {*=} obj\n * @param {function(...*)=} iterator\n * @param {Object=} context\n */\n_.each = function(obj, iterator, context) {\n    if (obj === null || obj === undefined) {\n        return;\n    }\n    if (nativeForEach && obj.forEach === nativeForEach) {\n        obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n        for (var i = 0, l = obj.length; i < l; i++) {\n            if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n                return;\n            }\n        }\n    } else {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                if (iterator.call(context, obj[key], key, obj) === breaker) {\n                    return;\n                }\n            }\n        }\n    }\n};\n\n_.extend = function(obj) {\n    _.each(slice.call(arguments, 1), function(source) {\n        for (var prop in source) {\n            if (source[prop] !== void 0) {\n                obj[prop] = source[prop];\n            }\n        }\n    });\n    return obj;\n};\n\n_.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n};\n\n// from a comment on http://dbj.org/dbj/?p=286\n// fails on only one very rare and deliberate custom object:\n// var bomb = { toString : undefined, valueOf: function(o) { return \"function BOMBA!\"; }};\n_.isFunction = function(f) {\n    try {\n        return /^\\s*\\bfunction\\b/.test(f);\n    } catch (x) {\n        return false;\n    }\n};\n\n_.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee'));\n};\n\n_.toArray = function(iterable) {\n    if (!iterable) {\n        return [];\n    }\n    if (iterable.toArray) {\n        return iterable.toArray();\n    }\n    if (_.isArray(iterable)) {\n        return slice.call(iterable);\n    }\n    if (_.isArguments(iterable)) {\n        return slice.call(iterable);\n    }\n    return _.values(iterable);\n};\n\n_.map = function(arr, callback, context) {\n    if (nativeMap && arr.map === nativeMap) {\n        return arr.map(callback, context);\n    } else {\n        var results = [];\n        _.each(arr, function(item) {\n            results.push(callback.call(context, item));\n        });\n        return results;\n    }\n};\n\n_.keys = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value, key) {\n        results[results.length] = key;\n    });\n    return results;\n};\n\n_.values = function(obj) {\n    var results = [];\n    if (obj === null) {\n        return results;\n    }\n    _.each(obj, function(value) {\n        results[results.length] = value;\n    });\n    return results;\n};\n\n_.include = function(obj, target) {\n    var found = false;\n    if (obj === null) {\n        return found;\n    }\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) {\n        return obj.indexOf(target) != -1;\n    }\n    _.each(obj, function(value) {\n        if (found || (found = (value === target))) {\n            return breaker;\n        }\n    });\n    return found;\n};\n\n_.includes = function(str, needle) {\n    return str.indexOf(needle) !== -1;\n};\n\n// Underscore Addons\n_.inherit = function(subclass, superclass) {\n    subclass.prototype = new superclass();\n    subclass.prototype.constructor = subclass;\n    subclass.superclass = superclass.prototype;\n    return subclass;\n};\n\n_.isObject = function(obj) {\n    return (obj === Object(obj) && !_.isArray(obj));\n};\n\n_.isEmptyObject = function(obj) {\n    if (_.isObject(obj)) {\n        for (var key in obj) {\n            if (hasOwnProperty.call(obj, key)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\n\n_.isUndefined = function(obj) {\n    return obj === void 0;\n};\n\n_.isString = function(obj) {\n    return toString.call(obj) == '[object String]';\n};\n\n_.isDate = function(obj) {\n    return toString.call(obj) == '[object Date]';\n};\n\n_.isNumber = function(obj) {\n    return toString.call(obj) == '[object Number]';\n};\n\n_.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n};\n\n_.encodeDates = function(obj) {\n    _.each(obj, function(v, k) {\n        if (_.isDate(v)) {\n            obj[k] = _.formatDate(v);\n        } else if (_.isObject(v)) {\n            obj[k] = _.encodeDates(v); // recurse\n        }\n    });\n    return obj;\n};\n\n_.timestamp = function() {\n    Date.now = Date.now || function() {\n        return +new Date;\n    };\n    return Date.now();\n};\n\n_.formatDate = function(d) {\n    // YYYY-MM-DDTHH:MM:SS in UTC\n    function pad(n) {\n        return n < 10 ? '0' + n : n;\n    }\n    return d.getUTCFullYear() + '-' +\n        pad(d.getUTCMonth() + 1) + '-' +\n        pad(d.getUTCDate()) + 'T' +\n        pad(d.getUTCHours()) + ':' +\n        pad(d.getUTCMinutes()) + ':' +\n        pad(d.getUTCSeconds());\n};\n\n_.strip_empty_properties = function(p) {\n    var ret = {};\n    _.each(p, function(v, k) {\n        if (_.isString(v) && v.length > 0) {\n            ret[k] = v;\n        }\n    });\n    return ret;\n};\n\n/*\n * this function returns a copy of object after truncating it.  If\n * passed an Array or Object it will iterate through obj and\n * truncate all the values recursively.\n */\n_.truncate = function(obj, length) {\n    var ret;\n\n    if (typeof(obj) === 'string') {\n        ret = obj.slice(0, length);\n    } else if (_.isArray(obj)) {\n        ret = [];\n        _.each(obj, function(val) {\n            ret.push(_.truncate(val, length));\n        });\n    } else if (_.isObject(obj)) {\n        ret = {};\n        _.each(obj, function(val, key) {\n            ret[key] = _.truncate(val, length);\n        });\n    } else {\n        ret = obj;\n    }\n\n    return ret;\n};\n\n_.JSONEncode = (function() {\n    return function(mixed_val) {\n        var value = mixed_val;\n        var quote = function(string) {\n            var escapable = /[\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g; // eslint-disable-line no-control-regex\n            var meta = { // table of character substitutions\n                '\\b': '\\\\b',\n                '\\t': '\\\\t',\n                '\\n': '\\\\n',\n                '\\f': '\\\\f',\n                '\\r': '\\\\r',\n                '\"': '\\\\\"',\n                '\\\\': '\\\\\\\\'\n            };\n\n            escapable.lastIndex = 0;\n            return escapable.test(string) ?\n                '\"' + string.replace(escapable, function(a) {\n                    var c = meta[a];\n                    return typeof c === 'string' ? c :\n                        '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n                }) + '\"' :\n                '\"' + string + '\"';\n        };\n\n        var str = function(key, holder) {\n            var gap = '';\n            var indent = '    ';\n            var i = 0; // The loop counter.\n            var k = ''; // The member key.\n            var v = ''; // The member value.\n            var length = 0;\n            var mind = gap;\n            var partial = [];\n            var value = holder[key];\n\n            // If the value has a toJSON method, call it to obtain a replacement value.\n            if (value && typeof value === 'object' &&\n                typeof value.toJSON === 'function') {\n                value = value.toJSON(key);\n            }\n\n            // What happens next depends on the value's type.\n            switch (typeof value) {\n                case 'string':\n                    return quote(value);\n\n                case 'number':\n                    // JSON numbers must be finite. Encode non-finite numbers as null.\n                    return isFinite(value) ? String(value) : 'null';\n\n                case 'boolean':\n                case 'null':\n                    // If the value is a boolean or null, convert it to a string. Note:\n                    // typeof null does not produce 'null'. The case is included here in\n                    // the remote chance that this gets fixed someday.\n\n                    return String(value);\n\n                case 'object':\n                    // If the type is 'object', we might be dealing with an object or an array or\n                    // null.\n                    // Due to a specification blunder in ECMAScript, typeof null is 'object',\n                    // so watch out for that case.\n                    if (!value) {\n                        return 'null';\n                    }\n\n                    // Make an array to hold the partial results of stringifying this object value.\n                    gap += indent;\n                    partial = [];\n\n                    // Is the value an array?\n                    if (toString.apply(value) === '[object Array]') {\n                        // The value is an array. Stringify every element. Use null as a placeholder\n                        // for non-JSON values.\n\n                        length = value.length;\n                        for (i = 0; i < length; i += 1) {\n                            partial[i] = str(i, value) || 'null';\n                        }\n\n                        // Join all of the elements together, separated with commas, and wrap them in\n                        // brackets.\n                        v = partial.length === 0 ? '[]' :\n                            gap ? '[\\n' + gap +\n                            partial.join(',\\n' + gap) + '\\n' +\n                            mind + ']' :\n                                '[' + partial.join(',') + ']';\n                        gap = mind;\n                        return v;\n                    }\n\n                    // Iterate through all of the keys in the object.\n                    for (k in value) {\n                        if (hasOwnProperty.call(value, k)) {\n                            v = str(k, value);\n                            if (v) {\n                                partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                            }\n                        }\n                    }\n\n                    // Join all of the member texts together, separated with commas,\n                    // and wrap them in braces.\n                    v = partial.length === 0 ? '{}' :\n                        gap ? '{' + partial.join(',') + '' +\n                        mind + '}' : '{' + partial.join(',') + '}';\n                    gap = mind;\n                    return v;\n            }\n        };\n\n        // Make a fake root object containing our value under the key of ''.\n        // Return the result of stringifying the value.\n        return str('', {\n            '': value\n        });\n    };\n})();\n\n/**\n * From https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js\n * Slightly modified to throw a real Error rather than a POJO\n */\n_.JSONDecode = (function() {\n    var at, // The index of the current character\n        ch, // The current character\n        escapee = {\n            '\"': '\"',\n            '\\\\': '\\\\',\n            '/': '/',\n            'b': '\\b',\n            'f': '\\f',\n            'n': '\\n',\n            'r': '\\r',\n            't': '\\t'\n        },\n        text,\n        error = function(m) {\n            var e = new SyntaxError(m);\n            e.at = at;\n            e.text = text;\n            throw e;\n        },\n        next = function(c) {\n            // If a c parameter is provided, verify that it matches the current character.\n            if (c && c !== ch) {\n                error('Expected \\'' + c + '\\' instead of \\'' + ch + '\\'');\n            }\n            // Get the next character. When there are no more characters,\n            // return the empty string.\n            ch = text.charAt(at);\n            at += 1;\n            return ch;\n        },\n        number = function() {\n            // Parse a number value.\n            var number,\n                string = '';\n\n            if (ch === '-') {\n                string = '-';\n                next('-');\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n            if (ch === '.') {\n                string += '.';\n                while (next() && ch >= '0' && ch <= '9') {\n                    string += ch;\n                }\n            }\n            if (ch === 'e' || ch === 'E') {\n                string += ch;\n                next();\n                if (ch === '-' || ch === '+') {\n                    string += ch;\n                    next();\n                }\n                while (ch >= '0' && ch <= '9') {\n                    string += ch;\n                    next();\n                }\n            }\n            number = +string;\n            if (!isFinite(number)) {\n                error('Bad number');\n            } else {\n                return number;\n            }\n        },\n\n        string = function() {\n            // Parse a string value.\n            var hex,\n                i,\n                string = '',\n                uffff;\n            // When parsing for string values, we must look for \" and \\ characters.\n            if (ch === '\"') {\n                while (next()) {\n                    if (ch === '\"') {\n                        next();\n                        return string;\n                    }\n                    if (ch === '\\\\') {\n                        next();\n                        if (ch === 'u') {\n                            uffff = 0;\n                            for (i = 0; i < 4; i += 1) {\n                                hex = parseInt(next(), 16);\n                                if (!isFinite(hex)) {\n                                    break;\n                                }\n                                uffff = uffff * 16 + hex;\n                            }\n                            string += String.fromCharCode(uffff);\n                        } else if (typeof escapee[ch] === 'string') {\n                            string += escapee[ch];\n                        } else {\n                            break;\n                        }\n                    } else {\n                        string += ch;\n                    }\n                }\n            }\n            error('Bad string');\n        },\n        white = function() {\n            // Skip whitespace.\n            while (ch && ch <= ' ') {\n                next();\n            }\n        },\n        word = function() {\n            // true, false, or null.\n            switch (ch) {\n                case 't':\n                    next('t');\n                    next('r');\n                    next('u');\n                    next('e');\n                    return true;\n                case 'f':\n                    next('f');\n                    next('a');\n                    next('l');\n                    next('s');\n                    next('e');\n                    return false;\n                case 'n':\n                    next('n');\n                    next('u');\n                    next('l');\n                    next('l');\n                    return null;\n            }\n            error('Unexpected \"' + ch + '\"');\n        },\n        value, // Placeholder for the value function.\n        array = function() {\n            // Parse an array value.\n            var array = [];\n\n            if (ch === '[') {\n                next('[');\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array; // empty array\n                }\n                while (ch) {\n                    array.push(value());\n                    white();\n                    if (ch === ']') {\n                        next(']');\n                        return array;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad array');\n        },\n        object = function() {\n            // Parse an object value.\n            var key,\n                object = {};\n\n            if (ch === '{') {\n                next('{');\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object; // empty object\n                }\n                while (ch) {\n                    key = string();\n                    white();\n                    next(':');\n                    if (Object.hasOwnProperty.call(object, key)) {\n                        error('Duplicate key \"' + key + '\"');\n                    }\n                    object[key] = value();\n                    white();\n                    if (ch === '}') {\n                        next('}');\n                        return object;\n                    }\n                    next(',');\n                    white();\n                }\n            }\n            error('Bad object');\n        };\n\n    value = function() {\n        // Parse a JSON value. It could be an object, an array, a string,\n        // a number, or a word.\n        white();\n        switch (ch) {\n            case '{':\n                return object();\n            case '[':\n                return array();\n            case '\"':\n                return string();\n            case '-':\n                return number();\n            default:\n                return ch >= '0' && ch <= '9' ? number() : word();\n        }\n    };\n\n    // Return the json_parse function. It will have access to all of the\n    // above functions and variables.\n    return function(source) {\n        var result;\n\n        text = source;\n        at = 0;\n        ch = ' ';\n        result = value();\n        white();\n        if (ch) {\n            error('Syntax error');\n        }\n\n        return result;\n    };\n})();\n\n_.base64Encode = function(data) {\n    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,\n        ac = 0,\n        enc = '',\n        tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    data = _.utf8Encode(data);\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1 << 16 | o2 << 8 | o3;\n\n        h1 = bits >> 18 & 0x3f;\n        h2 = bits >> 12 & 0x3f;\n        h3 = bits >> 6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n            break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n            break;\n    }\n\n    return enc;\n};\n\n_.utf8Encode = function(string) {\n    string = (string + '').replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n\n    var utftext = '',\n        start,\n        end;\n    var stringl = 0,\n        n;\n\n    start = end = 0;\n    stringl = string.length;\n\n    for (n = 0; n < stringl; n++) {\n        var c1 = string.charCodeAt(n);\n        var enc = null;\n\n        if (c1 < 128) {\n            end++;\n        } else if ((c1 > 127) && (c1 < 2048)) {\n            enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128);\n        } else {\n            enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128);\n        }\n        if (enc !== null) {\n            if (end > start) {\n                utftext += string.substring(start, end);\n            }\n            utftext += enc;\n            start = end = n + 1;\n        }\n    }\n\n    if (end > start) {\n        utftext += string.substring(start, string.length);\n    }\n\n    return utftext;\n};\n\n_.UUID = (function() {\n\n    // Time-based entropy\n    var T = function() {\n        var time = 1 * new Date(); // cross-browser version of Date.now()\n        var ticks;\n        if (win.performance && win.performance.now) {\n            ticks = win.performance.now();\n        } else {\n            // fall back to busy loop\n            ticks = 0;\n\n            // this while loop figures how many browser ticks go by\n            // before 1*new Date() returns a new number, ie the amount\n            // of ticks that go by per millisecond\n            while (time == 1 * new Date()) {\n                ticks++;\n            }\n        }\n        return time.toString(16) + Math.floor(ticks).toString(16);\n    };\n\n    // Math.Random entropy\n    var R = function() {\n        return Math.random().toString(16).replace('.', '');\n    };\n\n    // User agent entropy\n    // This function takes the user agent string, and then xors\n    // together each sequence of 8 bytes.  This produces a final\n    // sequence of 8 bytes which it returns as hex.\n    var UA = function() {\n        var ua = userAgent,\n            i, ch, buffer = [],\n            ret = 0;\n\n        function xor(result, byte_array) {\n            var j, tmp = 0;\n            for (j = 0; j < byte_array.length; j++) {\n                tmp |= (buffer[j] << j * 8);\n            }\n            return result ^ tmp;\n        }\n\n        for (i = 0; i < ua.length; i++) {\n            ch = ua.charCodeAt(i);\n            buffer.unshift(ch & 0xFF);\n            if (buffer.length >= 4) {\n                ret = xor(ret, buffer);\n                buffer = [];\n            }\n        }\n\n        if (buffer.length > 0) {\n            ret = xor(ret, buffer);\n        }\n\n        return ret.toString(16);\n    };\n\n    return function() {\n        var se = (screen.height * screen.width).toString(16);\n        return (T() + '-' + R() + '-' + UA() + '-' + se + '-' + T());\n    };\n})();\n\n// _.isBlockedUA()\n// This is to block various web spiders from executing our JS and\n// sending false tracking data\nvar BLOCKED_UA_STRS = [\n    'ahrefsbot',\n    'ahrefssiteaudit',\n    'baiduspider',\n    'bingbot',\n    'bingpreview',\n    'chrome-lighthouse',\n    'facebookexternal',\n    'petalbot',\n    'pinterest',\n    'screaming frog',\n    'yahoo! slurp',\n    'yandexbot',\n\n    // a whole bunch of goog-specific crawlers\n    // https://developers.google.com/search/docs/advanced/crawling/overview-google-crawlers\n    'adsbot-google',\n    'apis-google',\n    'duplexweb-google',\n    'feedfetcher-google',\n    'google favicon',\n    'google web preview',\n    'google-read-aloud',\n    'googlebot',\n    'googleweblight',\n    'mediapartners-google',\n    'storebot-google'\n];\n_.isBlockedUA = function(ua) {\n    var i;\n    ua = ua.toLowerCase();\n    for (i = 0; i < BLOCKED_UA_STRS.length; i++) {\n        if (ua.indexOf(BLOCKED_UA_STRS[i]) !== -1) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * @param {Object=} formdata\n * @param {string=} arg_separator\n */\n_.HTTPBuildQuery = function(formdata, arg_separator) {\n    var use_val, use_key, tmp_arr = [];\n\n    if (_.isUndefined(arg_separator)) {\n        arg_separator = '&';\n    }\n\n    _.each(formdata, function(val, key) {\n        use_val = encodeURIComponent(val.toString());\n        use_key = encodeURIComponent(key);\n        tmp_arr[tmp_arr.length] = use_key + '=' + use_val;\n    });\n\n    return tmp_arr.join(arg_separator);\n};\n\n_.getQueryParam = function(url, param) {\n    // Expects a raw URL\n\n    param = param.replace(/[[]/g, '\\\\[').replace(/[\\]]/g, '\\\\]');\n    var regexS = '[\\\\?&]' + param + '=([^&#]*)',\n        regex = new RegExp(regexS),\n        results = regex.exec(url);\n    if (results === null || (results && typeof(results[1]) !== 'string' && results[1].length)) {\n        return '';\n    } else {\n        var result = results[1];\n        try {\n            result = decodeURIComponent(result);\n        } catch(err) {\n            console$1.error('Skipping decoding for malformed query param: ' + result);\n        }\n        return result.replace(/\\+/g, ' ');\n    }\n};\n\n\n// _.cookie\n// Methods partially borrowed from quirksmode.org/js/cookies.html\n_.cookie = {\n    get: function(name) {\n        var nameEQ = name + '=';\n        var ca = document$1.cookie.split(';');\n        for (var i = 0; i < ca.length; i++) {\n            var c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        var cookie;\n        try {\n            cookie = _.JSONDecode(_.cookie.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return cookie;\n    },\n\n    set_seconds: function(name, value, seconds, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '',\n            expires = '',\n            secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (seconds) {\n            var date = new Date();\n            date.setTime(date.getTime() + (seconds * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        document$1.cookie = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n    },\n\n    set: function(name, value, days, is_cross_subdomain, is_secure, is_cross_site, domain_override) {\n        var cdomain = '', expires = '', secure = '';\n\n        if (domain_override) {\n            cdomain = '; domain=' + domain_override;\n        } else if (is_cross_subdomain) {\n            var domain = extract_domain(document$1.location.hostname);\n            cdomain = domain ? '; domain=.' + domain : '';\n        }\n\n        if (days) {\n            var date = new Date();\n            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));\n            expires = '; expires=' + date.toGMTString();\n        }\n\n        if (is_cross_site) {\n            is_secure = true;\n            secure = '; SameSite=None';\n        }\n        if (is_secure) {\n            secure += '; secure';\n        }\n\n        var new_cookie_val = name + '=' + encodeURIComponent(value) + expires + '; path=/' + cdomain + secure;\n        document$1.cookie = new_cookie_val;\n        return new_cookie_val;\n    },\n\n    remove: function(name, is_cross_subdomain, domain_override) {\n        _.cookie.set(name, '', -1, is_cross_subdomain, false, false, domain_override);\n    }\n};\n\nvar _localStorageSupported = null;\nvar localStorageSupported = function(storage, forceCheck) {\n    if (_localStorageSupported !== null && !forceCheck) {\n        return _localStorageSupported;\n    }\n\n    var supported = true;\n    try {\n        storage = storage || win.localStorage;\n        var key = '__mplss_' + cheap_guid(8),\n            val = 'xyz';\n        storage.setItem(key, val);\n        if (storage.getItem(key) !== val) {\n            supported = false;\n        }\n        storage.removeItem(key);\n    } catch (err) {\n        supported = false;\n    }\n\n    _localStorageSupported = supported;\n    return supported;\n};\n\n// _.localStorage\n_.localStorage = {\n    is_supported: function(force_check) {\n        var supported = localStorageSupported(null, force_check);\n        if (!supported) {\n            console$1.error('localStorage unsupported; falling back to cookie store');\n        }\n        return supported;\n    },\n\n    error: function(msg) {\n        console$1.error('localStorage error: ' + msg);\n    },\n\n    get: function(name) {\n        try {\n            return win.localStorage.getItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n        return null;\n    },\n\n    parse: function(name) {\n        try {\n            return _.JSONDecode(_.localStorage.get(name)) || {};\n        } catch (err) {\n            // noop\n        }\n        return null;\n    },\n\n    set: function(name, value) {\n        try {\n            win.localStorage.setItem(name, value);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    },\n\n    remove: function(name) {\n        try {\n            win.localStorage.removeItem(name);\n        } catch (err) {\n            _.localStorage.error(err);\n        }\n    }\n};\n\n_.register_event = (function() {\n    // written by Dean Edwards, 2005\n    // with input from Tino Zijdel - crisp@xs4all.nl\n    // with input from Carl Sverre - mail@carlsverre.com\n    // with input from Mixpanel\n    // http://dean.edwards.name/weblog/2005/10/add-event/\n    // https://gist.github.com/1930440\n\n    /**\n     * @param {Object} element\n     * @param {string} type\n     * @param {function(...*)} handler\n     * @param {boolean=} oldSchool\n     * @param {boolean=} useCapture\n     */\n    var register_event = function(element, type, handler, oldSchool, useCapture) {\n        if (!element) {\n            console$1.error('No valid element provided to register_event');\n            return;\n        }\n\n        if (element.addEventListener && !oldSchool) {\n            element.addEventListener(type, handler, !!useCapture);\n        } else {\n            var ontype = 'on' + type;\n            var old_handler = element[ontype]; // can be undefined\n            element[ontype] = makeHandler(element, handler, old_handler);\n        }\n    };\n\n    function makeHandler(element, new_handler, old_handlers) {\n        var handler = function(event) {\n            event = event || fixEvent(win.event);\n\n            // this basically happens in firefox whenever another script\n            // overwrites the onload callback and doesn't pass the event\n            // object to previously defined callbacks.  All the browsers\n            // that don't define window.event implement addEventListener\n            // so the dom_loaded handler will still be fired as usual.\n            if (!event) {\n                return undefined;\n            }\n\n            var ret = true;\n            var old_result, new_result;\n\n            if (_.isFunction(old_handlers)) {\n                old_result = old_handlers(event);\n            }\n            new_result = new_handler.call(element, event);\n\n            if ((false === old_result) || (false === new_result)) {\n                ret = false;\n            }\n\n            return ret;\n        };\n\n        return handler;\n    }\n\n    function fixEvent(event) {\n        if (event) {\n            event.preventDefault = fixEvent.preventDefault;\n            event.stopPropagation = fixEvent.stopPropagation;\n        }\n        return event;\n    }\n    fixEvent.preventDefault = function() {\n        this.returnValue = false;\n    };\n    fixEvent.stopPropagation = function() {\n        this.cancelBubble = true;\n    };\n\n    return register_event;\n})();\n\n\nvar TOKEN_MATCH_REGEX = new RegExp('^(\\\\w*)\\\\[(\\\\w+)([=~\\\\|\\\\^\\\\$\\\\*]?)=?\"?([^\\\\]\"]*)\"?\\\\]$');\n\n_.dom_query = (function() {\n    /* document.getElementsBySelector(selector)\n    - returns an array of element objects from the current document\n    matching the CSS selector. Selectors can contain element names,\n    class names and ids and can be nested. For example:\n\n    elements = document.getElementsBySelector('div#main p a.external')\n\n    Will return an array of all 'a' elements with 'external' in their\n    class attribute that are contained inside 'p' elements that are\n    contained inside the 'div' element which has id=\"main\"\n\n    New in version 0.4: Support for CSS2 and CSS3 attribute selectors:\n    See http://www.w3.org/TR/css3-selectors/#attribute-selectors\n\n    Version 0.4 - Simon Willison, March 25th 2003\n    -- Works in Phoenix 0.5, Mozilla 1.3, Opera 7, Internet Explorer 6, Internet Explorer 5 on Windows\n    -- Opera 7 fails\n\n    Version 0.5 - Carl Sverre, Jan 7th 2013\n    -- Now uses jQuery-esque `hasClass` for testing class name\n    equality.  This fixes a bug related to '-' characters being\n    considered not part of a 'word' in regex.\n    */\n\n    function getAllChildren(e) {\n        // Returns all children of element. Workaround required for IE5/Windows. Ugh.\n        return e.all ? e.all : e.getElementsByTagName('*');\n    }\n\n    var bad_whitespace = /[\\t\\r\\n]/g;\n\n    function hasClass(elem, selector) {\n        var className = ' ' + selector + ' ';\n        return ((' ' + elem.className + ' ').replace(bad_whitespace, ' ').indexOf(className) >= 0);\n    }\n\n    function getElementsBySelector(selector) {\n        // Attempt to fail gracefully in lesser browsers\n        if (!document$1.getElementsByTagName) {\n            return [];\n        }\n        // Split selector in to tokens\n        var tokens = selector.split(' ');\n        var token, bits, tagName, found, foundCount, i, j, k, elements, currentContextIndex;\n        var currentContext = [document$1];\n        for (i = 0; i < tokens.length; i++) {\n            token = tokens[i].replace(/^\\s+/, '').replace(/\\s+$/, '');\n            if (token.indexOf('#') > -1) {\n                // Token is an ID selector\n                bits = token.split('#');\n                tagName = bits[0];\n                var id = bits[1];\n                var element = document$1.getElementById(id);\n                if (!element || (tagName && element.nodeName.toLowerCase() != tagName)) {\n                    // element not found or tag with that ID not found, return false\n                    return [];\n                }\n                // Set currentContext to contain just this element\n                currentContext = [element];\n                continue; // Skip to next token\n            }\n            if (token.indexOf('.') > -1) {\n                // Token contains a class selector\n                bits = token.split('.');\n                tagName = bits[0];\n                var className = bits[1];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Get elements matching tag, filter them for class selector\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (found[j].className &&\n                        _.isString(found[j].className) && // some SVG elements have classNames which are not strings\n                        hasClass(found[j], className)\n                    ) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                continue; // Skip to next token\n            }\n            // Code to deal with attribute selectors\n            var token_match = token.match(TOKEN_MATCH_REGEX);\n            if (token_match) {\n                tagName = token_match[1];\n                var attrName = token_match[2];\n                var attrOperator = token_match[3];\n                var attrValue = token_match[4];\n                if (!tagName) {\n                    tagName = '*';\n                }\n                // Grab all of the tagName elements within current context\n                found = [];\n                foundCount = 0;\n                for (j = 0; j < currentContext.length; j++) {\n                    if (tagName == '*') {\n                        elements = getAllChildren(currentContext[j]);\n                    } else {\n                        elements = currentContext[j].getElementsByTagName(tagName);\n                    }\n                    for (k = 0; k < elements.length; k++) {\n                        found[foundCount++] = elements[k];\n                    }\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                var checkFunction; // This function will be used to filter the elements\n                switch (attrOperator) {\n                    case '=': // Equality\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName) == attrValue);\n                        };\n                        break;\n                    case '~': // Match one of space seperated words\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('\\\\b' + attrValue + '\\\\b')));\n                        };\n                        break;\n                    case '|': // Match start with value followed by optional hyphen\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).match(new RegExp('^' + attrValue + '-?')));\n                        };\n                        break;\n                    case '^': // Match starts with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) === 0);\n                        };\n                        break;\n                    case '$': // Match ends with value - fails with \"Warning\" in Opera 7\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).lastIndexOf(attrValue) == e.getAttribute(attrName).length - attrValue.length);\n                        };\n                        break;\n                    case '*': // Match ends with value\n                        checkFunction = function(e) {\n                            return (e.getAttribute(attrName).indexOf(attrValue) > -1);\n                        };\n                        break;\n                    default:\n                        // Just test for existence of attribute\n                        checkFunction = function(e) {\n                            return e.getAttribute(attrName);\n                        };\n                }\n                currentContext = [];\n                currentContextIndex = 0;\n                for (j = 0; j < found.length; j++) {\n                    if (checkFunction(found[j])) {\n                        currentContext[currentContextIndex++] = found[j];\n                    }\n                }\n                // alert('Attribute Selector: '+tagName+' '+attrName+' '+attrOperator+' '+attrValue);\n                continue; // Skip to next token\n            }\n            // If we get here, token is JUST an element (not a class or ID selector)\n            tagName = token;\n            found = [];\n            foundCount = 0;\n            for (j = 0; j < currentContext.length; j++) {\n                elements = currentContext[j].getElementsByTagName(tagName);\n                for (k = 0; k < elements.length; k++) {\n                    found[foundCount++] = elements[k];\n                }\n            }\n            currentContext = found;\n        }\n        return currentContext;\n    }\n\n    return function(query) {\n        if (_.isElement(query)) {\n            return [query];\n        } else if (_.isObject(query) && !_.isUndefined(query.length)) {\n            return query;\n        } else {\n            return getElementsBySelector.call(this, query);\n        }\n    };\n})();\n\nvar CAMPAIGN_KEYWORDS = ['utm_source', 'utm_medium', 'utm_campaign', 'utm_content', 'utm_term', 'utm_id', 'utm_source_platform','utm_campaign_id', 'utm_creative_format', 'utm_marketing_tactic'];\nvar CLICK_IDS = ['dclid', 'fbclid', 'gclid', 'ko_click_id', 'li_fat_id', 'msclkid', 'sccid', 'ttclid', 'twclid', 'wbraid'];\n\n_.info = {\n    campaignParams: function(default_value) {\n        var kw = '',\n            params = {};\n        _.each(CAMPAIGN_KEYWORDS, function(kwkey) {\n            kw = _.getQueryParam(document$1.URL, kwkey);\n            if (kw.length) {\n                params[kwkey] = kw;\n            } else if (default_value !== undefined) {\n                params[kwkey] = default_value;\n            }\n        });\n\n        return params;\n    },\n\n    clickParams: function() {\n        var id = '',\n            params = {};\n        _.each(CLICK_IDS, function(idkey) {\n            id = _.getQueryParam(document$1.URL, idkey);\n            if (id.length) {\n                params[idkey] = id;\n            }\n        });\n\n        return params;\n    },\n\n    marketingParams: function() {\n        return _.extend(_.info.campaignParams(), _.info.clickParams());\n    },\n\n    searchEngine: function(referrer) {\n        if (referrer.search('https?://(.*)google.([^/?]*)') === 0) {\n            return 'google';\n        } else if (referrer.search('https?://(.*)bing.com') === 0) {\n            return 'bing';\n        } else if (referrer.search('https?://(.*)yahoo.com') === 0) {\n            return 'yahoo';\n        } else if (referrer.search('https?://(.*)duckduckgo.com') === 0) {\n            return 'duckduckgo';\n        } else {\n            return null;\n        }\n    },\n\n    searchInfo: function(referrer) {\n        var search = _.info.searchEngine(referrer),\n            param = (search != 'yahoo') ? 'q' : 'p',\n            ret = {};\n\n        if (search !== null) {\n            ret['$search_engine'] = search;\n\n            var keyword = _.getQueryParam(referrer, param);\n            if (keyword.length) {\n                ret['mp_keyword'] = keyword;\n            }\n        }\n\n        return ret;\n    },\n\n    /**\n     * This function detects which browser is running this script.\n     * The order of the checks are important since many user agents\n     * include key words used in later checks.\n     */\n    browser: function(user_agent, vendor, opera) {\n        vendor = vendor || ''; // vendor is undefined for at least IE9\n        if (opera || _.includes(user_agent, ' OPR/')) {\n            if (_.includes(user_agent, 'Mini')) {\n                return 'Opera Mini';\n            }\n            return 'Opera';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (_.includes(user_agent, 'IEMobile') || _.includes(user_agent, 'WPDesktop')) {\n            return 'Internet Explorer Mobile';\n        } else if (_.includes(user_agent, 'SamsungBrowser/')) {\n            // https://developer.samsung.com/internet/user-agent-string-format\n            return 'Samsung Internet';\n        } else if (_.includes(user_agent, 'Edge') || _.includes(user_agent, 'Edg/')) {\n            return 'Microsoft Edge';\n        } else if (_.includes(user_agent, 'FBIOS')) {\n            return 'Facebook Mobile';\n        } else if (_.includes(user_agent, 'Chrome')) {\n            return 'Chrome';\n        } else if (_.includes(user_agent, 'CriOS')) {\n            return 'Chrome iOS';\n        } else if (_.includes(user_agent, 'UCWEB') || _.includes(user_agent, 'UCBrowser')) {\n            return 'UC Browser';\n        } else if (_.includes(user_agent, 'FxiOS')) {\n            return 'Firefox iOS';\n        } else if (_.includes(vendor, 'Apple')) {\n            if (_.includes(user_agent, 'Mobile')) {\n                return 'Mobile Safari';\n            }\n            return 'Safari';\n        } else if (_.includes(user_agent, 'Android')) {\n            return 'Android Mobile';\n        } else if (_.includes(user_agent, 'Konqueror')) {\n            return 'Konqueror';\n        } else if (_.includes(user_agent, 'Firefox')) {\n            return 'Firefox';\n        } else if (_.includes(user_agent, 'MSIE') || _.includes(user_agent, 'Trident/')) {\n            return 'Internet Explorer';\n        } else if (_.includes(user_agent, 'Gecko')) {\n            return 'Mozilla';\n        } else {\n            return '';\n        }\n    },\n\n    /**\n     * This function detects which browser version is running this script,\n     * parsing major and minor version (e.g., 42.1). User agent strings from:\n     * http://www.useragentstring.com/pages/useragentstring.php\n     */\n    browserVersion: function(userAgent, vendor, opera) {\n        var browser = _.info.browser(userAgent, vendor, opera);\n        var versionRegexs = {\n            'Internet Explorer Mobile': /rv:(\\d+(\\.\\d+)?)/,\n            'Microsoft Edge': /Edge?\\/(\\d+(\\.\\d+)?)/,\n            'Chrome': /Chrome\\/(\\d+(\\.\\d+)?)/,\n            'Chrome iOS': /CriOS\\/(\\d+(\\.\\d+)?)/,\n            'UC Browser' : /(UCBrowser|UCWEB)\\/(\\d+(\\.\\d+)?)/,\n            'Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Mobile Safari': /Version\\/(\\d+(\\.\\d+)?)/,\n            'Opera': /(Opera|OPR)\\/(\\d+(\\.\\d+)?)/,\n            'Firefox': /Firefox\\/(\\d+(\\.\\d+)?)/,\n            'Firefox iOS': /FxiOS\\/(\\d+(\\.\\d+)?)/,\n            'Konqueror': /Konqueror:(\\d+(\\.\\d+)?)/,\n            'BlackBerry': /BlackBerry (\\d+(\\.\\d+)?)/,\n            'Android Mobile': /android\\s(\\d+(\\.\\d+)?)/,\n            'Samsung Internet': /SamsungBrowser\\/(\\d+(\\.\\d+)?)/,\n            'Internet Explorer': /(rv:|MSIE )(\\d+(\\.\\d+)?)/,\n            'Mozilla': /rv:(\\d+(\\.\\d+)?)/\n        };\n        var regex = versionRegexs[browser];\n        if (regex === undefined) {\n            return null;\n        }\n        var matches = userAgent.match(regex);\n        if (!matches) {\n            return null;\n        }\n        return parseFloat(matches[matches.length - 2]);\n    },\n\n    os: function() {\n        var a = userAgent;\n        if (/Windows/i.test(a)) {\n            if (/Phone/.test(a) || /WPDesktop/.test(a)) {\n                return 'Windows Phone';\n            }\n            return 'Windows';\n        } else if (/(iPhone|iPad|iPod)/.test(a)) {\n            return 'iOS';\n        } else if (/Android/.test(a)) {\n            return 'Android';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {\n            return 'BlackBerry';\n        } else if (/Mac/i.test(a)) {\n            return 'Mac OS X';\n        } else if (/Linux/.test(a)) {\n            return 'Linux';\n        } else if (/CrOS/.test(a)) {\n            return 'Chrome OS';\n        } else {\n            return '';\n        }\n    },\n\n    device: function(user_agent) {\n        if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {\n            return 'Windows Phone';\n        } else if (/iPad/.test(user_agent)) {\n            return 'iPad';\n        } else if (/iPod/.test(user_agent)) {\n            return 'iPod Touch';\n        } else if (/iPhone/.test(user_agent)) {\n            return 'iPhone';\n        } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {\n            return 'BlackBerry';\n        } else if (/Android/.test(user_agent)) {\n            return 'Android';\n        } else {\n            return '';\n        }\n    },\n\n    referringDomain: function(referrer) {\n        var split = referrer.split('/');\n        if (split.length >= 3) {\n            return split[2];\n        }\n        return '';\n    },\n\n    currentUrl: function() {\n        return win.location.href;\n    },\n\n    properties: function(extra_props) {\n        if (typeof extra_props !== 'object') {\n            extra_props = {};\n        }\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera),\n            '$referrer': document$1.referrer,\n            '$referring_domain': _.info.referringDomain(document$1.referrer),\n            '$device': _.info.device(userAgent)\n        }), {\n            '$current_url': _.info.currentUrl(),\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera),\n            '$screen_height': screen.height,\n            '$screen_width': screen.width,\n            'mp_lib': 'web',\n            '$lib_version': Config.LIB_VERSION,\n            '$insert_id': cheap_guid(),\n            'time': _.timestamp() / 1000 // epoch time in seconds\n        }, _.strip_empty_properties(extra_props));\n    },\n\n    people_properties: function() {\n        return _.extend(_.strip_empty_properties({\n            '$os': _.info.os(),\n            '$browser': _.info.browser(userAgent, navigator.vendor, windowOpera)\n        }), {\n            '$browser_version': _.info.browserVersion(userAgent, navigator.vendor, windowOpera)\n        });\n    },\n\n    mpPageViewProperties: function() {\n        return _.strip_empty_properties({\n            'current_page_title': document$1.title,\n            'current_domain': win.location.hostname,\n            'current_url_path': win.location.pathname,\n            'current_url_protocol': win.location.protocol,\n            'current_url_search': win.location.search\n        });\n    }\n};\n\nvar cheap_guid = function(maxlen) {\n    var guid = Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10);\n    return maxlen ? guid.substring(0, maxlen) : guid;\n};\n\n// naive way to extract domain name (example.com) from full hostname (my.sub.example.com)\nvar SIMPLE_DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]*\\.[a-z]+$/i;\n// this next one attempts to account for some ccSLDs, e.g. extracting oxford.ac.uk from www.oxford.ac.uk\nvar DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\\.[a-z.]{2,6}$/i;\n/**\n * Attempts to extract main domain name from full hostname, using a few blunt heuristics. For\n * common TLDs like .com/.org that always have a simple SLD.TLD structure (example.com), we\n * simply extract the last two .-separated parts of the hostname (SIMPLE_DOMAIN_MATCH_REGEX).\n * For others, we attempt to account for short ccSLD+TLD combos (.ac.uk) with the legacy\n * DOMAIN_MATCH_REGEX (kept to maintain backwards compatibility with existing Mixpanel\n * integrations). The only _reliable_ way to extract domain from hostname is with an up-to-date\n * list like at https://publicsuffix.org/ so for cases that this helper fails at, the SDK\n * offers the 'cookie_domain' config option to set it explicitly.\n * @example\n * extract_domain('my.sub.example.com')\n * // 'example.com'\n */\nvar extract_domain = function(hostname) {\n    var domain_regex = DOMAIN_MATCH_REGEX;\n    var parts = hostname.split('.');\n    var tld = parts[parts.length - 1];\n    if (tld.length > 4 || tld === 'com' || tld === 'org') {\n        domain_regex = SIMPLE_DOMAIN_MATCH_REGEX;\n    }\n    var matches = hostname.match(domain_regex);\n    return matches ? matches[0] : '';\n};\n\n/**\n * Check whether we have network connection. default to true for browsers that don't support navigator.onLine (IE)\n * @returns {boolean}\n */\nvar isOnline = function() {\n    var onLine = win.navigator['onLine'];\n    return _.isUndefined(onLine) || onLine;\n};\n\nvar JSONStringify = null, JSONParse = null;\nif (typeof JSON !== 'undefined') {\n    JSONStringify = JSON.stringify;\n    JSONParse = JSON.parse;\n}\nJSONStringify = JSONStringify || _.JSONEncode;\nJSONParse = JSONParse || _.JSONDecode;\n\n// EXPORTS (for closure compiler)\n_['toArray']                = _.toArray;\n_['isObject']               = _.isObject;\n_['JSONEncode']             = _.JSONEncode;\n_['JSONDecode']             = _.JSONDecode;\n_['isBlockedUA']            = _.isBlockedUA;\n_['isEmptyObject']          = _.isEmptyObject;\n_['info']                   = _.info;\n_['info']['device']         = _.info.device;\n_['info']['browser']        = _.info.browser;\n_['info']['browserVersion'] = _.info.browserVersion;\n_['info']['properties']     = _.info.properties;\n_['NPO']                    = NpoPromise;\n\n/**\n * GDPR utils\n *\n * The General Data Protection Regulation (GDPR) is a regulation in EU law on data protection\n * and privacy for all individuals within the European Union. It addresses the export of personal\n * data outside the EU. The GDPR aims primarily to give control back to citizens and residents\n * over their personal data and to simplify the regulatory environment for international business\n * by unifying the regulation within the EU.\n *\n * This set of utilities is intended to enable opt in/out functionality in the Mixpanel JS SDK.\n * These functions are used internally by the SDK and are not intended to be publicly exposed.\n */\n\n/**\n * A function used to track a Mixpanel event (e.g. MixpanelLib.track)\n * @callback trackFunction\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n */\n\n/** Public **/\n\nvar GDPR_DEFAULT_PERSISTENCE_PREFIX = '__mp_opt_in_out_';\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction optIn(token, options) {\n    _optInOut(true, token, options);\n}\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-out cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-out cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-out cookie is set as secure or not\n */\nfunction optOut(token, options) {\n    _optInOut(false, token, options);\n}\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} whether the user has opted in to the given opt type\n */\nfunction hasOptedIn(token, options) {\n    return _getStorageValue(token, options) === '1';\n}\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the user has opted out of the given opt type\n */\nfunction hasOptedOut(token, options) {\n    if (_hasDoNotTrackFlagOn(options)) {\n        console$1.warn('This browser has \"Do Not Track\" enabled. This will prevent the Mixpanel SDK from sending any data. To ignore the \"Do Not Track\" browser setting, initialize the Mixpanel instance with the config \"ignore_dnt: true\"');\n        return true;\n    }\n    var optedOut = _getStorageValue(token, options) === '0';\n    if (optedOut) {\n        console$1.warn('You are opted out of Mixpanel tracking. This will prevent the Mixpanel SDK from sending any data.');\n    }\n    return optedOut;\n}\n\n/**\n * Wrap a MixpanelLib method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelLib(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this.get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelPeople method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelPeople(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Wrap a MixpanelGroup method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction addOptOutCheckMixpanelGroup(method) {\n    return _addOptOutCheck(method, function(name) {\n        return this._get_config(name);\n    });\n}\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for the given token\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistenceType] Persistence mechanism used - cookie or localStorage\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction clearOptInOut(token, options) {\n    options = options || {};\n    _getStorage(options).remove(\n        _getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain\n    );\n}\n\n/** Private **/\n\n/**\n * Get storage util\n * @param {Object} [options]\n * @param {string} [options.persistenceType]\n * @returns {object} either _.cookie or _.localstorage\n */\nfunction _getStorage(options) {\n    options = options || {};\n    return options.persistenceType === 'localStorage' ? _.localStorage : _.cookie;\n}\n\n/**\n * Get the name of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the name of the cookie for the given opt type\n */\nfunction _getStorageKey(token, options) {\n    options = options || {};\n    return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;\n}\n\n/**\n * Get the value of the cookie that is used for the given opt type (tracking, cookie, etc.)\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @returns {string} the value of the cookie for the given opt type\n */\nfunction _getStorageValue(token, options) {\n    return _getStorage(options).get(_getStorageKey(token, options));\n}\n\n/**\n * Check whether the user has set the DNT/doNotTrack setting to true in their browser\n * @param {Object} [options]\n * @param {string} [options.window] - alternate window object to check; used to force various DNT settings in browser tests\n * @param {boolean} [options.ignoreDnt] - flag to ignore browser DNT settings and always return false\n * @returns {boolean} whether the DNT setting is true\n */\nfunction _hasDoNotTrackFlagOn(options) {\n    if (options && options.ignoreDnt) {\n        return false;\n    }\n    var win$1 = (options && options.window) || win;\n    var nav = win$1['navigator'] || {};\n    var hasDntOn = false;\n\n    _.each([\n        nav['doNotTrack'], // standard\n        nav['msDoNotTrack'],\n        win$1['doNotTrack']\n    ], function(dntValue) {\n        if (_.includes([true, 1, '1', 'yes'], dntValue)) {\n            hasDntOn = true;\n        }\n    });\n\n    return hasDntOn;\n}\n\n/**\n * Set cookie/localstorage for the user indicating that they are opted in or out for the given opt type\n * @param {boolean} optValue - whether to opt the user in or out for the given opt type\n * @param {string} token - Mixpanel project tracking token\n * @param {Object} [options]\n * @param {trackFunction} [options.track] - function used for tracking a Mixpanel event to record the opt-in action\n * @param {string} [options.trackEventName] - event name to be used for tracking the opt-in action\n * @param {Object} [options.trackProperties] - set of properties to be tracked along with the opt-in action\n * @param {string} [options.persistencePrefix=__mp_opt_in_out] - custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookieExpiration] - number of days until the opt-in cookie expires\n * @param {string} [options.cookieDomain] - custom cookie domain\n * @param {boolean} [options.crossSiteCookie] - whether the opt-in cookie is set as cross-site-enabled\n * @param {boolean} [options.crossSubdomainCookie] - whether the opt-in cookie is set as cross-subdomain or not\n * @param {boolean} [options.secureCookie] - whether the opt-in cookie is set as secure or not\n */\nfunction _optInOut(optValue, token, options) {\n    if (!_.isString(token) || !token.length) {\n        console$1.error('gdpr.' + (optValue ? 'optIn' : 'optOut') + ' called with an invalid token');\n        return;\n    }\n\n    options = options || {};\n\n    _getStorage(options).set(\n        _getStorageKey(token, options),\n        optValue ? 1 : 0,\n        _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null,\n        !!options.crossSubdomainCookie,\n        !!options.secureCookie,\n        !!options.crossSiteCookie,\n        options.cookieDomain\n    );\n\n    if (options.track && optValue) { // only track event if opting in (optValue=true)\n        options.track(options.trackEventName || '$opt_in', options.trackProperties, {\n            'send_immediately': true\n        });\n    }\n}\n\n/**\n * Wrap a method with a check for whether the user is opted out of data tracking and cookies/localstorage for the given token\n * If the user has opted out, return early instead of executing the method.\n * If a callback argument was provided, execute it passing the 0 error code.\n * @param {function} method - wrapped method to be executed if the user has not opted out\n * @param {function} getConfigValue - getter function for the Mixpanel API token and other options to be used with opt-out check\n * @returns {*} the result of executing method OR undefined if the user has opted out\n */\nfunction _addOptOutCheck(method, getConfigValue) {\n    return function() {\n        var optedOut = false;\n\n        try {\n            var token = getConfigValue.call(this, 'token');\n            var ignoreDnt = getConfigValue.call(this, 'ignore_dnt');\n            var persistenceType = getConfigValue.call(this, 'opt_out_tracking_persistence_type');\n            var persistencePrefix = getConfigValue.call(this, 'opt_out_tracking_cookie_prefix');\n            var win = getConfigValue.call(this, 'window'); // used to override window during browser tests\n\n            if (token) { // if there was an issue getting the token, continue method execution as normal\n                optedOut = hasOptedOut(token, {\n                    ignoreDnt: ignoreDnt,\n                    persistenceType: persistenceType,\n                    persistencePrefix: persistencePrefix,\n                    window: win\n                });\n            }\n        } catch(err) {\n            console$1.error('Unexpected error when checking tracking opt-out status: ' + err);\n        }\n\n        if (!optedOut) {\n            return method.apply(this, arguments);\n        }\n\n        var callback = arguments[arguments.length - 1];\n        if (typeof(callback) === 'function') {\n            callback(0);\n        }\n\n        return;\n    };\n}\n\nvar logger$4 = console_with_prefix('lock');\n\n/**\n * SharedLock: a mutex built on HTML5 localStorage, to ensure that only one browser\n * window/tab at a time will be able to access shared resources.\n *\n * Based on the Alur and Taubenfeld fast lock\n * (http://www.cs.rochester.edu/research/synchronization/pseudocode/fastlock.html)\n * with an added timeout to ensure there will be eventual progress in the event\n * that a window is closed in the middle of the callback.\n *\n * Implementation based on the original version by David Wolever (https://github.com/wolever)\n * at https://gist.github.com/wolever/5fd7573d1ef6166e8f8c4af286a69432.\n *\n * @example\n * const myLock = new SharedLock('some-key');\n * myLock.withLock(function() {\n *   console.log('I hold the mutex!');\n * });\n *\n * @constructor\n */\nvar SharedLock = function(key, options) {\n    options = options || {};\n\n    this.storageKey = key;\n    this.storage = options.storage || window.localStorage;\n    this.pollIntervalMS = options.pollIntervalMS || 100;\n    this.timeoutMS = options.timeoutMS || 2000;\n\n    // dependency-inject promise implementation for testing purposes\n    this.promiseImpl = options.promiseImpl || PromisePolyfill;\n};\n\n// pass in a specific pid to test contention scenarios; otherwise\n// it is chosen randomly for each acquisition attempt\nSharedLock.prototype.withLock = function(lockedCB, pid) {\n    var Promise = this.promiseImpl;\n    return new Promise(_.bind(function (resolve, reject) {\n        var i = pid || (new Date().getTime() + '|' + Math.random());\n        var startTime = new Date().getTime();\n\n        var key = this.storageKey;\n        var pollIntervalMS = this.pollIntervalMS;\n        var timeoutMS = this.timeoutMS;\n        var storage = this.storage;\n\n        var keyX = key + ':X';\n        var keyY = key + ':Y';\n        var keyZ = key + ':Z';\n\n        var delay = function(cb) {\n            if (new Date().getTime() - startTime > timeoutMS) {\n                logger$4.error('Timeout waiting for mutex on ' + key + '; clearing lock. [' + i + ']');\n                storage.removeItem(keyZ);\n                storage.removeItem(keyY);\n                loop();\n                return;\n            }\n            setTimeout(function() {\n                try {\n                    cb();\n                } catch(err) {\n                    reject(err);\n                }\n            }, pollIntervalMS * (Math.random() + 0.1));\n        };\n\n        var waitFor = function(predicate, cb) {\n            if (predicate()) {\n                cb();\n            } else {\n                delay(function() {\n                    waitFor(predicate, cb);\n                });\n            }\n        };\n\n        var getSetY = function() {\n            var valY = storage.getItem(keyY);\n            if (valY && valY !== i) { // if Y == i then this process already has the lock (useful for test cases)\n                return false;\n            } else {\n                storage.setItem(keyY, i);\n                if (storage.getItem(keyY) === i) {\n                    return true;\n                } else {\n                    if (!localStorageSupported(storage, true)) {\n                        reject(new Error('localStorage support dropped while acquiring lock'));\n                    }\n                    return false;\n                }\n            }\n        };\n\n        var loop = function() {\n            storage.setItem(keyX, i);\n\n            waitFor(getSetY, function() {\n                if (storage.getItem(keyX) === i) {\n                    criticalSection();\n                    return;\n                }\n\n                delay(function() {\n                    if (storage.getItem(keyY) !== i) {\n                        loop();\n                        return;\n                    }\n                    waitFor(function() {\n                        return !storage.getItem(keyZ);\n                    }, criticalSection);\n                });\n            });\n        };\n\n        var criticalSection = function() {\n            storage.setItem(keyZ, '1');\n            var removeLock = function () {\n                storage.removeItem(keyZ);\n                if (storage.getItem(keyY) === i) {\n                    storage.removeItem(keyY);\n                }\n                if (storage.getItem(keyX) === i) {\n                    storage.removeItem(keyX);\n                }\n            };\n\n            lockedCB()\n                .then(function (ret) {\n                    removeLock();\n                    resolve(ret);\n                })\n                .catch(function (err) {\n                    removeLock();\n                    reject(err);\n                });\n        };\n\n        try {\n            if (localStorageSupported(storage, true)) {\n                loop();\n            } else {\n                throw new Error('localStorage support check failed');\n            }\n        } catch(err) {\n            reject(err);\n        }\n    }, this));\n};\n\n/**\n * @typedef {import('./wrapper').StorageWrapper}\n */\n\n/**\n * @type {StorageWrapper}\n */\nvar LocalStorageWrapper = function (storageOverride) {\n    this.storage = storageOverride || localStorage;\n};\n\nLocalStorageWrapper.prototype.init = function () {\n    return PromisePolyfill.resolve();\n};\n\nLocalStorageWrapper.prototype.setItem = function (key, value) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.setItem(key, value);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nLocalStorageWrapper.prototype.getItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        var item;\n        try {\n            item = this.storage.getItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve(item);\n    }, this));\n};\n\nLocalStorageWrapper.prototype.removeItem = function (key) {\n    return new PromisePolyfill(_.bind(function (resolve, reject) {\n        try {\n            this.storage.removeItem(key);\n        } catch (e) {\n            reject(e);\n        }\n        resolve();\n    }, this));\n};\n\nvar logger$3 = console_with_prefix('batch');\n\n/**\n * RequestQueue: queue for batching API requests with localStorage backup for retries.\n * Maintains an in-memory queue which represents the source of truth for the current\n * page, but also writes all items out to a copy in the browser's localStorage, which\n * can be read on subsequent pageloads and retried. For batchability, all the request\n * items in the queue should be of the same type (events, people updates, group updates)\n * so they can be sent in a single request to the same API endpoint.\n *\n * LocalStorage keying and locking: In order for reloads and subsequent pageloads of\n * the same site to access the same persisted data, they must share the same localStorage\n * key (for instance based on project token and queue type). Therefore access to the\n * localStorage entry is guarded by an asynchronous mutex (SharedLock) to prevent\n * simultaneously open windows/tabs from overwriting each other's data (which would lead\n * to data loss in some situations).\n * @constructor\n */\nvar RequestQueue = function (storageKey, options) {\n    options = options || {};\n    this.storageKey = storageKey;\n    this.usePersistence = options.usePersistence;\n    if (this.usePersistence) {\n        this.queueStorage = options.queueStorage || new LocalStorageWrapper();\n        this.lock = new SharedLock(storageKey, { storage: options.sharedLockStorage || window.localStorage });\n        this.queueStorage.init();\n    }\n    this.reportError = options.errorReporter || _.bind(logger$3.error, logger$3);\n\n    this.pid = options.pid || null; // pass pid to test out storage lock contention scenarios\n\n    this.memQueue = [];\n    this.initialized = false;\n};\n\nRequestQueue.prototype.ensureInit = function () {\n    if (this.initialized) {\n        return PromisePolyfill.resolve();\n    }\n\n    return this.queueStorage\n        .init()\n        .then(_.bind(function () {\n            this.initialized = true;\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error initializing queue persistence. Disabling persistence', err);\n            this.initialized = true;\n            this.usePersistence = false;\n        }, this));\n};\n\n/**\n * Add one item to queues (memory and localStorage). The queued entry includes\n * the given item along with an auto-generated ID and a \"flush-after\" timestamp.\n * It is expected that the item will be sent over the network and dequeued\n * before the flush-after time; if this doesn't happen it is considered orphaned\n * (e.g., the original tab where it was enqueued got closed before it could be\n * sent) and the item can be sent by any tab that finds it in localStorage.\n *\n * The final callback param is called with a param indicating success or\n * failure of the enqueue operation; it is asynchronous because the localStorage\n * lock is asynchronous.\n */\nRequestQueue.prototype.enqueue = function (item, flushInterval) {\n    var queueEntry = {\n        'id': cheap_guid(),\n        'flushAfter': new Date().getTime() + flushInterval * 2,\n        'payload': item\n    };\n\n    if (!this.usePersistence) {\n        this.memQueue.push(queueEntry);\n        return PromisePolyfill.resolve(true);\n    } else {\n\n        var enqueueItem = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue.push(queueEntry);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function (succeeded) {\n                    // only add to in-memory queue when storage succeeds\n                    if (succeeded) {\n                        this.memQueue.push(queueEntry);\n                    }\n                    return succeeded;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error enqueueing item', err, item);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(enqueueItem, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read out the given number of queue entries. If this.memQueue\n * has fewer than batchSize items, then look for \"orphaned\" items\n * in the persisted queue (items where the 'flushAfter' time has\n * already passed).\n */\nRequestQueue.prototype.fillBatch = function (batchSize) {\n    var batch = this.memQueue.slice(0, batchSize);\n    if (this.usePersistence && batch.length < batchSize) {\n        // don't need lock just to read events; localStorage is thread-safe\n        // and the worst that could happen is a duplicate send of some\n        // orphaned events, which will be deduplicated on the server side\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.readFromStorage();\n            }, this))\n            .then(_.bind(function (storedQueue) {\n                if (storedQueue.length) {\n                // item IDs already in batch; don't duplicate out of storage\n                    var idsInBatch = {}; // poor man's Set\n                    _.each(batch, function (item) {\n                        idsInBatch[item['id']] = true;\n                    });\n\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (new Date().getTime() > item['flushAfter'] && !idsInBatch[item['id']]) {\n                            item.orphaned = true;\n                            batch.push(item);\n                            if (batch.length >= batchSize) {\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                return batch;\n            }, this));\n    } else {\n        return PromisePolyfill.resolve(batch);\n    }\n};\n\n/**\n * Remove items with matching 'id' from array (immutably)\n * also remove any item without a valid id (e.g., malformed\n * storage entries).\n */\nvar filterOutIDsAndInvalid = function (items, idSet) {\n    var filteredItems = [];\n    _.each(items, function (item) {\n        if (item['id'] && !idSet[item['id']]) {\n            filteredItems.push(item);\n        }\n    });\n    return filteredItems;\n};\n\n/**\n * Remove items with matching IDs from both in-memory queue\n * and persisted queue\n */\nRequestQueue.prototype.removeItemsByID = function (ids) {\n    var idSet = {}; // poor man's Set\n    _.each(ids, function (id) {\n        idSet[id] = true;\n    });\n\n    this.memQueue = filterOutIDsAndInvalid(this.memQueue, idSet);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        var removeFromStorage = _.bind(function () {\n            return this.ensureInit()\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    storedQueue = filterOutIDsAndInvalid(storedQueue, idSet);\n                    return this.saveToStorage(storedQueue);\n                }, this))\n                .then(_.bind(function () {\n                    return this.readFromStorage();\n                }, this))\n                .then(_.bind(function (storedQueue) {\n                    // an extra check: did storage report success but somehow\n                    // the items are still there?\n                    for (var i = 0; i < storedQueue.length; i++) {\n                        var item = storedQueue[i];\n                        if (item['id'] && !!idSet[item['id']]) {\n                            throw new Error('Item not removed from storage');\n                        }\n                    }\n                    return true;\n                }, this))\n                .catch(_.bind(function (err) {\n                    this.reportError('Error removing items', err, ids);\n                    return false;\n                }, this));\n        }, this);\n\n        return this.lock\n            .withLock(removeFromStorage, this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                if (!localStorageSupported(this.queueStorage.storage, true)) {\n                    // Looks like localStorage writes have stopped working sometime after\n                    // initialization (probably full), and so nobody can acquire locks\n                    // anymore. Consider it temporarily safe to remove items without the\n                    // lock, since nobody's writing successfully anyway.\n                    return removeFromStorage()\n                        .then(_.bind(function (success) {\n                            if (!success) {\n                                // OK, we couldn't even write out the smaller queue. Try clearing it\n                                // entirely.\n                                return this.queueStorage.removeItem(this.storageKey).then(function () {\n                                    return success;\n                                });\n                            }\n                            return success;\n                        }, this))\n                        .catch(_.bind(function (err) {\n                            this.reportError('Error clearing queue', err);\n                            return false;\n                        }, this));\n                } else {\n                    return false;\n                }\n            }, this));\n    }\n};\n\n// internal helper for RequestQueue.updatePayloads\nvar updatePayloads = function (existingItems, itemsToUpdate) {\n    var newItems = [];\n    _.each(existingItems, function (item) {\n        var id = item['id'];\n        if (id in itemsToUpdate) {\n            var newPayload = itemsToUpdate[id];\n            if (newPayload !== null) {\n                item['payload'] = newPayload;\n                newItems.push(item);\n            }\n        } else {\n            // no update\n            newItems.push(item);\n        }\n    });\n    return newItems;\n};\n\n/**\n * Update payloads of given items in both in-memory queue and\n * persisted queue. Items set to null are removed from queues.\n */\nRequestQueue.prototype.updatePayloads = function (itemsToUpdate) {\n    this.memQueue = updatePayloads(this.memQueue, itemsToUpdate);\n    if (!this.usePersistence) {\n        return PromisePolyfill.resolve(true);\n    } else {\n        return this.lock\n            .withLock(_.bind(function lockAcquired() {\n                return this.ensureInit()\n                    .then(_.bind(function () {\n                        return this.readFromStorage();\n                    }, this))\n                    .then(_.bind(function (storedQueue) {\n                        storedQueue = updatePayloads(storedQueue, itemsToUpdate);\n                        return this.saveToStorage(storedQueue);\n                    }, this))\n                    .catch(_.bind(function (err) {\n                        this.reportError('Error updating items', itemsToUpdate, err);\n                        return false;\n                    }, this));\n            }, this), this.pid)\n            .catch(_.bind(function (err) {\n                this.reportError('Error acquiring storage lock', err);\n                return false;\n            }, this));\n    }\n};\n\n/**\n * Read and parse items array from localStorage entry, handling\n * malformed/missing data if necessary.\n */\nRequestQueue.prototype.readFromStorage = function () {\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.getItem(this.storageKey);\n        }, this))\n        .then(_.bind(function (storageEntry) {\n            if (storageEntry) {\n                storageEntry = JSONParse(storageEntry);\n                if (!_.isArray(storageEntry)) {\n                    this.reportError('Invalid storage entry:', storageEntry);\n                    storageEntry = null;\n                }\n            }\n            return storageEntry || [];\n        }, this))\n        .catch(_.bind(function (err) {\n            this.reportError('Error retrieving queue', err);\n            return [];\n        }, this));\n};\n\n/**\n * Serialize the given items array to localStorage.\n */\nRequestQueue.prototype.saveToStorage = function (queue) {\n    try {\n        var serialized = JSONStringify(queue);\n    } catch (err) {\n        this.reportError('Error serializing queue', err);\n        return PromisePolyfill.resolve(false);\n    }\n\n    return this.ensureInit()\n        .then(_.bind(function () {\n            return this.queueStorage.setItem(this.storageKey, serialized);\n        }, this))\n        .then(function () {\n            return true;\n        })\n        .catch(_.bind(function (err) {\n            this.reportError('Error saving queue', err);\n            return false;\n        }, this));\n};\n\n/**\n * Clear out queues (memory and localStorage).\n */\nRequestQueue.prototype.clear = function () {\n    this.memQueue = [];\n\n    if (this.usePersistence) {\n        return this.ensureInit()\n            .then(_.bind(function () {\n                return this.queueStorage.removeItem(this.storageKey);\n            }, this));\n    } else {\n        return PromisePolyfill.resolve();\n    }\n};\n\n// maximum interval between request retries after exponential backoff\nvar MAX_RETRY_INTERVAL_MS = 10 * 60 * 1000; // 10 minutes\n\nvar logger$2 = console_with_prefix('batch');\n\n/**\n * RequestBatcher: manages the queueing, flushing, retry etc of requests of one\n * type (events, people, groups).\n * Uses RequestQueue to manage the backing store.\n * @constructor\n */\nvar RequestBatcher = function(storageKey, options) {\n    this.errorReporter = options.errorReporter;\n    this.queue = new RequestQueue(storageKey, {\n        errorReporter: _.bind(this.reportError, this),\n        queueStorage: options.queueStorage,\n        sharedLockStorage: options.sharedLockStorage,\n        usePersistence: options.usePersistence\n    });\n\n    this.libConfig = options.libConfig;\n    this.sendRequest = options.sendRequestFunc;\n    this.beforeSendHook = options.beforeSendHook;\n    this.stopAllBatching = options.stopAllBatchingFunc;\n\n    // seed variable batch size + flush interval with configured values\n    this.batchSize = this.libConfig['batch_size'];\n    this.flushInterval = this.libConfig['batch_flush_interval_ms'];\n\n    this.stopped = !this.libConfig['batch_autostart'];\n    this.consecutiveRemovalFailures = 0;\n\n    // extra client-side dedupe\n    this.itemIdsSentSuccessfully = {};\n\n    // Make the flush occur at the interval specified by flushIntervalMs, default behavior will attempt consecutive flushes\n    // as long as the queue is not empty. This is useful for high-frequency events like Session Replay where we might end up\n    // in a request loop and get ratelimited by the server.\n    this.flushOnlyOnInterval = options.flushOnlyOnInterval || false;\n};\n\n/**\n * Add one item to queue.\n */\nRequestBatcher.prototype.enqueue = function(item) {\n    return this.queue.enqueue(item, this.flushInterval);\n};\n\n/**\n * Start flushing batches at the configured time interval. Must call\n * this method upon SDK init in order to send anything over the network.\n */\nRequestBatcher.prototype.start = function() {\n    this.stopped = false;\n    this.consecutiveRemovalFailures = 0;\n    return this.flush();\n};\n\n/**\n * Stop flushing batches. Can be restarted by calling start().\n */\nRequestBatcher.prototype.stop = function() {\n    this.stopped = true;\n    if (this.timeoutID) {\n        clearTimeout(this.timeoutID);\n        this.timeoutID = null;\n    }\n};\n\n/**\n * Clear out queue.\n */\nRequestBatcher.prototype.clear = function() {\n    return this.queue.clear();\n};\n\n/**\n * Restore batch size configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetBatchSize = function() {\n    this.batchSize = this.libConfig['batch_size'];\n};\n\n/**\n * Restore flush interval time configuration to whatever is set in the main SDK.\n */\nRequestBatcher.prototype.resetFlush = function() {\n    this.scheduleFlush(this.libConfig['batch_flush_interval_ms']);\n};\n\n/**\n * Schedule the next flush in the given number of milliseconds.\n */\nRequestBatcher.prototype.scheduleFlush = function(flushMS) {\n    this.flushInterval = flushMS;\n    if (!this.stopped) { // don't schedule anymore if batching has been stopped\n        this.timeoutID = setTimeout(_.bind(function() {\n            if (!this.stopped) {\n                this.flush();\n            }\n        }, this), this.flushInterval);\n    }\n};\n\n/**\n * Send a request using the sendRequest callback, but promisified.\n * TODO: sendRequest should be promisified in the first place.\n */\nRequestBatcher.prototype.sendRequestPromise = function(data, options) {\n    return new PromisePolyfill(_.bind(function(resolve) {\n        this.sendRequest(data, options, resolve);\n    }, this));\n};\n\n\n/**\n * Flush one batch to network. Depending on success/failure modes, it will either\n * remove the batch from the queue or leave it in for retry, and schedule the next\n * flush. In cases of most network or API failures, it will back off exponentially\n * when retrying.\n * @param {Object} [options]\n * @param {boolean} [options.sendBeacon] - whether to send batch with\n * navigator.sendBeacon (only useful for sending batches before page unloads, as\n * sendBeacon offers no callbacks or status indications)\n */\nRequestBatcher.prototype.flush = function(options) {\n    if (this.requestInProgress) {\n        logger$2.log('Flush: Request already in progress');\n        return PromisePolyfill.resolve();\n    }\n\n    this.requestInProgress = true;\n\n    options = options || {};\n    var timeoutMS = this.libConfig['batch_request_timeout_ms'];\n    var startTime = new Date().getTime();\n    var currentBatchSize = this.batchSize;\n\n    return this.queue.fillBatch(currentBatchSize)\n        .then(_.bind(function(batch) {\n\n            // if there's more items in the queue than the batch size, attempt\n            // to flush again after the current batch is done.\n            var attemptSecondaryFlush = batch.length === currentBatchSize;\n            var dataForRequest = [];\n            var transformedItems = {};\n            _.each(batch, function(item) {\n                var payload = item['payload'];\n                if (this.beforeSendHook && !item.orphaned) {\n                    payload = this.beforeSendHook(payload);\n                }\n                if (payload) {\n                    // mp_sent_by_lib_version prop captures which lib version actually\n                    // sends each event (regardless of which version originally queued\n                    // it for sending)\n                    if (payload['event'] && payload['properties']) {\n                        payload['properties'] = _.extend(\n                            {},\n                            payload['properties'],\n                            {'mp_sent_by_lib_version': Config.LIB_VERSION}\n                        );\n                    }\n                    var addPayload = true;\n                    var itemId = item['id'];\n                    if (itemId) {\n                        if ((this.itemIdsSentSuccessfully[itemId] || 0) > 5) {\n                            this.reportError('[dupe] item ID sent too many times, not sending', {\n                                item: item,\n                                batchSize: batch.length,\n                                timesSent: this.itemIdsSentSuccessfully[itemId]\n                            });\n                            addPayload = false;\n                        }\n                    } else {\n                        this.reportError('[dupe] found item with no ID', {item: item});\n                    }\n\n                    if (addPayload) {\n                        dataForRequest.push(payload);\n                    }\n                }\n                transformedItems[item['id']] = payload;\n            }, this);\n\n            if (dataForRequest.length < 1) {\n                this.requestInProgress = false;\n                this.resetFlush();\n                return PromisePolyfill.resolve(); // nothing to do\n            }\n\n            var removeItemsFromQueue = _.bind(function () {\n                return this.queue\n                    .removeItemsByID(\n                        _.map(batch, function (item) {\n                            return item['id'];\n                        })\n                    )\n                    .then(_.bind(function (succeeded) {\n                        // client-side dedupe\n                        _.each(batch, _.bind(function(item) {\n                            var itemId = item['id'];\n                            if (itemId) {\n                                this.itemIdsSentSuccessfully[itemId] = this.itemIdsSentSuccessfully[itemId] || 0;\n                                this.itemIdsSentSuccessfully[itemId]++;\n                                if (this.itemIdsSentSuccessfully[itemId] > 5) {\n                                    this.reportError('[dupe] item ID sent too many times', {\n                                        item: item,\n                                        batchSize: batch.length,\n                                        timesSent: this.itemIdsSentSuccessfully[itemId]\n                                    });\n                                }\n                            } else {\n                                this.reportError('[dupe] found item with no ID while removing', {item: item});\n                            }\n                        }, this));\n\n                        if (succeeded) {\n                            this.consecutiveRemovalFailures = 0;\n                            if (this.flushOnlyOnInterval && !attemptSecondaryFlush) {\n                                this.resetFlush(); // schedule next batch with a delay\n                                return PromisePolyfill.resolve();\n                            } else {\n                                return this.flush(); // handle next batch if the queue isn't empty\n                            }\n                        } else {\n                            if (++this.consecutiveRemovalFailures > 5) {\n                                this.reportError('Too many queue failures; disabling batching system.');\n                                this.stopAllBatching();\n                            } else {\n                                this.resetFlush();\n                            }\n                            return PromisePolyfill.resolve();\n                        }\n                    }, this));\n            }, this);\n\n            var batchSendCallback = _.bind(function(res) {\n                this.requestInProgress = false;\n\n                try {\n\n                    // handle API response in a try-catch to make sure we can reset the\n                    // flush operation if something goes wrong\n\n                    if (options.unloading) {\n                        // update persisted data to include hook transformations\n                        return this.queue.updatePayloads(transformedItems);\n                    } else if (\n                        _.isObject(res) &&\n                            res.error === 'timeout' &&\n                            new Date().getTime() - startTime >= timeoutMS\n                    ) {\n                        this.reportError('Network timeout; retrying');\n                        return this.flush();\n                    } else if (\n                        _.isObject(res) &&\n                            (\n                                res.httpStatusCode >= 500\n                                || res.httpStatusCode === 429\n                                || (res.httpStatusCode <= 0 && !isOnline())\n                                || res.error === 'timeout'\n                            )\n                    ) {\n                        // network or API error, or 429 Too Many Requests, retry\n                        var retryMS = this.flushInterval * 2;\n                        if (res.retryAfter) {\n                            retryMS = (parseInt(res.retryAfter, 10) * 1000) || retryMS;\n                        }\n                        retryMS = Math.min(MAX_RETRY_INTERVAL_MS, retryMS);\n                        this.reportError('Error; retry in ' + retryMS + ' ms');\n                        this.scheduleFlush(retryMS);\n                        return PromisePolyfill.resolve();\n                    } else if (_.isObject(res) && res.httpStatusCode === 413) {\n                        // 413 Payload Too Large\n                        if (batch.length > 1) {\n                            var halvedBatchSize = Math.max(1, Math.floor(currentBatchSize / 2));\n                            this.batchSize = Math.min(this.batchSize, halvedBatchSize, batch.length - 1);\n                            this.reportError('413 response; reducing batch size to ' + this.batchSize);\n                            this.resetFlush();\n                            return PromisePolyfill.resolve();\n                        } else {\n                            this.reportError('Single-event request too large; dropping', batch);\n                            this.resetBatchSize();\n                            return removeItemsFromQueue();\n                        }\n                    } else {\n                        // successful network request+response; remove each item in batch from queue\n                        // (even if it was e.g. a 400, in which case retrying won't help)\n                        return removeItemsFromQueue();\n                    }\n                } catch(err) {\n                    this.reportError('Error handling API response', err);\n                    this.resetFlush();\n                }\n            }, this);\n            var requestOptions = {\n                method: 'POST',\n                verbose: true,\n                ignore_json_errors: true, // eslint-disable-line camelcase\n                timeout_ms: timeoutMS // eslint-disable-line camelcase\n            };\n            if (options.unloading) {\n                requestOptions.transport = 'sendBeacon';\n            }\n            logger$2.log('MIXPANEL REQUEST:', dataForRequest);\n            return this.sendRequestPromise(dataForRequest, requestOptions).then(batchSendCallback);\n        }, this))\n        .catch(_.bind(function(err) {\n            this.reportError('Error flushing request queue', err);\n            this.resetFlush();\n        }, this));\n};\n\n/**\n * Log error to global logger and optional user-defined logger.\n */\nRequestBatcher.prototype.reportError = function(msg, err) {\n    logger$2.error.apply(logger$2.error, arguments);\n    if (this.errorReporter) {\n        try {\n            if (!(err instanceof Error)) {\n                err = new Error(msg);\n            }\n            this.errorReporter(msg, err);\n        } catch(err) {\n            logger$2.error(err);\n        }\n    }\n};\n\nvar logger$1 = console_with_prefix('recorder');\nvar CompressionStream = win['CompressionStream'];\n\nvar RECORDER_BATCHER_LIB_CONFIG = {\n    'batch_size': 1000,\n    'batch_flush_interval_ms': 10 * 1000,\n    'batch_request_timeout_ms': 90 * 1000,\n    'batch_autostart': true\n};\n\nvar ACTIVE_SOURCES = new Set([\n    IncrementalSource.MouseMove,\n    IncrementalSource.MouseInteraction,\n    IncrementalSource.Scroll,\n    IncrementalSource.ViewportResize,\n    IncrementalSource.Input,\n    IncrementalSource.TouchMove,\n    IncrementalSource.MediaInteraction,\n    IncrementalSource.Drag,\n    IncrementalSource.Selection,\n]);\n\nfunction isUserEvent(ev) {\n    return ev.type === EventType.IncrementalSnapshot && ACTIVE_SOURCES.has(ev.data.source);\n}\n\n/**\n * This class encapsulates a single session recording and its lifecycle.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n * @param {String} [options.replayId] - unique uuid for a single replay\n * @param {Function} [options.onIdleTimeout] - callback when a recording reaches idle timeout\n * @param {Function} [options.onMaxLengthReached] - callback when a recording reaches its maximum length\n * @param {Function} [options.rrwebRecord] - rrweb's `record` function\n */\nvar SessionRecording = function(options) {\n    this._mixpanel = options.mixpanelInstance;\n    this._onIdleTimeout = options.onIdleTimeout;\n    this._onMaxLengthReached = options.onMaxLengthReached;\n    this._rrwebRecord = options.rrwebRecord;\n\n    this.replayId = options.replayId;\n\n    // internal rrweb stopRecording function\n    this._stopRecording = null;\n\n    this.seqNo = 0;\n    this.replayStartTime = null;\n    this.replayStartUrl = null;\n    this.batchStartUrl = null;\n\n    this.idleTimeoutId = null;\n    this.maxTimeoutId = null;\n\n    this.recordMaxMs = MAX_RECORDING_MS;\n    this.recordMinMs = 0;\n\n    // each replay has its own batcher key to avoid conflicts between rrweb events of different recordings\n    // this will be important when persistence is introduced\n    var batcherKey = '__mprec_' + this.getConfig('token') + '_' + this.replayId;\n    this.batcher = new RequestBatcher(batcherKey, {\n        errorReporter: _.bind(this.reportError, this),\n        flushOnlyOnInterval: true,\n        libConfig: RECORDER_BATCHER_LIB_CONFIG,\n        sendRequestFunc: _.bind(this.flushEventsWithOptOut, this),\n        usePersistence: false\n    });\n};\n\nSessionRecording.prototype.getConfig = function(configVar) {\n    return this._mixpanel.get_config(configVar);\n};\n\n// Alias for getConfig, used by the common addOptOutCheckMixpanelLib function which\n// reaches into this class instance and expects the snake case version of the function.\n// eslint-disable-next-line camelcase\nSessionRecording.prototype.get_config = function(configVar) {\n    return this.getConfig(configVar);\n};\n\nSessionRecording.prototype.startRecording = function (shouldStopBatcher) {\n    if (this._stopRecording !== null) {\n        logger$1.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    this.recordMaxMs = this.getConfig('record_max_ms');\n    if (this.recordMaxMs > MAX_RECORDING_MS) {\n        this.recordMaxMs = MAX_RECORDING_MS;\n        logger$1.critical('record_max_ms cannot be greater than ' + MAX_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    this.recordMinMs = this.getConfig('record_min_ms');\n    if (this.recordMinMs > MAX_VALUE_FOR_MIN_RECORDING_MS) {\n        this.recordMinMs = MAX_VALUE_FOR_MIN_RECORDING_MS;\n        logger$1.critical('record_min_ms cannot be greater than ' + MAX_VALUE_FOR_MIN_RECORDING_MS + 'ms. Capping value.');\n    }\n\n    this.replayStartTime = new Date().getTime();\n    this.batchStartUrl = _.info.currentUrl();\n    this.replayStartUrl = _.info.currentUrl();\n\n    if (shouldStopBatcher || this.recordMinMs > 0) {\n        // the primary case for shouldStopBatcher is when we're starting recording after a reset\n        // and don't want to send anything over the network until there's\n        // actual user activity\n        // this also applies if the minimum recording length has not been hit yet\n        // so that we don't send data until we know the recording will be long enough\n        this.batcher.stop();\n    } else {\n        this.batcher.start();\n    }\n\n    var resetIdleTimeout = _.bind(function () {\n        clearTimeout(this.idleTimeoutId);\n        this.idleTimeoutId = setTimeout(this._onIdleTimeout, this.getConfig('record_idle_timeout_ms'));\n    }, this);\n\n    var blockSelector = this.getConfig('record_block_selector');\n    if (blockSelector === '' || blockSelector === null) {\n        blockSelector = undefined;\n    }\n\n    this._stopRecording = this._rrwebRecord({\n        'emit': _.bind(function (ev) {\n            this.batcher.enqueue(ev);\n            if (isUserEvent(ev)) {\n                if (this.batcher.stopped && new Date().getTime() - this.replayStartTime >= this.recordMinMs) {\n                    // start flushing again after user activity\n                    this.batcher.start();\n                }\n                resetIdleTimeout();\n            }\n        }, this),\n        'blockClass': this.getConfig('record_block_class'),\n        'blockSelector': blockSelector,\n        'collectFonts': this.getConfig('record_collect_fonts'),\n        'dataURLOptions': { // canvas image options (https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toDataURL)\n            'type': 'image/webp',\n            'quality': 0.6\n        },\n        'maskAllInputs': true,\n        'maskTextClass': this.getConfig('record_mask_text_class'),\n        'maskTextSelector': this.getConfig('record_mask_text_selector'),\n        'recordCanvas': this.getConfig('record_canvas'),\n        'sampling': {\n            'canvas': 15\n        }\n    });\n\n    if (typeof this._stopRecording !== 'function') {\n        this.reportError('rrweb failed to start, skipping this recording.');\n        this._stopRecording = null;\n        this.stopRecording(); // stop batcher looping and any timeouts\n        return;\n    }\n\n    resetIdleTimeout();\n\n    this.maxTimeoutId = setTimeout(_.bind(this._onMaxLengthReached, this), this.recordMaxMs);\n};\n\nSessionRecording.prototype.stopRecording = function () {\n    if (!this.isRrwebStopped()) {\n        try {\n            this._stopRecording();\n        } catch (err) {\n            this.reportError('Error with rrweb stopRecording', err);\n        }\n        this._stopRecording = null;\n    }\n\n    if (this.batcher.stopped) {\n        // never got user activity to flush after reset, so just clear the batcher\n        this.batcher.clear();\n    } else {\n        // flush any remaining events from running batcher\n        this.batcher.flush();\n        this.batcher.stop();\n    }\n\n    clearTimeout(this.idleTimeoutId);\n    clearTimeout(this.maxTimeoutId);\n};\n\nSessionRecording.prototype.isRrwebStopped = function () {\n    return this._stopRecording === null;\n};\n\n/**\n * Flushes the current batch of events to the server, but passes an opt-out callback to make sure\n * we stop recording and dump any queued events if the user has opted out.\n */\nSessionRecording.prototype.flushEventsWithOptOut = function (data, options, cb) {\n    this._flushEvents(data, options, cb, _.bind(this._onOptOut, this));\n};\n\nSessionRecording.prototype._onOptOut = function (code) {\n    // addOptOutCheckMixpanelLib invokes this function with code=0 when the user has opted out\n    if (code === 0) {\n        this.stopRecording();\n    }\n};\n\nSessionRecording.prototype._sendRequest = function(currentReplayId, reqParams, reqBody, callback) {\n    var onSuccess = _.bind(function (response, responseBody) {\n        // Update batch specific props only if the request was successful to guarantee ordering.\n        // RequestBatcher will always flush the next batch after the previous one succeeds.\n        // extra check to see if the replay ID has changed so that we don't increment the seqNo on the wrong replay\n        if (response.status === 200 && this.replayId === currentReplayId) {\n            this.seqNo++;\n            this.batchStartUrl = _.info.currentUrl();\n        }\n        callback({\n            status: 0,\n            httpStatusCode: response.status,\n            responseBody: responseBody,\n            retryAfter: response.headers.get('Retry-After')\n        });\n    }, this);\n\n    win['fetch'](this.getConfig('api_host') + '/' + this.getConfig('api_routes')['record'] + '?' + new URLSearchParams(reqParams), {\n        'method': 'POST',\n        'headers': {\n            'Authorization': 'Basic ' + btoa(this.getConfig('token') + ':'),\n            'Content-Type': 'application/octet-stream'\n        },\n        'body': reqBody,\n    }).then(function (response) {\n        response.json().then(function (responseBody) {\n            onSuccess(response, responseBody);\n        }).catch(function (error) {\n            callback({error: error});\n        });\n    }).catch(function (error) {\n        callback({error: error, httpStatusCode: 0});\n    });\n};\n\nSessionRecording.prototype._flushEvents = addOptOutCheckMixpanelLib(function (data, options, callback) {\n    const numEvents = data.length;\n\n    if (numEvents > 0) {\n        var replayId = this.replayId;\n        // each rrweb event has a timestamp - leverage those to get time properties\n        var batchStartTime = data[0].timestamp;\n        if (this.seqNo === 0 || !this.replayStartTime) {\n            // extra safety net so that we don't send a null replay start time\n            if (this.seqNo !== 0) {\n                this.reportError('Replay start time not set but seqNo is not 0. Using current batch start time as a fallback.');\n            }\n\n            this.replayStartTime = batchStartTime;\n        }\n        var replayLengthMs = data[numEvents - 1].timestamp - this.replayStartTime;\n\n        var reqParams = {\n            '$current_url': this.batchStartUrl,\n            '$lib_version': Config.LIB_VERSION,\n            'batch_start_time': batchStartTime / 1000,\n            'distinct_id': String(this._mixpanel.get_distinct_id()),\n            'mp_lib': 'web',\n            'replay_id': replayId,\n            'replay_length_ms': replayLengthMs,\n            'replay_start_time': this.replayStartTime / 1000,\n            'replay_start_url': this.replayStartUrl,\n            'seq': this.seqNo\n        };\n        var eventsJson = _.JSONEncode(data);\n\n        // send ID management props if they exist\n        var deviceId = this._mixpanel.get_property('$device_id');\n        if (deviceId) {\n            reqParams['$device_id'] = deviceId;\n        }\n        var userId = this._mixpanel.get_property('$user_id');\n        if (userId) {\n            reqParams['$user_id'] = userId;\n        }\n\n        if (CompressionStream) {\n            var jsonStream = new Blob([eventsJson], {type: 'application/json'}).stream();\n            var gzipStream = jsonStream.pipeThrough(new CompressionStream('gzip'));\n            new Response(gzipStream)\n                .blob()\n                .then(_.bind(function(compressedBlob) {\n                    reqParams['format'] = 'gzip';\n                    this._sendRequest(replayId, reqParams, compressedBlob, callback);\n                }, this));\n        } else {\n            reqParams['format'] = 'body';\n            this._sendRequest(replayId, reqParams, eventsJson, callback);\n        }\n    }\n});\n\n\nSessionRecording.prototype.reportError = function(msg, err) {\n    logger$1.error.apply(logger$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.getConfig('error_reporter')(msg, err);\n    } catch(err) {\n        logger$1.error(err);\n    }\n};\n\nvar logger = console_with_prefix('recorder');\n\n/**\n * Recorder API: manages recordings and exposes methods public to the core Mixpanel library.\n * @param {Object} [options.mixpanelInstance] - reference to the core MixpanelLib\n */\nvar MixpanelRecorder = function(mixpanelInstance) {\n    this._mixpanel = mixpanelInstance;\n    this.activeRecording = null;\n};\n\nMixpanelRecorder.prototype.startRecording = function(shouldStopBatcher) {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        logger.log('Recording already in progress, skipping startRecording.');\n        return;\n    }\n\n    var onIdleTimeout = _.bind(function () {\n        logger.log('Idle timeout reached, restarting recording.');\n        this.resetRecording();\n    }, this);\n\n    var onMaxLengthReached = _.bind(function () {\n        logger.log('Max recording length reached, stopping recording.');\n        this.resetRecording();\n    }, this);\n\n    this.activeRecording = new SessionRecording({\n        mixpanelInstance: this._mixpanel,\n        onIdleTimeout: onIdleTimeout,\n        onMaxLengthReached: onMaxLengthReached,\n        replayId: _.UUID(),\n        rrwebRecord: record\n    });\n\n    this.activeRecording.startRecording(shouldStopBatcher);\n};\n\nMixpanelRecorder.prototype.stopRecording = function() {\n    if (this.activeRecording) {\n        this.activeRecording.stopRecording();\n        this.activeRecording = null;\n    }\n};\n\nMixpanelRecorder.prototype.resetRecording = function () {\n    this.stopRecording();\n    this.startRecording(true);\n};\n\nMixpanelRecorder.prototype.getActiveReplayId = function () {\n    if (this.activeRecording && !this.activeRecording.isRrwebStopped()) {\n        return this.activeRecording.replayId;\n    } else {\n        return null;\n    }\n};\n\n// getter so that older mixpanel-core versions can still retrieve the replay ID\n// when pulling the latest recorder bundle from the CDN\nObject.defineProperty(MixpanelRecorder.prototype, 'replayId', {\n    get: function () {\n        return this.getActiveReplayId();\n    }\n});\n\nwin['__mp_recorder'] = MixpanelRecorder;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * DomTracker Object\n * @constructor\n */\nvar DomTracker = function() {};\n\n\n// interface\nDomTracker.prototype.create_properties = function() {};\nDomTracker.prototype.event_handler = function() {};\nDomTracker.prototype.after_track_handler = function() {};\n\nDomTracker.prototype.init = function(mixpanel_instance) {\n    this.mp = mixpanel_instance;\n    return this;\n};\n\n/**\n * @param {Object|string} query\n * @param {string} event_name\n * @param {Object=} properties\n * @param {function=} user_callback\n */\nDomTracker.prototype.track = function(query, event_name, properties, user_callback) {\n    var that = this;\n    var elements = _.dom_query(query);\n\n    if (elements.length === 0) {\n        console$1.error('The DOM query (' + query + ') returned 0 elements');\n        return;\n    }\n\n    _.each(elements, function(element) {\n        _.register_event(element, this.override_event, function(e) {\n            var options = {};\n            var props = that.create_properties(properties, this);\n            var timeout = that.mp.get_config('track_links_timeout');\n\n            that.event_handler(e, this, options);\n\n            // in case the mixpanel servers don't get back to us in time\n            window.setTimeout(that.track_callback(user_callback, props, options, true), timeout);\n\n            // fire the tracking event\n            that.mp.track(event_name, props, that.track_callback(user_callback, props, options));\n        });\n    }, this);\n\n    return true;\n};\n\n/**\n * @param {function} user_callback\n * @param {Object} props\n * @param {boolean=} timeout_occured\n */\nDomTracker.prototype.track_callback = function(user_callback, props, options, timeout_occured) {\n    timeout_occured = timeout_occured || false;\n    var that = this;\n\n    return function() {\n        // options is referenced from both callbacks, so we can have\n        // a 'lock' of sorts to ensure only one fires\n        if (options.callback_fired) { return; }\n        options.callback_fired = true;\n\n        if (user_callback && user_callback(timeout_occured, props) === false) {\n            // user can prevent the default functionality by\n            // returning false from their callback\n            return;\n        }\n\n        that.after_track_handler(props, options, timeout_occured);\n    };\n};\n\nDomTracker.prototype.create_properties = function(properties, element) {\n    var props;\n\n    if (typeof(properties) === 'function') {\n        props = properties(element);\n    } else {\n        props = _.extend({}, properties);\n    }\n\n    return props;\n};\n\n/**\n * LinkTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar LinkTracker = function() {\n    this.override_event = 'click';\n};\n_.inherit(LinkTracker, DomTracker);\n\nLinkTracker.prototype.create_properties = function(properties, element) {\n    var props = LinkTracker.superclass.create_properties.apply(this, arguments);\n\n    if (element.href) { props['url'] = element.href; }\n\n    return props;\n};\n\nLinkTracker.prototype.event_handler = function(evt, element, options) {\n    options.new_tab = (\n        evt.which === 2 ||\n        evt.metaKey ||\n        evt.ctrlKey ||\n        element.target === '_blank'\n    );\n    options.href = element.href;\n\n    if (!options.new_tab) {\n        evt.preventDefault();\n    }\n};\n\nLinkTracker.prototype.after_track_handler = function(props, options) {\n    if (options.new_tab) { return; }\n\n    setTimeout(function() {\n        window.location = options.href;\n    }, 0);\n};\n\n/**\n * FormTracker Object\n * @constructor\n * @extends DomTracker\n */\nvar FormTracker = function() {\n    this.override_event = 'submit';\n};\n_.inherit(FormTracker, DomTracker);\n\nFormTracker.prototype.event_handler = function(evt, element, options) {\n    options.element = element;\n    evt.preventDefault();\n};\n\nFormTracker.prototype.after_track_handler = function(props, options) {\n    setTimeout(function() {\n        options.element.submit();\n    }, 0);\n};\n\n/* eslint camelcase: \"off\" */\n\n/** @const */ var SET_ACTION      = '$set';\n/** @const */ var SET_ONCE_ACTION = '$set_once';\n/** @const */ var UNSET_ACTION    = '$unset';\n/** @const */ var ADD_ACTION      = '$add';\n/** @const */ var APPEND_ACTION   = '$append';\n/** @const */ var UNION_ACTION    = '$union';\n/** @const */ var REMOVE_ACTION   = '$remove';\n/** @const */ var DELETE_ACTION   = '$delete';\n\n// Common internal methods for mixpanel.people and mixpanel.group APIs.\n// These methods shouldn't involve network I/O.\nvar apiActions = {\n    set_action: function(prop, to) {\n        var data = {};\n        var $set = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set[k] = v;\n                }\n            }, this);\n        } else {\n            $set[prop] = to;\n        }\n\n        data[SET_ACTION] = $set;\n        return data;\n    },\n\n    unset_action: function(prop) {\n        var data = {};\n        var $unset = [];\n        if (!_.isArray(prop)) {\n            prop = [prop];\n        }\n\n        _.each(prop, function(k) {\n            if (!this._is_reserved_property(k)) {\n                $unset.push(k);\n            }\n        }, this);\n\n        data[UNSET_ACTION] = $unset;\n        return data;\n    },\n\n    set_once_action: function(prop, to) {\n        var data = {};\n        var $set_once = {};\n        if (_.isObject(prop)) {\n            _.each(prop, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $set_once[k] = v;\n                }\n            }, this);\n        } else {\n            $set_once[prop] = to;\n        }\n        data[SET_ONCE_ACTION] = $set_once;\n        return data;\n    },\n\n    union_action: function(list_name, values) {\n        var data = {};\n        var $union = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $union[k] = _.isArray(v) ? v : [v];\n                }\n            }, this);\n        } else {\n            $union[list_name] = _.isArray(values) ? values : [values];\n        }\n        data[UNION_ACTION] = $union;\n        return data;\n    },\n\n    append_action: function(list_name, value) {\n        var data = {};\n        var $append = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $append[k] = v;\n                }\n            }, this);\n        } else {\n            $append[list_name] = value;\n        }\n        data[APPEND_ACTION] = $append;\n        return data;\n    },\n\n    remove_action: function(list_name, value) {\n        var data = {};\n        var $remove = {};\n        if (_.isObject(list_name)) {\n            _.each(list_name, function(v, k) {\n                if (!this._is_reserved_property(k)) {\n                    $remove[k] = v;\n                }\n            }, this);\n        } else {\n            $remove[list_name] = value;\n        }\n        data[REMOVE_ACTION] = $remove;\n        return data;\n    },\n\n    delete_action: function() {\n        var data = {};\n        data[DELETE_ACTION] = '';\n        return data;\n    }\n};\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel Group Object\n * @constructor\n */\nvar MixpanelGroup = function() {};\n\n_.extend(MixpanelGroup.prototype, apiActions);\n\nMixpanelGroup.prototype._init = function(mixpanel_instance, group_key, group_id) {\n    this._mixpanel = mixpanel_instance;\n    this._group_key = group_key;\n    this._group_id = group_id;\n};\n\n/**\n * Set properties on a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, dates, or lists\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Set properties on a group, only if they do not yet exist.\n * This will not overwrite previous group property values, unlike\n * group.set().\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').set_once('Location', '405 Howard');\n *\n *     // or set multiple properties at once\n *     mixpanel.get_group('company', 'mixpanel').set_once({\n *          'Location': '405 Howard',\n *          'Founded' : 2009,\n *     });\n *     // properties can be strings, integers, lists or dates\n *\n * @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n * @param {*} [to] A value to set on the given property name\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.set_once = addOptOutCheckMixpanelGroup(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/**\n * Unset properties on a group permanently.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').unset('Founded');\n *\n * @param {String} prop The name of the property.\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.unset = addOptOutCheckMixpanelGroup(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/**\n * Merge a given list with a list-valued group property, excluding duplicate values.\n *\n * ### Usage:\n *\n *     // merge a value to a list, creating it if needed\n *     mixpanel.get_group('company', 'mixpanel').union('Location', ['San Francisco', 'London']);\n *\n * @param {String} list_name Name of the property.\n * @param {Array} values Values to merge with the given property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.union = addOptOutCheckMixpanelGroup(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/**\n * Permanently delete a group.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').delete();\n *\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype['delete'] = addOptOutCheckMixpanelGroup(function(callback) {\n    // bracket notation above prevents a minification error related to reserved words\n    var data = this.delete_action();\n    return this._send_request(data, callback);\n});\n\n/**\n * Remove a property from a group. The value will be ignored if doesn't exist.\n *\n * ### Usage:\n *\n *     mixpanel.get_group('company', 'mixpanel').remove('Location', 'London');\n *\n * @param {String} list_name Name of the property.\n * @param {Object} value Value to remove from the given group property\n * @param {Function} [callback] If provided, the callback will be called after the tracking event\n */\nMixpanelGroup.prototype.remove = addOptOutCheckMixpanelGroup(function(list_name, value, callback) {\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\nMixpanelGroup.prototype._send_request = function(data, callback) {\n    data['$group_key'] = this._group_key;\n    data['$group_id'] = this._group_id;\n    data['$token'] = this._get_config('token');\n\n    var date_encoded_data = _.encodeDates(data);\n    return this._mixpanel._track_or_batch({\n        type: 'groups',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['groups'],\n        batcher: this._mixpanel.request_batchers.groups\n    }, callback);\n};\n\nMixpanelGroup.prototype._is_reserved_property = function(prop) {\n    return prop === '$group_key' || prop === '$group_id';\n};\n\nMixpanelGroup.prototype._get_config = function(conf) {\n    return this._mixpanel.get_config(conf);\n};\n\nMixpanelGroup.prototype.toString = function() {\n    return this._mixpanel.toString() + '.group.' + this._group_key + '.' + this._group_id;\n};\n\n// MixpanelGroup Exports\nMixpanelGroup.prototype['remove']   = MixpanelGroup.prototype.remove;\nMixpanelGroup.prototype['set']      = MixpanelGroup.prototype.set;\nMixpanelGroup.prototype['set_once'] = MixpanelGroup.prototype.set_once;\nMixpanelGroup.prototype['union']    = MixpanelGroup.prototype.union;\nMixpanelGroup.prototype['unset']    = MixpanelGroup.prototype.unset;\nMixpanelGroup.prototype['toString'] = MixpanelGroup.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/**\n * Mixpanel People Object\n * @constructor\n */\nvar MixpanelPeople = function() {};\n\n_.extend(MixpanelPeople.prototype, apiActions);\n\nMixpanelPeople.prototype._init = function(mixpanel_instance) {\n    this._mixpanel = mixpanel_instance;\n};\n\n/*\n* Set properties on a user record.\n*\n* ### Usage:\n*\n*     mixpanel.people.set('gender', 'm');\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set({\n*         'Company': 'Acme',\n*         'Plan': 'Premium',\n*         'Upgrade date': new Date()\n*     });\n*     // properties can be strings, integers, dates, or lists\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    // make sure that the referrer info has been updated and saved\n    if (this._get_config('save_referrer')) {\n        this._mixpanel['persistence'].update_referrer_info(document.referrer);\n    }\n\n    // update $set object with default people properties\n    data[SET_ACTION] = _.extend(\n        {},\n        _.info.people_properties(),\n        data[SET_ACTION]\n    );\n    return this._send_request(data, callback);\n});\n\n/*\n* Set properties on a user record, only if they do not yet exist.\n* This will not overwrite previous people property values, unlike\n* people.set().\n*\n* ### Usage:\n*\n*     mixpanel.people.set_once('First Login Date', new Date());\n*\n*     // or set multiple properties at once\n*     mixpanel.people.set_once({\n*         'First Login Date': new Date(),\n*         'Starting Plan': 'Premium'\n*     });\n*\n*     // properties can be strings, integers or dates\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [to] A value to set on the given property name\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.set_once = addOptOutCheckMixpanelPeople(function(prop, to, callback) {\n    var data = this.set_once_action(prop, to);\n    if (_.isObject(prop)) {\n        callback = to;\n    }\n    return this._send_request(data, callback);\n});\n\n/*\n* Unset properties on a user record (permanently removes the properties and their values from a profile).\n*\n* ### Usage:\n*\n*     mixpanel.people.unset('gender');\n*\n*     // or unset multiple properties at once\n*     mixpanel.people.unset(['gender', 'Company']);\n*\n* @param {Array|String} prop If a string, this is the name of the property. If an array, this is a list of property names.\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.unset = addOptOutCheckMixpanelPeople(function(prop, callback) {\n    var data = this.unset_action(prop);\n    return this._send_request(data, callback);\n});\n\n/*\n* Increment/decrement numeric people analytics properties.\n*\n* ### Usage:\n*\n*     mixpanel.people.increment('page_views', 1);\n*\n*     // or, for convenience, if you're just incrementing a counter by\n*     // 1, you can simply do\n*     mixpanel.people.increment('page_views');\n*\n*     // to decrement a counter, pass a negative number\n*     mixpanel.people.increment('credits_left', -1);\n*\n*     // like mixpanel.people.set(), you can increment multiple\n*     // properties at once:\n*     mixpanel.people.increment({\n*         counter1: 1,\n*         counter2: 6\n*     });\n*\n* @param {Object|String} prop If a string, this is the name of the property. If an object, this is an associative array of names and numeric values.\n* @param {Number} [by] An amount to increment the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.increment = addOptOutCheckMixpanelPeople(function(prop, by, callback) {\n    var data = {};\n    var $add = {};\n    if (_.isObject(prop)) {\n        _.each(prop, function(v, k) {\n            if (!this._is_reserved_property(k)) {\n                if (isNaN(parseFloat(v))) {\n                    console$1.error('Invalid increment value passed to mixpanel.people.increment - must be a number');\n                    return;\n                } else {\n                    $add[k] = v;\n                }\n            }\n        }, this);\n        callback = by;\n    } else {\n        // convenience: mixpanel.people.increment('property'); will\n        // increment 'property' by 1\n        if (_.isUndefined(by)) {\n            by = 1;\n        }\n        $add[prop] = by;\n    }\n    data[ADD_ACTION] = $add;\n\n    return this._send_request(data, callback);\n});\n\n/*\n* Append a value to a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     // append a value to a list, creating it if needed\n*     mixpanel.people.append('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.append({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value An item to append to the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.append = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.append_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Remove a value from a list-valued people analytics property.\n*\n* ### Usage:\n*\n*     mixpanel.people.remove('School', 'UCB');\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] value Item to remove from the list\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.remove = addOptOutCheckMixpanelPeople(function(list_name, value, callback) {\n    if (_.isObject(list_name)) {\n        callback = value;\n    }\n    var data = this.remove_action(list_name, value);\n    return this._send_request(data, callback);\n});\n\n/*\n* Merge a given list with a list-valued people analytics property,\n* excluding duplicate values.\n*\n* ### Usage:\n*\n*     // merge a value to a list, creating it if needed\n*     mixpanel.people.union('pages_visited', 'homepage');\n*\n*     // like mixpanel.people.set(), you can append multiple\n*     // properties at once:\n*     mixpanel.people.union({\n*         list1: 'bob',\n*         list2: 123\n*     });\n*\n*     // like mixpanel.people.append(), you can append multiple\n*     // values to the same list:\n*     mixpanel.people.union({\n*         list1: ['bob', 'billy']\n*     });\n*\n* @param {Object|String} list_name If a string, this is the name of the property. If an object, this is an associative array of names and values.\n* @param {*} [value] Value / values to merge with the given property\n* @param {Function} [callback] If provided, the callback will be called after tracking the event.\n*/\nMixpanelPeople.prototype.union = addOptOutCheckMixpanelPeople(function(list_name, values, callback) {\n    if (_.isObject(list_name)) {\n        callback = values;\n    }\n    var data = this.union_action(list_name, values);\n    return this._send_request(data, callback);\n});\n\n/*\n * Record that you have charged the current user a certain amount\n * of money. Charges recorded with track_charge() will appear in the\n * Mixpanel revenue report.\n *\n * ### Usage:\n *\n *     // charge a user $50\n *     mixpanel.people.track_charge(50);\n *\n *     // charge a user $30.50 on the 2nd of january\n *     mixpanel.people.track_charge(30.50, {\n *         '$time': new Date('jan 1 2012')\n *     });\n *\n * @param {Number} amount The amount of money charged to the current user\n * @param {Object} [properties] An associative array of properties associated with the charge\n * @param {Function} [callback] If provided, the callback will be called when the server responds\n * @deprecated\n */\nMixpanelPeople.prototype.track_charge = addOptOutCheckMixpanelPeople(function(amount, properties, callback) {\n    if (!_.isNumber(amount)) {\n        amount = parseFloat(amount);\n        if (isNaN(amount)) {\n            console$1.error('Invalid value passed to mixpanel.people.track_charge - must be a number');\n            return;\n        }\n    }\n\n    return this.append('$transactions', _.extend({\n        '$amount': amount\n    }, properties), callback);\n});\n\n/*\n * Permanently clear all revenue report transactions from the\n * current user's people analytics profile.\n *\n * ### Usage:\n *\n *     mixpanel.people.clear_charges();\n *\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n * @deprecated\n */\nMixpanelPeople.prototype.clear_charges = function(callback) {\n    return this.set('$transactions', [], callback);\n};\n\n/*\n* Permanently deletes the current people analytics profile from\n* Mixpanel (using the current distinct_id).\n*\n* ### Usage:\n*\n*     // remove the all data you have stored about the current user\n*     mixpanel.people.delete_user();\n*\n*/\nMixpanelPeople.prototype.delete_user = function() {\n    if (!this._identify_called()) {\n        console$1.error('mixpanel.people.delete_user() requires you to call identify() first');\n        return;\n    }\n    var data = {'$delete': this._mixpanel.get_distinct_id()};\n    return this._send_request(data);\n};\n\nMixpanelPeople.prototype.toString = function() {\n    return this._mixpanel.toString() + '.people';\n};\n\nMixpanelPeople.prototype._send_request = function(data, callback) {\n    data['$token'] = this._get_config('token');\n    data['$distinct_id'] = this._mixpanel.get_distinct_id();\n    var device_id = this._mixpanel.get_property('$device_id');\n    var user_id = this._mixpanel.get_property('$user_id');\n    var had_persisted_distinct_id = this._mixpanel.get_property('$had_persisted_distinct_id');\n    if (device_id) {\n        data['$device_id'] = device_id;\n    }\n    if (user_id) {\n        data['$user_id'] = user_id;\n    }\n    if (had_persisted_distinct_id) {\n        data['$had_persisted_distinct_id'] = had_persisted_distinct_id;\n    }\n\n    var date_encoded_data = _.encodeDates(data);\n\n    if (!this._identify_called()) {\n        this._enqueue(data);\n        if (!_.isUndefined(callback)) {\n            if (this._get_config('verbose')) {\n                callback({status: -1, error: null});\n            } else {\n                callback(-1);\n            }\n        }\n        return _.truncate(date_encoded_data, 255);\n    }\n\n    return this._mixpanel._track_or_batch({\n        type: 'people',\n        data: date_encoded_data,\n        endpoint: this._get_config('api_host') + '/' +  this._get_config('api_routes')['engage'],\n        batcher: this._mixpanel.request_batchers.people\n    }, callback);\n};\n\nMixpanelPeople.prototype._get_config = function(conf_var) {\n    return this._mixpanel.get_config(conf_var);\n};\n\nMixpanelPeople.prototype._identify_called = function() {\n    return this._mixpanel._flags.identify_called === true;\n};\n\n// Queue up engage operations if identify hasn't been called yet.\nMixpanelPeople.prototype._enqueue = function(data) {\n    if (SET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ACTION, data);\n    } else if (SET_ONCE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(SET_ONCE_ACTION, data);\n    } else if (UNSET_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNSET_ACTION, data);\n    } else if (ADD_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(ADD_ACTION, data);\n    } else if (APPEND_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, data);\n    } else if (REMOVE_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, data);\n    } else if (UNION_ACTION in data) {\n        this._mixpanel['persistence']._add_to_people_queue(UNION_ACTION, data);\n    } else {\n        console$1.error('Invalid call to _enqueue():', data);\n    }\n};\n\nMixpanelPeople.prototype._flush_one_queue = function(action, action_method, callback, queue_to_params_fn) {\n    var _this = this;\n    var queued_data = _.extend({}, this._mixpanel['persistence'].load_queue(action));\n    var action_params = queued_data;\n\n    if (!_.isUndefined(queued_data) && _.isObject(queued_data) && !_.isEmptyObject(queued_data)) {\n        _this._mixpanel['persistence']._pop_from_people_queue(action, queued_data);\n        _this._mixpanel['persistence'].save();\n        if (queue_to_params_fn) {\n            action_params = queue_to_params_fn(queued_data);\n        }\n        action_method.call(_this, action_params, function(response, data) {\n            // on bad response, we want to add it back to the queue\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(action, queued_data);\n            }\n            if (!_.isUndefined(callback)) {\n                callback(response, data);\n            }\n        });\n    }\n};\n\n// Flush queued engage operations - order does not matter,\n// and there are network level race conditions anyway\nMixpanelPeople.prototype._flush = function(\n    _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    var _this = this;\n\n    this._flush_one_queue(SET_ACTION, this.set, _set_callback);\n    this._flush_one_queue(SET_ONCE_ACTION, this.set_once, _set_once_callback);\n    this._flush_one_queue(UNSET_ACTION, this.unset, _unset_callback, function(queue) { return _.keys(queue); });\n    this._flush_one_queue(ADD_ACTION, this.increment, _add_callback);\n    this._flush_one_queue(UNION_ACTION, this.union, _union_callback);\n\n    // we have to fire off each $append individually since there is\n    // no concat method server side\n    var $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n    if (!_.isUndefined($append_queue) && _.isArray($append_queue) && $append_queue.length) {\n        var $append_item;\n        var append_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(APPEND_ACTION, $append_item);\n            }\n            if (!_.isUndefined(_append_callback)) {\n                _append_callback(response, data);\n            }\n        };\n        for (var i = $append_queue.length - 1; i >= 0; i--) {\n            $append_queue = this._mixpanel['persistence'].load_queue(APPEND_ACTION);\n            $append_item = $append_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($append_item)) {\n                _this.append($append_item, append_callback);\n            }\n        }\n    }\n\n    // same for $remove\n    var $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n    if (!_.isUndefined($remove_queue) && _.isArray($remove_queue) && $remove_queue.length) {\n        var $remove_item;\n        var remove_callback = function(response, data) {\n            if (response === 0) {\n                _this._mixpanel['persistence']._add_to_people_queue(REMOVE_ACTION, $remove_item);\n            }\n            if (!_.isUndefined(_remove_callback)) {\n                _remove_callback(response, data);\n            }\n        };\n        for (var j = $remove_queue.length - 1; j >= 0; j--) {\n            $remove_queue = this._mixpanel['persistence'].load_queue(REMOVE_ACTION);\n            $remove_item = $remove_queue.pop();\n            _this._mixpanel['persistence'].save();\n            if (!_.isEmptyObject($remove_item)) {\n                _this.remove($remove_item, remove_callback);\n            }\n        }\n    }\n};\n\nMixpanelPeople.prototype._is_reserved_property = function(prop) {\n    return prop === '$distinct_id' || prop === '$token' || prop === '$device_id' || prop === '$user_id' || prop === '$had_persisted_distinct_id';\n};\n\n// MixpanelPeople Exports\nMixpanelPeople.prototype['set']           = MixpanelPeople.prototype.set;\nMixpanelPeople.prototype['set_once']      = MixpanelPeople.prototype.set_once;\nMixpanelPeople.prototype['unset']         = MixpanelPeople.prototype.unset;\nMixpanelPeople.prototype['increment']     = MixpanelPeople.prototype.increment;\nMixpanelPeople.prototype['append']        = MixpanelPeople.prototype.append;\nMixpanelPeople.prototype['remove']        = MixpanelPeople.prototype.remove;\nMixpanelPeople.prototype['union']         = MixpanelPeople.prototype.union;\nMixpanelPeople.prototype['track_charge']  = MixpanelPeople.prototype.track_charge;\nMixpanelPeople.prototype['clear_charges'] = MixpanelPeople.prototype.clear_charges;\nMixpanelPeople.prototype['delete_user']   = MixpanelPeople.prototype.delete_user;\nMixpanelPeople.prototype['toString']      = MixpanelPeople.prototype.toString;\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Constants\n */\n/** @const */ var SET_QUEUE_KEY          = '__mps';\n/** @const */ var SET_ONCE_QUEUE_KEY     = '__mpso';\n/** @const */ var UNSET_QUEUE_KEY        = '__mpus';\n/** @const */ var ADD_QUEUE_KEY          = '__mpa';\n/** @const */ var APPEND_QUEUE_KEY       = '__mpap';\n/** @const */ var REMOVE_QUEUE_KEY       = '__mpr';\n/** @const */ var UNION_QUEUE_KEY        = '__mpu';\n// This key is deprecated, but we want to check for it to see whether aliasing is allowed.\n/** @const */ var PEOPLE_DISTINCT_ID_KEY = '$people_distinct_id';\n/** @const */ var ALIAS_ID_KEY           = '__alias';\n/** @const */ var EVENT_TIMERS_KEY       = '__timers';\n/** @const */ var RESERVED_PROPERTIES = [\n    SET_QUEUE_KEY,\n    SET_ONCE_QUEUE_KEY,\n    UNSET_QUEUE_KEY,\n    ADD_QUEUE_KEY,\n    APPEND_QUEUE_KEY,\n    REMOVE_QUEUE_KEY,\n    UNION_QUEUE_KEY,\n    PEOPLE_DISTINCT_ID_KEY,\n    ALIAS_ID_KEY,\n    EVENT_TIMERS_KEY\n];\n\n/**\n * Mixpanel Persistence Object\n * @constructor\n */\nvar MixpanelPersistence = function(config) {\n    this['props'] = {};\n    this.campaign_params_saved = false;\n\n    if (config['persistence_name']) {\n        this.name = 'mp_' + config['persistence_name'];\n    } else {\n        this.name = 'mp_' + config['token'] + '_mixpanel';\n    }\n\n    var storage_type = config['persistence'];\n    if (storage_type !== 'cookie' && storage_type !== 'localStorage') {\n        console$1.critical('Unknown persistence type ' + storage_type + '; falling back to cookie');\n        storage_type = config['persistence'] = 'cookie';\n    }\n\n    if (storage_type === 'localStorage' && _.localStorage.is_supported()) {\n        this.storage = _.localStorage;\n    } else {\n        this.storage = _.cookie;\n    }\n\n    this.load();\n    this.update_config(config);\n    this.upgrade();\n    this.save();\n};\n\nMixpanelPersistence.prototype.properties = function() {\n    var p = {};\n\n    this.load();\n\n    // Filter out reserved properties\n    _.each(this['props'], function(v, k) {\n        if (!_.include(RESERVED_PROPERTIES, k)) {\n            p[k] = v;\n        }\n    });\n    return p;\n};\n\nMixpanelPersistence.prototype.load = function() {\n    if (this.disabled) { return; }\n\n    var entry = this.storage.parse(this.name);\n\n    if (entry) {\n        this['props'] = _.extend({}, entry);\n    }\n};\n\nMixpanelPersistence.prototype.upgrade = function() {\n    var old_cookie,\n        old_localstorage;\n\n    // if transferring from cookie to localStorage or vice-versa, copy existing\n    // super properties over to new storage mode\n    if (this.storage === _.localStorage) {\n        old_cookie = _.cookie.parse(this.name);\n\n        _.cookie.remove(this.name);\n        _.cookie.remove(this.name, true);\n\n        if (old_cookie) {\n            this.register_once(old_cookie);\n        }\n    } else if (this.storage === _.cookie) {\n        old_localstorage = _.localStorage.parse(this.name);\n\n        _.localStorage.remove(this.name);\n\n        if (old_localstorage) {\n            this.register_once(old_localstorage);\n        }\n    }\n};\n\nMixpanelPersistence.prototype.save = function() {\n    if (this.disabled) { return; }\n\n    this.storage.set(\n        this.name,\n        _.JSONEncode(this['props']),\n        this.expire_days,\n        this.cross_subdomain,\n        this.secure,\n        this.cross_site,\n        this.cookie_domain\n    );\n};\n\nMixpanelPersistence.prototype.load_prop = function(key) {\n    this.load();\n    return this['props'][key];\n};\n\nMixpanelPersistence.prototype.remove = function() {\n    // remove both domain and subdomain cookies\n    this.storage.remove(this.name, false, this.cookie_domain);\n    this.storage.remove(this.name, true, this.cookie_domain);\n};\n\n// removes the storage entry and deletes all loaded data\n// forced name for tests\nMixpanelPersistence.prototype.clear = function() {\n    this.remove();\n    this['props'] = {};\n};\n\n/**\n* @param {Object} props\n* @param {*=} default_value\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register_once = function(props, default_value, days) {\n    if (_.isObject(props)) {\n        if (typeof(default_value) === 'undefined') { default_value = 'None'; }\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n\n        _.each(props, function(val, prop) {\n            if (!this['props'].hasOwnProperty(prop) || this['props'][prop] === default_value) {\n                this['props'][prop] = val;\n            }\n        }, this);\n\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\n/**\n* @param {Object} props\n* @param {number=} days\n*/\nMixpanelPersistence.prototype.register = function(props, days) {\n    if (_.isObject(props)) {\n        this.expire_days = (typeof(days) === 'undefined') ? this.default_expiry : days;\n\n        this.load();\n        _.extend(this['props'], props);\n        this.save();\n\n        return true;\n    }\n    return false;\n};\n\nMixpanelPersistence.prototype.unregister = function(prop) {\n    this.load();\n    if (prop in this['props']) {\n        delete this['props'][prop];\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.update_search_keyword = function(referrer) {\n    this.register(_.info.searchInfo(referrer));\n};\n\n// EXPORTED METHOD, we test this directly.\nMixpanelPersistence.prototype.update_referrer_info = function(referrer) {\n    // If referrer doesn't exist, we want to note the fact that it was type-in traffic.\n    this.register_once({\n        '$initial_referrer': referrer || '$direct',\n        '$initial_referring_domain': _.info.referringDomain(referrer) || '$direct'\n    }, '');\n};\n\nMixpanelPersistence.prototype.get_referrer_info = function() {\n    return _.strip_empty_properties({\n        '$initial_referrer': this['props']['$initial_referrer'],\n        '$initial_referring_domain': this['props']['$initial_referring_domain']\n    });\n};\n\nMixpanelPersistence.prototype.update_config = function(config) {\n    this.default_expiry = this.expire_days = config['cookie_expiration'];\n    this.set_disabled(config['disable_persistence']);\n    this.set_cookie_domain(config['cookie_domain']);\n    this.set_cross_site(config['cross_site_cookie']);\n    this.set_cross_subdomain(config['cross_subdomain_cookie']);\n    this.set_secure(config['secure_cookie']);\n};\n\nMixpanelPersistence.prototype.set_disabled = function(disabled) {\n    this.disabled = disabled;\n    if (this.disabled) {\n        this.remove();\n    } else {\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cookie_domain = function(cookie_domain) {\n    if (cookie_domain !== this.cookie_domain) {\n        this.remove();\n        this.cookie_domain = cookie_domain;\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_site = function(cross_site) {\n    if (cross_site !== this.cross_site) {\n        this.cross_site = cross_site;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {\n    if (cross_subdomain !== this.cross_subdomain) {\n        this.cross_subdomain = cross_subdomain;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype.get_cross_subdomain = function() {\n    return this.cross_subdomain;\n};\n\nMixpanelPersistence.prototype.set_secure = function(secure) {\n    if (secure !== this.secure) {\n        this.secure = secure ? true : false;\n        this.remove();\n        this.save();\n    }\n};\n\nMixpanelPersistence.prototype._add_to_people_queue = function(queue, data) {\n    var q_key = this._get_queue_key(queue),\n        q_data = data[queue],\n        set_q = this._get_or_create_queue(SET_ACTION),\n        set_once_q = this._get_or_create_queue(SET_ONCE_ACTION),\n        unset_q = this._get_or_create_queue(UNSET_ACTION),\n        add_q = this._get_or_create_queue(ADD_ACTION),\n        union_q = this._get_or_create_queue(UNION_ACTION),\n        remove_q = this._get_or_create_queue(REMOVE_ACTION, []),\n        append_q = this._get_or_create_queue(APPEND_ACTION, []);\n\n    if (q_key === SET_QUEUE_KEY) {\n        // Update the set queue - we can override any existing values\n        _.extend(set_q, q_data);\n        // if there was a pending increment, override it\n        // with the set.\n        this._pop_from_people_queue(ADD_ACTION, q_data);\n        // if there was a pending union, override it\n        // with the set.\n        this._pop_from_people_queue(UNION_ACTION, q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === SET_ONCE_QUEUE_KEY) {\n        // only queue the data if there is not already a set_once call for it.\n        _.each(q_data, function(v, k) {\n            if (!(k in set_once_q)) {\n                set_once_q[k] = v;\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNSET_QUEUE_KEY) {\n        _.each(q_data, function(prop) {\n\n            // undo previously-queued actions on this key\n            _.each([set_q, set_once_q, add_q, union_q], function(enqueued_obj) {\n                if (prop in enqueued_obj) {\n                    delete enqueued_obj[prop];\n                }\n            });\n            _.each(append_q, function(append_obj) {\n                if (prop in append_obj) {\n                    delete append_obj[prop];\n                }\n            });\n\n            unset_q[prop] = true;\n\n        });\n    } else if (q_key === ADD_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            // If it exists in the set queue, increment\n            // the value\n            if (k in set_q) {\n                set_q[k] += v;\n            } else {\n                // If it doesn't exist, update the add\n                // queue\n                if (!(k in add_q)) {\n                    add_q[k] = 0;\n                }\n                add_q[k] += v;\n            }\n        }, this);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === UNION_QUEUE_KEY) {\n        _.each(q_data, function(v, k) {\n            if (_.isArray(v)) {\n                if (!(k in union_q)) {\n                    union_q[k] = [];\n                }\n                // We may send duplicates, the server will dedup them.\n                union_q[k] = union_q[k].concat(v);\n            }\n        });\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    } else if (q_key === REMOVE_QUEUE_KEY) {\n        remove_q.push(q_data);\n        this._pop_from_people_queue(APPEND_ACTION, q_data);\n    } else if (q_key === APPEND_QUEUE_KEY) {\n        append_q.push(q_data);\n        this._pop_from_people_queue(UNSET_ACTION, q_data);\n    }\n\n    console$1.log('MIXPANEL PEOPLE REQUEST (QUEUED, PENDING IDENTIFY):');\n    console$1.log(data);\n\n    this.save();\n};\n\nMixpanelPersistence.prototype._pop_from_people_queue = function(queue, data) {\n    var q = this['props'][this._get_queue_key(queue)];\n    if (!_.isUndefined(q)) {\n        _.each(data, function(v, k) {\n            if (queue === APPEND_ACTION || queue === REMOVE_ACTION) {\n                // list actions: only remove if both k+v match\n                // e.g. remove should not override append in a case like\n                // append({foo: 'bar'}); remove({foo: 'qux'})\n                _.each(q, function(queued_action) {\n                    if (queued_action[k] === v) {\n                        delete queued_action[k];\n                    }\n                });\n            } else {\n                delete q[k];\n            }\n        }, this);\n    }\n};\n\nMixpanelPersistence.prototype.load_queue = function(queue) {\n    return this.load_prop(this._get_queue_key(queue));\n};\n\nMixpanelPersistence.prototype._get_queue_key = function(queue) {\n    if (queue === SET_ACTION) {\n        return SET_QUEUE_KEY;\n    } else if (queue === SET_ONCE_ACTION) {\n        return SET_ONCE_QUEUE_KEY;\n    } else if (queue === UNSET_ACTION) {\n        return UNSET_QUEUE_KEY;\n    } else if (queue === ADD_ACTION) {\n        return ADD_QUEUE_KEY;\n    } else if (queue === APPEND_ACTION) {\n        return APPEND_QUEUE_KEY;\n    } else if (queue === REMOVE_ACTION) {\n        return REMOVE_QUEUE_KEY;\n    } else if (queue === UNION_ACTION) {\n        return UNION_QUEUE_KEY;\n    } else {\n        console$1.error('Invalid queue:', queue);\n    }\n};\n\nMixpanelPersistence.prototype._get_or_create_queue = function(queue, default_val) {\n    var key = this._get_queue_key(queue);\n    default_val = _.isUndefined(default_val) ? {} : default_val;\n    return this['props'][key] || (this['props'][key] = default_val);\n};\n\nMixpanelPersistence.prototype.set_event_timer = function(event_name, timestamp) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    timers[event_name] = timestamp;\n    this['props'][EVENT_TIMERS_KEY] = timers;\n    this.save();\n};\n\nMixpanelPersistence.prototype.remove_event_timer = function(event_name) {\n    var timers = this.load_prop(EVENT_TIMERS_KEY) || {};\n    var timestamp = timers[event_name];\n    if (!_.isUndefined(timestamp)) {\n        delete this['props'][EVENT_TIMERS_KEY][event_name];\n        this.save();\n    }\n    return timestamp;\n};\n\n/* eslint camelcase: \"off\" */\n\n/*\n * Mixpanel JS Library\n *\n * Copyright 2012, Mixpanel, Inc. All Rights Reserved\n * http://mixpanel.com/\n *\n * Includes portions of Underscore.js\n * http://documentcloud.github.com/underscore/\n * (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n * Released under the MIT License.\n */\n\n// ==ClosureCompiler==\n// @compilation_level ADVANCED_OPTIMIZATIONS\n// @output_file_name mixpanel-2.8.min.js\n// ==/ClosureCompiler==\n\n/*\nSIMPLE STYLE GUIDE:\n\nthis.x === public function\nthis._x === internal - only use within this file\nthis.__x === private - only use within the class\n\nGlobals should be all caps\n*/\n\nvar init_type;       // MODULE or SNIPPET loader\n// allow bundlers to specify how extra code (recorder bundle) should be loaded\n// eslint-disable-next-line no-unused-vars\nvar load_extra_bundle = function(src, _onload) {\n    throw new Error(src + ' not available in this build.');\n};\n\nvar mixpanel_master; // main mixpanel instance / object\nvar INIT_MODULE  = 0;\nvar INIT_SNIPPET = 1;\n\nvar IDENTITY_FUNC = function(x) {return x;};\nvar NOOP_FUNC = function() {};\n\n/** @const */ var PRIMARY_INSTANCE_NAME = 'mixpanel';\n/** @const */ var PAYLOAD_TYPE_BASE64   = 'base64';\n/** @const */ var PAYLOAD_TYPE_JSON     = 'json';\n/** @const */ var DEVICE_ID_PREFIX      = '$device:';\n\n\n/*\n * Dynamic... constants? Is that an oxymoron?\n */\n// http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/\n// https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#withCredentials\nvar USE_XHR = (win.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest());\n\n// IE<10 does not support cross-origin XHR's but script tags\n// with defer won't block window.onload; ENQUEUE_REQUESTS\n// should only be true for Opera<12\nvar ENQUEUE_REQUESTS = !USE_XHR && (userAgent.indexOf('MSIE') === -1) && (userAgent.indexOf('Mozilla') === -1);\n\n// save reference to navigator.sendBeacon so it can be minified\nvar sendBeacon = null;\nif (navigator['sendBeacon']) {\n    sendBeacon = function() {\n        // late reference to navigator.sendBeacon to allow patching/spying\n        return navigator['sendBeacon'].apply(navigator, arguments);\n    };\n}\n\nvar DEFAULT_API_ROUTES = {\n    'track': 'track/',\n    'engage': 'engage/',\n    'groups': 'groups/',\n    'record': 'record/'\n};\n\n/*\n * Module-level globals\n */\nvar DEFAULT_CONFIG = {\n    'api_host':                          'https://api-js.mixpanel.com',\n    'api_routes':                        DEFAULT_API_ROUTES,\n    'api_method':                        'POST',\n    'api_transport':                     'XHR',\n    'api_payload_format':                PAYLOAD_TYPE_BASE64,\n    'app_host':                          'https://mixpanel.com',\n    'cdn':                               'https://cdn.mxpnl.com',\n    'cross_site_cookie':                 false,\n    'cross_subdomain_cookie':            true,\n    'error_reporter':                    NOOP_FUNC,\n    'persistence':                       'cookie',\n    'persistence_name':                  '',\n    'cookie_domain':                     '',\n    'cookie_name':                       '',\n    'loaded':                            NOOP_FUNC,\n    'mp_loader':                         null,\n    'track_marketing':                   true,\n    'track_pageview':                    false,\n    'skip_first_touch_marketing':        false,\n    'store_google':                      true,\n    'stop_utm_persistence':              false,\n    'save_referrer':                     true,\n    'test':                              false,\n    'verbose':                           false,\n    'img':                               false,\n    'debug':                             false,\n    'track_links_timeout':               300,\n    'cookie_expiration':                 365,\n    'upgrade':                           false,\n    'disable_persistence':               false,\n    'disable_cookie':                    false,\n    'secure_cookie':                     false,\n    'ip':                                true,\n    'opt_out_tracking_by_default':       false,\n    'opt_out_persistence_by_default':    false,\n    'opt_out_tracking_persistence_type': 'localStorage',\n    'opt_out_tracking_cookie_prefix':    null,\n    'property_blacklist':                [],\n    'xhr_headers':                       {}, // { header: value, header2: value }\n    'ignore_dnt':                        false,\n    'batch_requests':                    true,\n    'batch_size':                        50,\n    'batch_flush_interval_ms':           5000,\n    'batch_request_timeout_ms':          90000,\n    'batch_autostart':                   true,\n    'hooks':                             {},\n    'record_block_class':                new RegExp('^(mp-block|fs-exclude|amp-block|rr-block|ph-no-capture)$'),\n    'record_block_selector':             'img, video',\n    'record_canvas':                     false,\n    'record_collect_fonts':              false,\n    'record_idle_timeout_ms':            30 * 60 * 1000, // 30 minutes\n    'record_mask_text_class':            new RegExp('^(mp-mask|fs-mask|amp-mask|rr-mask|ph-mask)$'),\n    'record_mask_text_selector':         '*',\n    'record_max_ms':                     MAX_RECORDING_MS,\n    'record_min_ms':                     0,\n    'record_sessions_percent':           0,\n    'recorder_src':                      'https://cdn.mxpnl.com/libs/mixpanel-recorder.min.js'\n};\n\nvar DOM_LOADED = false;\n\n/**\n * Mixpanel Library Object\n * @constructor\n */\nvar MixpanelLib = function() {};\n\n\n/**\n * create_mplib(token:string, config:object, name:string)\n *\n * This function is used by the init method of MixpanelLib objects\n * as well as the main initializer at the end of the JSLib (that\n * initializes document.mixpanel as well as any additional instances\n * declared before this file has loaded).\n */\nvar create_mplib = function(token, config, name) {\n    var instance,\n        target = (name === PRIMARY_INSTANCE_NAME) ? mixpanel_master : mixpanel_master[name];\n\n    if (target && init_type === INIT_MODULE) {\n        instance = target;\n    } else {\n        if (target && !_.isArray(target)) {\n            console$1.error('You have already initialized ' + name);\n            return;\n        }\n        instance = new MixpanelLib();\n    }\n\n    instance._cached_groups = {}; // cache groups in a pool\n\n    instance._init(token, config, name);\n\n    instance['people'] = new MixpanelPeople();\n    instance['people']._init(instance);\n\n    if (!instance.get_config('skip_first_touch_marketing')) {\n        // We need null UTM params in the object because\n        // UTM parameters act as a tuple. If any UTM param\n        // is present, then we set all UTM params including\n        // empty ones together\n        var utm_params = _.info.campaignParams(null);\n        var initial_utm_params = {};\n        var has_utm = false;\n        _.each(utm_params, function(utm_value, utm_key) {\n            initial_utm_params['initial_' + utm_key] = utm_value;\n            if (utm_value) {\n                has_utm = true;\n            }\n        });\n        if (has_utm) {\n            instance['people'].set_once(initial_utm_params);\n        }\n    }\n\n    // if any instance on the page has debug = true, we set the\n    // global debug to be true\n    Config.DEBUG = Config.DEBUG || instance.get_config('debug');\n\n    // if target is not defined, we called init after the lib already\n    // loaded, so there won't be an array of things to execute\n    if (!_.isUndefined(target) && _.isArray(target)) {\n        // Crunch through the people queue first - we queue this data up &\n        // flush on identify, so it's better to do all these operations first\n        instance._execute_array.call(instance['people'], target['people']);\n        instance._execute_array(target);\n    }\n\n    return instance;\n};\n\n// Initialization methods\n\n/**\n * This function initializes a new instance of the Mixpanel tracking object.\n * All new instances are added to the main mixpanel object as sub properties (such as\n * mixpanel.library_name) and also returned by this function. To define a\n * second instance on the page, you would call:\n *\n *     mixpanel.init('new token', { your: 'config' }, 'library_name');\n *\n * and use it like so:\n *\n *     mixpanel.library_name.track(...);\n *\n * @param {String} token   Your Mixpanel API token\n * @param {Object} [config]  A dictionary of config options to override. <a href=\"https://github.com/mixpanel/mixpanel-js/blob/v2.46.0/src/mixpanel-core.js#L88-L127\">See a list of default config options</a>.\n * @param {String} [name]    The name for the new mixpanel instance that you want created\n */\nMixpanelLib.prototype.init = function (token, config, name) {\n    if (_.isUndefined(name)) {\n        this.report_error('You must name your new library: init(token, config, name)');\n        return;\n    }\n    if (name === PRIMARY_INSTANCE_NAME) {\n        this.report_error('You must initialize the main mixpanel object right after you include the Mixpanel js snippet');\n        return;\n    }\n\n    var instance = create_mplib(token, config, name);\n    mixpanel_master[name] = instance;\n    instance._loaded();\n\n    return instance;\n};\n\n// mixpanel._init(token:string, config:object, name:string)\n//\n// This function sets up the current instance of the mixpanel\n// library.  The difference between this method and the init(...)\n// method is this one initializes the actual instance, whereas the\n// init(...) method sets up a new library and calls _init on it.\n//\nMixpanelLib.prototype._init = function(token, config, name) {\n    config = config || {};\n\n    this['__loaded'] = true;\n    this['config'] = {};\n\n    var variable_features = {};\n\n    // default to JSON payload for standard mixpanel.com API hosts\n    if (!('api_payload_format' in config)) {\n        var api_host = config['api_host'] || DEFAULT_CONFIG['api_host'];\n        if (api_host.match(/\\.mixpanel\\.com/)) {\n            variable_features['api_payload_format'] = PAYLOAD_TYPE_JSON;\n        }\n    }\n\n    this.set_config(_.extend({}, DEFAULT_CONFIG, variable_features, config, {\n        'name': name,\n        'token': token,\n        'callback_fn': ((name === PRIMARY_INSTANCE_NAME) ? name : PRIMARY_INSTANCE_NAME + '.' + name) + '._jsc'\n    }));\n\n    this['_jsc'] = NOOP_FUNC;\n\n    this.__dom_loaded_queue = [];\n    this.__request_queue = [];\n    this.__disabled_events = [];\n    this._flags = {\n        'disable_all_events': false,\n        'identify_called': false\n    };\n\n    // set up request queueing/batching\n    this.request_batchers = {};\n    this._batch_requests = this.get_config('batch_requests');\n    if (this._batch_requests) {\n        if (!_.localStorage.is_supported(true) || !USE_XHR) {\n            this._batch_requests = false;\n            console$1.log('Turning off Mixpanel request-queueing; needs XHR and localStorage support');\n            _.each(this.get_batcher_configs(), function(batcher_config) {\n                console$1.log('Clearing batch queue ' + batcher_config.queue_key);\n                _.localStorage.remove(batcher_config.queue_key);\n            });\n        } else {\n            this.init_batchers();\n            if (sendBeacon && win.addEventListener) {\n                // Before page closes or hides (user tabs away etc), attempt to flush any events\n                // queued up via navigator.sendBeacon. Since sendBeacon doesn't report success/failure,\n                // events will not be removed from the persistent store; if the site is loaded again,\n                // the events will be flushed again on startup and deduplicated on the Mixpanel server\n                // side.\n                // There is no reliable way to capture only page close events, so we lean on the\n                // visibilitychange and pagehide events as recommended at\n                // https://developer.mozilla.org/en-US/docs/Web/API/Window/unload_event#usage_notes.\n                // These events fire when the user clicks away from the current page/tab, so will occur\n                // more frequently than page unload, but are the only mechanism currently for capturing\n                // this scenario somewhat reliably.\n                var flush_on_unload = _.bind(function() {\n                    if (!this.request_batchers.events.stopped) {\n                        this.request_batchers.events.flush({unloading: true});\n                    }\n                }, this);\n                win.addEventListener('pagehide', function(ev) {\n                    if (ev['persisted']) {\n                        flush_on_unload();\n                    }\n                });\n                win.addEventListener('visibilitychange', function() {\n                    if (document$1['visibilityState'] === 'hidden') {\n                        flush_on_unload();\n                    }\n                });\n            }\n        }\n    }\n\n    this['persistence'] = this['cookie'] = new MixpanelPersistence(this['config']);\n    this.unpersisted_superprops = {};\n    this._gdpr_init();\n\n    var uuid = _.UUID();\n    if (!this.get_distinct_id()) {\n        // There is no need to set the distinct id\n        // or the device id if something was already stored\n        // in the persitence\n        this.register_once({\n            'distinct_id': DEVICE_ID_PREFIX + uuid,\n            '$device_id': uuid\n        }, '');\n    }\n\n    var track_pageview_option = this.get_config('track_pageview');\n    if (track_pageview_option) {\n        this._init_url_change_tracking(track_pageview_option);\n    }\n\n    if (this.get_config('record_sessions_percent') > 0 && Math.random() * 100 <= this.get_config('record_sessions_percent')) {\n        this.start_session_recording();\n    }\n};\n\nMixpanelLib.prototype.start_session_recording = addOptOutCheckMixpanelLib(function () {\n    if (!win['MutationObserver']) {\n        console$1.critical('Browser does not support MutationObserver; skipping session recording');\n        return;\n    }\n\n    var handleLoadedRecorder = _.bind(function() {\n        this._recorder = this._recorder || new win['__mp_recorder'](this);\n        this._recorder['startRecording']();\n    }, this);\n\n    if (_.isUndefined(win['__mp_recorder'])) {\n        load_extra_bundle(this.get_config('recorder_src'), handleLoadedRecorder);\n    } else {\n        handleLoadedRecorder();\n    }\n});\n\nMixpanelLib.prototype.stop_session_recording = function () {\n    if (this._recorder) {\n        this._recorder['stopRecording']();\n    } else {\n        console$1.critical('Session recorder module not loaded');\n    }\n};\n\nMixpanelLib.prototype.get_session_recording_properties = function () {\n    var props = {};\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        props['$mp_replay_id'] = replay_id;\n    }\n    return props;\n};\n\nMixpanelLib.prototype.get_session_replay_url = function () {\n    var replay_url = null;\n    var replay_id = this._get_session_replay_id();\n    if (replay_id) {\n        var query_params = _.HTTPBuildQuery({\n            'replay_id': replay_id,\n            'distinct_id': this.get_distinct_id(),\n            'token': this.get_config('token')\n        });\n        replay_url = 'https://mixpanel.com/projects/replay-redirect?' + query_params;\n    }\n    return replay_url;\n};\n\nMixpanelLib.prototype._get_session_replay_id = function () {\n    var replay_id = null;\n    if (this._recorder) {\n        replay_id = this._recorder['replayId'];\n    }\n    return replay_id || null;\n};\n\n// Private methods\n\nMixpanelLib.prototype._loaded = function() {\n    this.get_config('loaded')(this);\n    this._set_default_superprops();\n    this['people'].set_once(this['persistence'].get_referrer_info());\n\n    // `store_google` is now deprecated and previously stored UTM parameters are cleared\n    // from persistence by default.\n    if (this.get_config('store_google') && this.get_config('stop_utm_persistence')) {\n        var utm_params = _.info.campaignParams(null);\n        _.each(utm_params, function(_utm_value, utm_key) {\n            // We need to unregister persisted UTM parameters so old values\n            // are not mixed with the new UTM parameters\n            this.unregister(utm_key);\n        }.bind(this));\n    }\n};\n\n// update persistence with info on referrer, UTM params, etc\nMixpanelLib.prototype._set_default_superprops = function() {\n    this['persistence'].update_search_keyword(document$1.referrer);\n    // Registering super properties for UTM persistence by 'store_google' is deprecated.\n    if (this.get_config('store_google') && !this.get_config('stop_utm_persistence')) {\n        this.register(_.info.campaignParams());\n    }\n    if (this.get_config('save_referrer')) {\n        this['persistence'].update_referrer_info(document$1.referrer);\n    }\n};\n\nMixpanelLib.prototype._dom_loaded = function() {\n    _.each(this.__dom_loaded_queue, function(item) {\n        this._track_dom.apply(this, item);\n    }, this);\n\n    if (!this.has_opted_out_tracking()) {\n        _.each(this.__request_queue, function(item) {\n            this._send_request.apply(this, item);\n        }, this);\n    }\n\n    delete this.__dom_loaded_queue;\n    delete this.__request_queue;\n};\n\nMixpanelLib.prototype._track_dom = function(DomClass, args) {\n    if (this.get_config('img')) {\n        this.report_error('You can\\'t use DOM tracking functions with img = true.');\n        return false;\n    }\n\n    if (!DOM_LOADED) {\n        this.__dom_loaded_queue.push([DomClass, args]);\n        return false;\n    }\n\n    var dt = new DomClass().init(this);\n    return dt.track.apply(dt, args);\n};\n\nMixpanelLib.prototype._init_url_change_tracking = function(track_pageview_option) {\n    var previous_tracked_url = '';\n    var tracked = this.track_pageview();\n    if (tracked) {\n        previous_tracked_url = _.info.currentUrl();\n    }\n\n    if (_.include(['full-url', 'url-with-path-and-query-string', 'url-with-path'], track_pageview_option)) {\n        win.addEventListener('popstate', function() {\n            win.dispatchEvent(new Event('mp_locationchange'));\n        });\n        win.addEventListener('hashchange', function() {\n            win.dispatchEvent(new Event('mp_locationchange'));\n        });\n        var nativePushState = win.history.pushState;\n        if (typeof nativePushState === 'function') {\n            win.history.pushState = function(state, unused, url) {\n                nativePushState.call(win.history, state, unused, url);\n                win.dispatchEvent(new Event('mp_locationchange'));\n            };\n        }\n        var nativeReplaceState = win.history.replaceState;\n        if (typeof nativeReplaceState === 'function') {\n            win.history.replaceState = function(state, unused, url) {\n                nativeReplaceState.call(win.history, state, unused, url);\n                win.dispatchEvent(new Event('mp_locationchange'));\n            };\n        }\n        win.addEventListener('mp_locationchange', function() {\n            var current_url = _.info.currentUrl();\n            var should_track = false;\n            if (track_pageview_option === 'full-url') {\n                should_track = current_url !== previous_tracked_url;\n            } else if (track_pageview_option === 'url-with-path-and-query-string') {\n                should_track = current_url.split('#')[0] !== previous_tracked_url.split('#')[0];\n            } else if (track_pageview_option === 'url-with-path') {\n                should_track = current_url.split('#')[0].split('?')[0] !== previous_tracked_url.split('#')[0].split('?')[0];\n            }\n\n            if (should_track) {\n                var tracked = this.track_pageview();\n                if (tracked) {\n                    previous_tracked_url = current_url;\n                }\n            }\n        }.bind(this));\n    }\n};\n\n/**\n * _prepare_callback() should be called by callers of _send_request for use\n * as the callback argument.\n *\n * If there is no callback, this returns null.\n * If we are going to make XHR/XDR requests, this returns a function.\n * If we are going to use script tags, this returns a string to use as the\n * callback GET param.\n */\nMixpanelLib.prototype._prepare_callback = function(callback, data) {\n    if (_.isUndefined(callback)) {\n        return null;\n    }\n\n    if (USE_XHR) {\n        var callback_function = function(response) {\n            callback(response, data);\n        };\n        return callback_function;\n    } else {\n        // if the user gives us a callback, we store as a random\n        // property on this instances jsc function and update our\n        // callback string to reflect that.\n        var jsc = this['_jsc'];\n        var randomized_cb = '' + Math.floor(Math.random() * 100000000);\n        var callback_string = this.get_config('callback_fn') + '[' + randomized_cb + ']';\n        jsc[randomized_cb] = function(response) {\n            delete jsc[randomized_cb];\n            callback(response, data);\n        };\n        return callback_string;\n    }\n};\n\nMixpanelLib.prototype._send_request = function(url, data, options, callback) {\n    var succeeded = true;\n\n    if (ENQUEUE_REQUESTS) {\n        this.__request_queue.push(arguments);\n        return succeeded;\n    }\n\n    var DEFAULT_OPTIONS = {\n        method: this.get_config('api_method'),\n        transport: this.get_config('api_transport'),\n        verbose: this.get_config('verbose')\n    };\n    var body_data = null;\n\n    if (!callback && (_.isFunction(options) || typeof options === 'string')) {\n        callback = options;\n        options = null;\n    }\n    options = _.extend(DEFAULT_OPTIONS, options || {});\n    if (!USE_XHR) {\n        options.method = 'GET';\n    }\n    var use_post = options.method === 'POST';\n    var use_sendBeacon = sendBeacon && use_post && options.transport.toLowerCase() === 'sendbeacon';\n\n    // needed to correctly format responses\n    var verbose_mode = options.verbose;\n    if (data['verbose']) { verbose_mode = true; }\n\n    if (this.get_config('test')) { data['test'] = 1; }\n    if (verbose_mode) { data['verbose'] = 1; }\n    if (this.get_config('img')) { data['img'] = 1; }\n    if (!USE_XHR) {\n        if (callback) {\n            data['callback'] = callback;\n        } else if (verbose_mode || this.get_config('test')) {\n            // Verbose output (from verbose mode, or an error in test mode) is a json blob,\n            // which by itself is not valid javascript. Without a callback, this verbose output will\n            // cause an error when returned via jsonp, so we force a no-op callback param.\n            // See the ECMA script spec: http://www.ecma-international.org/ecma-262/5.1/#sec-12.4\n            data['callback'] = '(function(){})';\n        }\n    }\n\n    data['ip'] = this.get_config('ip')?1:0;\n    data['_'] = new Date().getTime().toString();\n\n    if (use_post) {\n        body_data = 'data=' + encodeURIComponent(data['data']);\n        delete data['data'];\n    }\n\n    url += '?' + _.HTTPBuildQuery(data);\n\n    var lib = this;\n    if ('img' in data) {\n        var img = document$1.createElement('img');\n        img.src = url;\n        document$1.body.appendChild(img);\n    } else if (use_sendBeacon) {\n        try {\n            succeeded = sendBeacon(url, body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n        try {\n            if (callback) {\n                callback(succeeded ? 1 : 0);\n            }\n        } catch (e) {\n            lib.report_error(e);\n        }\n    } else if (USE_XHR) {\n        try {\n            var req = new XMLHttpRequest();\n            req.open(options.method, url, true);\n\n            var headers = this.get_config('xhr_headers');\n            if (use_post) {\n                headers['Content-Type'] = 'application/x-www-form-urlencoded';\n            }\n            _.each(headers, function(headerValue, headerName) {\n                req.setRequestHeader(headerName, headerValue);\n            });\n\n            if (options.timeout_ms && typeof req.timeout !== 'undefined') {\n                req.timeout = options.timeout_ms;\n                var start_time = new Date().getTime();\n            }\n\n            // send the mp_optout cookie\n            // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n            req.withCredentials = true;\n            req.onreadystatechange = function () {\n                if (req.readyState === 4) { // XMLHttpRequest.DONE == 4, except in safari 4\n                    if (req.status === 200) {\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response;\n                                try {\n                                    response = _.JSONDecode(req.responseText);\n                                } catch (e) {\n                                    lib.report_error(e);\n                                    if (options.ignore_json_errors) {\n                                        response = req.responseText;\n                                    } else {\n                                        return;\n                                    }\n                                }\n                                callback(response);\n                            } else {\n                                callback(Number(req.responseText));\n                            }\n                        }\n                    } else {\n                        var error;\n                        if (\n                            req.timeout &&\n                            !req.status &&\n                            new Date().getTime() - start_time >= req.timeout\n                        ) {\n                            error = 'timeout';\n                        } else {\n                            error = 'Bad HTTP status: ' + req.status + ' ' + req.statusText;\n                        }\n                        lib.report_error(error);\n                        if (callback) {\n                            if (verbose_mode) {\n                                var response_headers = req['responseHeaders'] || {};\n                                callback({status: 0, httpStatusCode: req['status'], error: error, retryAfter: response_headers['Retry-After']});\n                            } else {\n                                callback(0);\n                            }\n                        }\n                    }\n                }\n            };\n            req.send(body_data);\n        } catch (e) {\n            lib.report_error(e);\n            succeeded = false;\n        }\n    } else {\n        var script = document$1.createElement('script');\n        script.type = 'text/javascript';\n        script.async = true;\n        script.defer = true;\n        script.src = url;\n        var s = document$1.getElementsByTagName('script')[0];\n        s.parentNode.insertBefore(script, s);\n    }\n\n    return succeeded;\n};\n\n/**\n * _execute_array() deals with processing any mixpanel function\n * calls that were called before the Mixpanel library were loaded\n * (and are thus stored in an array so they can be called later)\n *\n * Note: we fire off all the mixpanel function calls && user defined\n * functions BEFORE we fire off mixpanel tracking calls. This is so\n * identify/register/set_config calls can properly modify early\n * tracking calls.\n *\n * @param {Array} array\n */\nMixpanelLib.prototype._execute_array = function(array) {\n    var fn_name, alias_calls = [], other_calls = [], tracking_calls = [];\n    _.each(array, function(item) {\n        if (item) {\n            fn_name = item[0];\n            if (_.isArray(fn_name)) {\n                tracking_calls.push(item); // chained call e.g. mixpanel.get_group().set()\n            } else if (typeof(item) === 'function') {\n                item.call(this);\n            } else if (_.isArray(item) && fn_name === 'alias') {\n                alias_calls.push(item);\n            } else if (_.isArray(item) && fn_name.indexOf('track') !== -1 && typeof(this[fn_name]) === 'function') {\n                tracking_calls.push(item);\n            } else {\n                other_calls.push(item);\n            }\n        }\n    }, this);\n\n    var execute = function(calls, context) {\n        _.each(calls, function(item) {\n            if (_.isArray(item[0])) {\n                // chained call\n                var caller = context;\n                _.each(item, function(call) {\n                    caller = caller[call[0]].apply(caller, call.slice(1));\n                });\n            } else {\n                this[item[0]].apply(this, item.slice(1));\n            }\n        }, context);\n    };\n\n    execute(alias_calls, this);\n    execute(other_calls, this);\n    execute(tracking_calls, this);\n};\n\n// request queueing utils\n\nMixpanelLib.prototype.are_batchers_initialized = function() {\n    return !!this.request_batchers.events;\n};\n\nMixpanelLib.prototype.get_batcher_configs = function() {\n    var queue_prefix = '__mpq_' + this.get_config('token');\n    var api_routes = this.get_config('api_routes');\n    this._batcher_configs = this._batcher_configs || {\n        events: {type: 'events', endpoint: '/' + api_routes['track'], queue_key: queue_prefix + '_ev'},\n        people: {type: 'people', endpoint: '/' + api_routes['engage'], queue_key: queue_prefix + '_pp'},\n        groups: {type: 'groups', endpoint: '/' + api_routes['groups'], queue_key: queue_prefix + '_gr'}\n    };\n    return this._batcher_configs;\n};\n\nMixpanelLib.prototype.init_batchers = function() {\n    if (!this.are_batchers_initialized()) {\n        var batcher_for = _.bind(function(attrs) {\n            return new RequestBatcher(\n                attrs.queue_key,\n                {\n                    libConfig: this['config'],\n                    errorReporter: this.get_config('error_reporter'),\n                    sendRequestFunc: _.bind(function(data, options, cb) {\n                        this._send_request(\n                            this.get_config('api_host') + attrs.endpoint,\n                            this._encode_data_for_request(data),\n                            options,\n                            this._prepare_callback(cb, data)\n                        );\n                    }, this),\n                    beforeSendHook: _.bind(function(item) {\n                        return this._run_hook('before_send_' + attrs.type, item);\n                    }, this),\n                    stopAllBatchingFunc: _.bind(this.stop_batch_senders, this),\n                    usePersistence: true\n                }\n            );\n        }, this);\n        var batcher_configs = this.get_batcher_configs();\n        this.request_batchers = {\n            events: batcher_for(batcher_configs.events),\n            people: batcher_for(batcher_configs.people),\n            groups: batcher_for(batcher_configs.groups)\n        };\n    }\n    if (this.get_config('batch_autostart')) {\n        this.start_batch_senders();\n    }\n};\n\nMixpanelLib.prototype.start_batch_senders = function() {\n    this._batchers_were_started = true;\n    if (this.are_batchers_initialized()) {\n        this._batch_requests = true;\n        _.each(this.request_batchers, function(batcher) {\n            batcher.start();\n        });\n    }\n};\n\nMixpanelLib.prototype.stop_batch_senders = function() {\n    this._batch_requests = false;\n    _.each(this.request_batchers, function(batcher) {\n        batcher.stop();\n        batcher.clear();\n    });\n};\n\n/**\n * push() keeps the standard async-array-push\n * behavior around after the lib is loaded.\n * This is only useful for external integrations that\n * do not wish to rely on our convenience methods\n * (created in the snippet).\n *\n * ### Usage:\n *     mixpanel.push(['register', { a: 'b' }]);\n *\n * @param {Array} item A [function_name, args...] array to be executed\n */\nMixpanelLib.prototype.push = function(item) {\n    this._execute_array([item]);\n};\n\n/**\n * Disable events on the Mixpanel object. If passed no arguments,\n * this function disables tracking of any event. If passed an\n * array of event names, those events will be disabled, but other\n * events will continue to be tracked.\n *\n * Note: this function does not stop other mixpanel functions from\n * firing, such as register() or people.set().\n *\n * @param {Array} [events] An array of event names to disable\n */\nMixpanelLib.prototype.disable = function(events) {\n    if (typeof(events) === 'undefined') {\n        this._flags.disable_all_events = true;\n    } else {\n        this.__disabled_events = this.__disabled_events.concat(events);\n    }\n};\n\nMixpanelLib.prototype._encode_data_for_request = function(data) {\n    var encoded_data = _.JSONEncode(data);\n    if (this.get_config('api_payload_format') === PAYLOAD_TYPE_BASE64) {\n        encoded_data = _.base64Encode(encoded_data);\n    }\n    return {'data': encoded_data};\n};\n\n// internal method for handling track vs batch-enqueue logic\nMixpanelLib.prototype._track_or_batch = function(options, callback) {\n    var truncated_data = _.truncate(options.data, 255);\n    var endpoint = options.endpoint;\n    var batcher = options.batcher;\n    var should_send_immediately = options.should_send_immediately;\n    var send_request_options = options.send_request_options || {};\n    callback = callback || NOOP_FUNC;\n\n    var request_enqueued_or_initiated = true;\n    var send_request_immediately = _.bind(function() {\n        if (!send_request_options.skip_hooks) {\n            truncated_data = this._run_hook('before_send_' + options.type, truncated_data);\n        }\n        if (truncated_data) {\n            console$1.log('MIXPANEL REQUEST:');\n            console$1.log(truncated_data);\n            return this._send_request(\n                endpoint,\n                this._encode_data_for_request(truncated_data),\n                send_request_options,\n                this._prepare_callback(callback, truncated_data)\n            );\n        } else {\n            return null;\n        }\n    }, this);\n\n    if (this._batch_requests && !should_send_immediately) {\n        batcher.enqueue(truncated_data).then(function(succeeded) {\n            if (succeeded) {\n                callback(1, truncated_data);\n            } else {\n                send_request_immediately();\n            }\n        });\n    } else {\n        request_enqueued_or_initiated = send_request_immediately();\n    }\n\n    return request_enqueued_or_initiated && truncated_data;\n};\n\n/**\n * Track an event. This is the most important and\n * frequently used Mixpanel function.\n *\n * ### Usage:\n *\n *     // track an event named 'Registered'\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n *     // track an event using navigator.sendBeacon\n *     mixpanel.track('Left page', {'duration_seconds': 35}, {transport: 'sendBeacon'});\n *\n * To track link clicks or form submissions, see track_links() or track_forms().\n *\n * @param {String} event_name The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.\n * @param {Object} [properties] A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.\n * @param {Object} [options] Optional configuration for this track request.\n * @param {String} [options.transport] Transport method for network request ('xhr' or 'sendBeacon').\n * @param {Boolean} [options.send_immediately] Whether to bypass batching/queueing and send track request immediately.\n * @param {Function} [callback] If provided, the callback function will be called after tracking the event.\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track = addOptOutCheckMixpanelLib(function(event_name, properties, options, callback) {\n    if (!callback && typeof options === 'function') {\n        callback = options;\n        options = null;\n    }\n    options = options || {};\n    var transport = options['transport']; // external API, don't minify 'transport' prop\n    if (transport) {\n        options.transport = transport; // 'transport' prop name can be minified internally\n    }\n    var should_send_immediately = options['send_immediately'];\n    if (typeof callback !== 'function') {\n        callback = NOOP_FUNC;\n    }\n\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.track');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        callback(0);\n        return;\n    }\n\n    // set defaults\n    properties = _.extend({}, properties);\n    properties['token'] = this.get_config('token');\n\n    // set $duration if time_event was previously called for this event\n    var start_timestamp = this['persistence'].remove_event_timer(event_name);\n    if (!_.isUndefined(start_timestamp)) {\n        var duration_in_ms = new Date().getTime() - start_timestamp;\n        properties['$duration'] = parseFloat((duration_in_ms / 1000).toFixed(3));\n    }\n\n    this._set_default_superprops();\n\n    var marketing_properties = this.get_config('track_marketing')\n        ? _.info.marketingParams()\n        : {};\n\n    // note: extend writes to the first object, so lets make sure we\n    // don't write to the persistence properties object and info\n    // properties object by passing in a new object\n\n    // update properties with pageview info and super-properties\n    properties = _.extend(\n        {},\n        _.info.properties({'mp_loader': this.get_config('mp_loader')}),\n        marketing_properties,\n        this['persistence'].properties(),\n        this.unpersisted_superprops,\n        this.get_session_recording_properties(),\n        properties\n    );\n\n    var property_blacklist = this.get_config('property_blacklist');\n    if (_.isArray(property_blacklist)) {\n        _.each(property_blacklist, function(blacklisted_prop) {\n            delete properties[blacklisted_prop];\n        });\n    } else {\n        this.report_error('Invalid value for property_blacklist config: ' + property_blacklist);\n    }\n\n    var data = {\n        'event': event_name,\n        'properties': properties\n    };\n    var ret = this._track_or_batch({\n        type: 'events',\n        data: data,\n        endpoint: this.get_config('api_host') + '/' + this.get_config('api_routes')['track'],\n        batcher: this.request_batchers.events,\n        should_send_immediately: should_send_immediately,\n        send_request_options: options\n    }, callback);\n\n    return ret;\n});\n\n/**\n * Register the current user into one/many groups.\n *\n * ### Usage:\n *\n *      mixpanel.set_group('company', ['mixpanel', 'google']) // an array of IDs\n *      mixpanel.set_group('company', 'mixpanel')\n *      mixpanel.set_group('company', 128746312)\n *\n * @param {String} group_key Group key\n * @param {Array|String|Number} group_ids An array of group IDs, or a singular group ID\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n *\n */\nMixpanelLib.prototype.set_group = addOptOutCheckMixpanelLib(function(group_key, group_ids, callback) {\n    if (!_.isArray(group_ids)) {\n        group_ids = [group_ids];\n    }\n    var prop = {};\n    prop[group_key] = group_ids;\n    this.register(prop);\n    return this['people'].set(group_key, group_ids, callback);\n});\n\n/**\n * Add a new group for this user.\n *\n * ### Usage:\n *\n *      mixpanel.add_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.add_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_values = this.get_property(group_key);\n    var prop = {};\n    if (old_values === undefined) {\n        prop[group_key] = [group_id];\n        this.register(prop);\n    } else {\n        if (old_values.indexOf(group_id) === -1) {\n            old_values.push(group_id);\n            prop[group_key] = old_values;\n            this.register(prop);\n        }\n    }\n    return this['people'].union(group_key, group_id, callback);\n});\n\n/**\n * Remove a group from this user.\n *\n * ### Usage:\n *\n *      mixpanel.remove_group('company', 'mixpanel')\n *\n * @param {String} group_key Group key\n * @param {*} group_id A valid Mixpanel property type\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.remove_group = addOptOutCheckMixpanelLib(function(group_key, group_id, callback) {\n    var old_value = this.get_property(group_key);\n    // if the value doesn't exist, the persistent store is unchanged\n    if (old_value !== undefined) {\n        var idx = old_value.indexOf(group_id);\n        if (idx > -1) {\n            old_value.splice(idx, 1);\n            this.register({group_key: old_value});\n        }\n        if (old_value.length === 0) {\n            this.unregister(group_key);\n        }\n    }\n    return this['people'].remove(group_key, group_id, callback);\n});\n\n/**\n * Track an event with specific groups.\n *\n * ### Usage:\n *\n *      mixpanel.track_with_groups('purchase', {'product': 'iphone'}, {'University': ['UCB', 'UCLA']})\n *\n * @param {String} event_name The name of the event (see `mixpanel.track()`)\n * @param {Object=} properties A set of properties to include with the event you're sending (see `mixpanel.track()`)\n * @param {Object=} groups An object mapping group name keys to one or more values\n * @param {Function} [callback] If provided, the callback will be called after tracking the event.\n */\nMixpanelLib.prototype.track_with_groups = addOptOutCheckMixpanelLib(function(event_name, properties, groups, callback) {\n    var tracking_props = _.extend({}, properties || {});\n    _.each(groups, function(v, k) {\n        if (v !== null && v !== undefined) {\n            tracking_props[k] = v;\n        }\n    });\n    return this.track(event_name, tracking_props, callback);\n});\n\nMixpanelLib.prototype._create_map_key = function (group_key, group_id) {\n    return group_key + '_' + JSON.stringify(group_id);\n};\n\nMixpanelLib.prototype._remove_group_from_cache = function (group_key, group_id) {\n    delete this._cached_groups[this._create_map_key(group_key, group_id)];\n};\n\n/**\n * Look up reference to a Mixpanel group\n *\n * ### Usage:\n *\n *       mixpanel.get_group(group_key, group_id)\n *\n * @param {String} group_key Group key\n * @param {Object} group_id A valid Mixpanel property type\n * @returns {Object} A MixpanelGroup identifier\n */\nMixpanelLib.prototype.get_group = function (group_key, group_id) {\n    var map_key = this._create_map_key(group_key, group_id);\n    var group = this._cached_groups[map_key];\n    if (group === undefined || group._group_key !== group_key || group._group_id !== group_id) {\n        group = new MixpanelGroup();\n        group._init(this, group_key, group_id);\n        this._cached_groups[map_key] = group;\n    }\n    return group;\n};\n\n/**\n * Track a default Mixpanel page view event, which includes extra default event properties to\n * improve page view data.\n *\n * ### Usage:\n *\n *     // track a default $mp_web_page_view event\n *     mixpanel.track_pageview();\n *\n *     // track a page view event with additional event properties\n *     mixpanel.track_pageview({'ab_test_variant': 'card-layout-b'});\n *\n *     // example approach to track page views on different page types as event properties\n *     mixpanel.track_pageview({'page': 'pricing'});\n *     mixpanel.track_pageview({'page': 'homepage'});\n *\n *     // UNCOMMON: Tracking a page view event with a custom event_name option. NOT expected to be used for\n *     // individual pages on the same site or product. Use cases for custom event_name may be page\n *     // views on different products or internal applications that are considered completely separate\n *     mixpanel.track_pageview({'page': 'customer-search'}, {'event_name': '[internal] Admin Page View'});\n *\n * ### Notes:\n *\n * The `config.track_pageview` option for <a href=\"#mixpanelinit\">mixpanel.init()</a>\n * may be turned on for tracking page loads automatically.\n *\n *     // track only page loads\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: true});\n *\n *     // track when the URL changes in any manner\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'full-url'});\n *\n *     // track when the URL changes, ignoring any changes in the hash part\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path-and-query-string'});\n *\n *     // track when the path changes, ignoring any query parameter or hash changes\n *     mixpanel.init(PROJECT_TOKEN, {track_pageview: 'url-with-path'});\n *\n * @param {Object} [properties] An optional set of additional properties to send with the page view event\n * @param {Object} [options] Page view tracking options\n * @param {String} [options.event_name] - Alternate name for the tracking event\n * @returns {Boolean|Object} If the tracking request was successfully initiated/queued, an object\n * with the tracking payload sent to the API server is returned; otherwise false.\n */\nMixpanelLib.prototype.track_pageview = addOptOutCheckMixpanelLib(function(properties, options) {\n    if (typeof properties !== 'object') {\n        properties = {};\n    }\n    options = options || {};\n    var event_name = options['event_name'] || '$mp_web_page_view';\n\n    var default_page_properties = _.extend(\n        _.info.mpPageViewProperties(),\n        _.info.campaignParams(),\n        _.info.clickParams()\n    );\n\n    var event_properties = _.extend(\n        {},\n        default_page_properties,\n        properties\n    );\n\n    return this.track(event_name, event_properties);\n});\n\n/**\n * Track clicks on a set of document elements. Selector must be a\n * valid query. Elements must exist on the page at the time track_links is called.\n *\n * ### Usage:\n *\n *     // track click for link id #nav\n *     mixpanel.track_links('#nav', 'Clicked Nav Link');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the Mixpanel\n * servers to respond. If they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] A properties object or function that returns a dictionary of properties when passed a DOMElement\n */\nMixpanelLib.prototype.track_links = function() {\n    return this._track_dom.call(this, LinkTracker, arguments);\n};\n\n/**\n * Track form submissions. Selector must be a valid query.\n *\n * ### Usage:\n *\n *     // track submission for form id 'register'\n *     mixpanel.track_forms('#register', 'Created Account');\n *\n * ### Notes:\n *\n * This function will wait up to 300 ms for the mixpanel\n * servers to respond, if they have not responded by that time\n * it will head to the link without ensuring that your event\n * has been tracked.  To configure this timeout please see the\n * set_config() documentation below.\n *\n * If you pass a function in as the properties argument, the\n * function will receive the DOMElement that triggered the\n * event as an argument.  You are expected to return an object\n * from the function; any properties defined on this object\n * will be sent to mixpanel as event properties.\n *\n * @type {Function}\n * @param {Object|String} query A valid DOM query, element or jQuery-esque list\n * @param {String} event_name The name of the event to track\n * @param {Object|Function} [properties] This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement\n */\nMixpanelLib.prototype.track_forms = function() {\n    return this._track_dom.call(this, FormTracker, arguments);\n};\n\n/**\n * Time an event by including the time between this call and a\n * later 'track' call for the same event in the properties sent\n * with the event.\n *\n * ### Usage:\n *\n *     // time an event named 'Registered'\n *     mixpanel.time_event('Registered');\n *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});\n *\n * When called for a particular event name, the next track call for that event\n * name will include the elapsed time between the 'time_event' and 'track'\n * calls. This value is stored as seconds in the '$duration' property.\n *\n * @param {String} event_name The name of the event.\n */\nMixpanelLib.prototype.time_event = function(event_name) {\n    if (_.isUndefined(event_name)) {\n        this.report_error('No event name provided to mixpanel.time_event');\n        return;\n    }\n\n    if (this._event_is_disabled(event_name)) {\n        return;\n    }\n\n    this['persistence'].set_event_timer(event_name,  new Date().getTime());\n};\n\nvar REGISTER_DEFAULTS = {\n    'persistent': true\n};\n/**\n * Helper to parse options param for register methods, maintaining\n * legacy support for plain \"days\" param instead of options object\n * @param {Number|Object} [days_or_options] 'days' option (Number), or Options object for register methods\n * @returns {Object} options object\n */\nvar options_for_register = function(days_or_options) {\n    var options;\n    if (_.isObject(days_or_options)) {\n        options = days_or_options;\n    } else if (!_.isUndefined(days_or_options)) {\n        options = {'days': days_or_options};\n    } else {\n        options = {};\n    }\n    return _.extend({}, REGISTER_DEFAULTS, options);\n};\n\n/**\n * Register a set of super properties, which are included with all\n * events. This will overwrite previous super property values.\n *\n * ### Usage:\n *\n *     // register 'Gender' as a super property\n *     mixpanel.register({'Gender': 'Female'});\n *\n *     // register several super properties when a user signs up\n *     mixpanel.register({\n *         'Email': 'jdoe@example.com',\n *         'Account Type': 'Free'\n *     });\n *\n *     // register only for the current pageload\n *     mixpanel.register({'Name': 'Pat'}, {persistent: false});\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register = function(props, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register(props, options['days']);\n    } else {\n        _.extend(this.unpersisted_superprops, props);\n    }\n};\n\n/**\n * Register a set of super properties only once. This will not\n * overwrite previous super property values, unlike register().\n *\n * ### Usage:\n *\n *     // register a super property for the first time only\n *     mixpanel.register_once({\n *         'First Login Date': new Date().toISOString()\n *     });\n *\n *     // register once, only for the current pageload\n *     mixpanel.register_once({\n *         'First interaction time': new Date().toISOString()\n *     }, 'None', {persistent: false});\n *\n * ### Notes:\n *\n * If default_value is specified, current super properties\n * with that value will be overwritten.\n *\n * @param {Object} properties An associative array of properties to store about the user\n * @param {*} [default_value] Value to override if already set in super properties (ex: 'False') Default: 'None'\n * @param {Number|Object} [days_or_options] Options object or number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.days] - number of days since the user's last visit to store the super properties (only valid for persisted props)\n * @param {boolean} [days_or_options.persistent=true] - whether to put in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.register_once = function(props, default_value, days_or_options) {\n    var options = options_for_register(days_or_options);\n    if (options['persistent']) {\n        this['persistence'].register_once(props, default_value, options['days']);\n    } else {\n        if (typeof(default_value) === 'undefined') {\n            default_value = 'None';\n        }\n        _.each(props, function(val, prop) {\n            if (!this.unpersisted_superprops.hasOwnProperty(prop) || this.unpersisted_superprops[prop] === default_value) {\n                this.unpersisted_superprops[prop] = val;\n            }\n        }, this);\n    }\n};\n\n/**\n * Delete a super property stored with the current user.\n *\n * @param {String} property The name of the super property to remove\n * @param {Object} [options]\n * @param {boolean} [options.persistent=true] - whether to look in persistent storage (cookie/localStorage)\n */\nMixpanelLib.prototype.unregister = function(property, options) {\n    options = options_for_register(options);\n    if (options['persistent']) {\n        this['persistence'].unregister(property);\n    } else {\n        delete this.unpersisted_superprops[property];\n    }\n};\n\nMixpanelLib.prototype._register_single = function(prop, value) {\n    var props = {};\n    props[prop] = value;\n    this.register(props);\n};\n\n/**\n * Identify a user with a unique ID to track user activity across\n * devices, tie a user to their events, and create a user profile.\n * If you never call this method, unique visitors are tracked using\n * a UUID generated the first time they visit the site.\n *\n * Call identify when you know the identity of the current user,\n * typically after login or signup. We recommend against using\n * identify for anonymous visitors to your site.\n *\n * ### Notes:\n * If your project has\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the identify method will connect pre- and\n * post-authentication events when appropriate.\n *\n * If your project does not have ID Merge enabled, identify will\n * change the user's local distinct_id to the unique ID you pass.\n * Events tracked prior to authentication will not be connected\n * to the same user identity. If ID Merge is disabled, alias can\n * be used to connect pre- and post-registration events.\n *\n * @param {String} [unique_id] A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.\n */\nMixpanelLib.prototype.identify = function(\n    new_distinct_id, _set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback\n) {\n    // Optional Parameters\n    //  _set_callback:function  A callback to be run if and when the People set queue is flushed\n    //  _add_callback:function  A callback to be run if and when the People add queue is flushed\n    //  _append_callback:function  A callback to be run if and when the People append queue is flushed\n    //  _set_once_callback:function  A callback to be run if and when the People set_once queue is flushed\n    //  _union_callback:function  A callback to be run if and when the People union queue is flushed\n    //  _unset_callback:function  A callback to be run if and when the People unset queue is flushed\n\n    var previous_distinct_id = this.get_distinct_id();\n    if (new_distinct_id && previous_distinct_id !== new_distinct_id) {\n        // we allow the following condition if previous distinct_id is same as new_distinct_id\n        // so that you can force flush people updates for anonymous profiles.\n        if (typeof new_distinct_id === 'string' && new_distinct_id.indexOf(DEVICE_ID_PREFIX) === 0) {\n            this.report_error('distinct_id cannot have $device: prefix');\n            return -1;\n        }\n        this.register({'$user_id': new_distinct_id});\n    }\n\n    if (!this.get_property('$device_id')) {\n        // The persisted distinct id might not actually be a device id at all\n        // it might be a distinct id of the user from before\n        var device_id = previous_distinct_id;\n        this.register_once({\n            '$had_persisted_distinct_id': true,\n            '$device_id': device_id\n        }, '');\n    }\n\n    // identify only changes the distinct id if it doesn't match either the existing or the alias;\n    // if it's new, blow away the alias as well.\n    if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {\n        this.unregister(ALIAS_ID_KEY);\n        this.register({'distinct_id': new_distinct_id});\n    }\n    this._flags.identify_called = true;\n    // Flush any queued up people requests\n    this['people']._flush(_set_callback, _add_callback, _append_callback, _set_once_callback, _union_callback, _unset_callback, _remove_callback);\n\n    // send an $identify event any time the distinct_id is changing - logic on the server\n    // will determine whether or not to do anything with it.\n    if (new_distinct_id !== previous_distinct_id) {\n        this.track('$identify', {\n            'distinct_id': new_distinct_id,\n            '$anon_distinct_id': previous_distinct_id\n        }, {skip_hooks: true});\n    }\n};\n\n/**\n * Clears super properties and generates a new random distinct_id for this instance.\n * Useful for clearing data when a user logs out.\n */\nMixpanelLib.prototype.reset = function() {\n    this['persistence'].clear();\n    this._flags.identify_called = false;\n    var uuid = _.UUID();\n    this.register_once({\n        'distinct_id': DEVICE_ID_PREFIX + uuid,\n        '$device_id': uuid\n    }, '');\n};\n\n/**\n * Returns the current distinct id of the user. This is either the id automatically\n * generated by the library or the id that has been passed by a call to identify().\n *\n * ### Notes:\n *\n * get_distinct_id() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // set distinct_id after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             distinct_id = mixpanel.get_distinct_id();\n *         }\n *     });\n */\nMixpanelLib.prototype.get_distinct_id = function() {\n    return this.get_property('distinct_id');\n};\n\n/**\n * The alias method creates an alias which Mixpanel will use to\n * remap one id to another. Multiple aliases can point to the\n * same identifier.\n *\n * The following is a valid use of alias:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // You can add multiple id aliases to the existing ID\n *     mixpanel.alias('newer_id', 'existing_id');\n *\n * Aliases can also be chained - the following is a valid example:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // chain newer_id - new_id - existing_id\n *     mixpanel.alias('newer_id', 'new_id');\n *\n * Aliases cannot point to multiple identifiers - the following\n * example will not work:\n *\n *     mixpanel.alias('new_id', 'existing_id');\n *     // this is invalid as 'new_id' already points to 'existing_id'\n *     mixpanel.alias('new_id', 'newer_id');\n *\n * ### Notes:\n *\n * If your project does not have\n * <a href=\"https://help.mixpanel.com/hc/en-us/articles/360039133851\">ID Merge</a>\n * enabled, the best practice is to call alias once when a unique\n * ID is first created for a user (e.g., when a user first registers\n * for an account). Do not use alias multiple times for a single\n * user without ID Merge enabled.\n *\n * @param {String} alias A unique identifier that you want to use for this user in the future.\n * @param {String} [original] The current identifier being used for this user.\n */\nMixpanelLib.prototype.alias = function(alias, original) {\n    // If the $people_distinct_id key exists in persistence, there has been a previous\n    // mixpanel.people.identify() call made for this user. It is VERY BAD to make an alias with\n    // this ID, as it will duplicate users.\n    if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {\n        this.report_error('Attempting to create alias for existing People user - aborting.');\n        return -2;\n    }\n\n    var _this = this;\n    if (_.isUndefined(original)) {\n        original = this.get_distinct_id();\n    }\n    if (alias !== original) {\n        this._register_single(ALIAS_ID_KEY, alias);\n        return this.track('$create_alias', {\n            'alias': alias,\n            'distinct_id': original\n        }, {\n            skip_hooks: true\n        }, function() {\n            // Flush the people queue\n            _this.identify(alias);\n        });\n    } else {\n        this.report_error('alias matches current distinct_id - skipping api call.');\n        this.identify(alias);\n        return -1;\n    }\n};\n\n/**\n * Provide a string to recognize the user by. The string passed to\n * this method will appear in the Mixpanel Streams product rather\n * than an automatically generated name. Name tags do not have to\n * be unique.\n *\n * This value will only be included in Streams data.\n *\n * @param {String} name_tag A human readable name for the user\n * @deprecated\n */\nMixpanelLib.prototype.name_tag = function(name_tag) {\n    this._register_single('mp_name_tag', name_tag);\n};\n\n/**\n * Update the configuration of a mixpanel library instance.\n *\n * The default config is:\n *\n *     {\n *       // host for requests (customizable for e.g. a local proxy)\n *       api_host: 'https://api-js.mixpanel.com',\n *\n *       // endpoints for different types of requests\n *       api_routes: {\n *         track: 'track/',\n *         engage: 'engage/',\n *         groups: 'groups/',\n *       }\n *\n *       // HTTP method for tracking requests\n *       api_method: 'POST'\n *\n *       // transport for sending requests ('XHR' or 'sendBeacon')\n *       // NB: sendBeacon should only be used for scenarios such as\n *       // page unload where a \"best-effort\" attempt to send is\n *       // acceptable; the sendBeacon API does not support callbacks\n *       // or any way to know the result of the request. Mixpanel\n *       // tracking via sendBeacon will not support any event-\n *       // batching or retry mechanisms.\n *       api_transport: 'XHR'\n *\n *       // request-batching/queueing/retry\n *       batch_requests: true,\n *\n *       // maximum number of events/updates to send in a single\n *       // network request\n *       batch_size: 50,\n *\n *       // milliseconds to wait between sending batch requests\n *       batch_flush_interval_ms: 5000,\n *\n *       // milliseconds to wait for network responses to batch requests\n *       // before they are considered timed-out and retried\n *       batch_request_timeout_ms: 90000,\n *\n *       // override value for cookie domain, only useful for ensuring\n *       // correct cross-subdomain cookies on unusual domains like\n *       // subdomain.mainsite.avocat.fr; NB this cannot be used to\n *       // set cookies on a different domain than the current origin\n *       cookie_domain: ''\n *\n *       // super properties cookie expiration (in days)\n *       cookie_expiration: 365\n *\n *       // if true, cookie will be set with SameSite=None; Secure\n *       // this is only useful in special situations, like embedded\n *       // 3rd-party iframes that set up a Mixpanel instance\n *       cross_site_cookie: false\n *\n *       // super properties span subdomains\n *       cross_subdomain_cookie: true\n *\n *       // debug mode\n *       debug: false\n *\n *       // if this is true, the mixpanel cookie or localStorage entry\n *       // will be deleted, and no user persistence will take place\n *       disable_persistence: false\n *\n *       // if this is true, Mixpanel will automatically determine\n *       // City, Region and Country data using the IP address of\n *       //the client\n *       ip: true\n *\n *       // opt users out of tracking by this Mixpanel instance by default\n *       opt_out_tracking_by_default: false\n *\n *       // opt users out of browser data storage by this Mixpanel instance by default\n *       opt_out_persistence_by_default: false\n *\n *       // persistence mechanism used by opt-in/opt-out methods - cookie\n *       // or localStorage - falls back to cookie if localStorage is unavailable\n *       opt_out_tracking_persistence_type: 'localStorage'\n *\n *       // customize the name of cookie/localStorage set by opt-in/opt-out methods\n *       opt_out_tracking_cookie_prefix: null\n *\n *       // type of persistent store for super properties (cookie/\n *       // localStorage) if set to 'localStorage', any existing\n *       // mixpanel cookie value with the same persistence_name\n *       // will be transferred to localStorage and deleted\n *       persistence: 'cookie'\n *\n *       // name for super properties persistent store\n *       persistence_name: ''\n *\n *       // names of properties/superproperties which should never\n *       // be sent with track() calls\n *       property_blacklist: []\n *\n *       // if this is true, mixpanel cookies will be marked as\n *       // secure, meaning they will only be transmitted over https\n *       secure_cookie: false\n *\n *       // disables enriching user profiles with first touch marketing data\n *       skip_first_touch_marketing: false\n *\n *       // the amount of time track_links will\n *       // wait for Mixpanel's servers to respond\n *       track_links_timeout: 300\n *\n *       // adds any UTM parameters and click IDs present on the page to any events fired\n *       track_marketing: true\n *\n *       // enables automatic page view tracking using default page view events through\n *       // the track_pageview() method\n *       track_pageview: false\n *\n *       // if you set upgrade to be true, the library will check for\n *       // a cookie from our old js library and import super\n *       // properties from it, then the old cookie is deleted\n *       // The upgrade config option only works in the initialization,\n *       // so make sure you set it when you create the library.\n *       upgrade: false\n *\n *       // extra HTTP request headers to set for each API request, in\n *       // the format {'Header-Name': value}\n *       xhr_headers: {}\n *\n *       // whether to ignore or respect the web browser's Do Not Track setting\n *       ignore_dnt: false\n *     }\n *\n *\n * @param {Object} config A dictionary of new configuration values to update\n */\nMixpanelLib.prototype.set_config = function(config) {\n    if (_.isObject(config)) {\n        _.extend(this['config'], config);\n\n        var new_batch_size = config['batch_size'];\n        if (new_batch_size) {\n            _.each(this.request_batchers, function(batcher) {\n                batcher.resetBatchSize();\n            });\n        }\n\n        if (!this.get_config('persistence_name')) {\n            this['config']['persistence_name'] = this['config']['cookie_name'];\n        }\n        if (!this.get_config('disable_persistence')) {\n            this['config']['disable_persistence'] = this['config']['disable_cookie'];\n        }\n\n        if (this['persistence']) {\n            this['persistence'].update_config(this['config']);\n        }\n        Config.DEBUG = Config.DEBUG || this.get_config('debug');\n    }\n};\n\n/**\n * returns the current config object for the library.\n */\nMixpanelLib.prototype.get_config = function(prop_name) {\n    return this['config'][prop_name];\n};\n\n/**\n * Fetch a hook function from config, with safe default, and run it\n * against the given arguments\n * @param {string} hook_name which hook to retrieve\n * @returns {any|null} return value of user-provided hook, or null if nothing was returned\n */\nMixpanelLib.prototype._run_hook = function(hook_name) {\n    var ret = (this['config']['hooks'][hook_name] || IDENTITY_FUNC).apply(this, slice.call(arguments, 1));\n    if (typeof ret === 'undefined') {\n        this.report_error(hook_name + ' hook did not return a value');\n        ret = null;\n    }\n    return ret;\n};\n\n/**\n * Returns the value of the super property named property_name. If no such\n * property is set, get_property() will return the undefined value.\n *\n * ### Notes:\n *\n * get_property() can only be called after the Mixpanel library has finished loading.\n * init() has a loaded function available to handle this automatically. For example:\n *\n *     // grab value for 'user_id' after the mixpanel library has loaded\n *     mixpanel.init('YOUR PROJECT TOKEN', {\n *         loaded: function(mixpanel) {\n *             user_id = mixpanel.get_property('user_id');\n *         }\n *     });\n *\n * @param {String} property_name The name of the super property you want to retrieve\n */\nMixpanelLib.prototype.get_property = function(property_name) {\n    return this['persistence'].load_prop([property_name]);\n};\n\nMixpanelLib.prototype.toString = function() {\n    var name = this.get_config('name');\n    if (name !== PRIMARY_INSTANCE_NAME) {\n        name = PRIMARY_INSTANCE_NAME + '.' + name;\n    }\n    return name;\n};\n\nMixpanelLib.prototype._event_is_disabled = function(event_name) {\n    return _.isBlockedUA(userAgent) ||\n        this._flags.disable_all_events ||\n        _.include(this.__disabled_events, event_name);\n};\n\n// perform some housekeeping around GDPR opt-in/out state\nMixpanelLib.prototype._gdpr_init = function() {\n    var is_localStorage_requested = this.get_config('opt_out_tracking_persistence_type') === 'localStorage';\n\n    // try to convert opt-in/out cookies to localStorage if possible\n    if (is_localStorage_requested && _.localStorage.is_supported()) {\n        if (!this.has_opted_in_tracking() && this.has_opted_in_tracking({'persistence_type': 'cookie'})) {\n            this.opt_in_tracking({'enable_persistence': false});\n        }\n        if (!this.has_opted_out_tracking() && this.has_opted_out_tracking({'persistence_type': 'cookie'})) {\n            this.opt_out_tracking({'clear_persistence': false});\n        }\n        this.clear_opt_in_out_tracking({\n            'persistence_type': 'cookie',\n            'enable_persistence': false\n        });\n    }\n\n    // check whether the user has already opted out - if so, clear & disable persistence\n    if (this.has_opted_out_tracking()) {\n        this._gdpr_update_persistence({'clear_persistence': true});\n\n    // check whether we should opt out by default\n    // note: we don't clear persistence here by default since opt-out default state is often\n    //       used as an initial state while GDPR information is being collected\n    } else if (!this.has_opted_in_tracking() && (\n        this.get_config('opt_out_tracking_by_default') || _.cookie.get('mp_optout')\n    )) {\n        _.cookie.remove('mp_optout');\n        this.opt_out_tracking({\n            'clear_persistence': this.get_config('opt_out_persistence_by_default')\n        });\n    }\n};\n\n/**\n * Enable or disable persistence based on options\n * only enable/disable if persistence is not already in this state\n * @param {boolean} [options.clear_persistence] If true, will delete all data stored by the sdk in persistence and disable it\n * @param {boolean} [options.enable_persistence] If true, will re-enable sdk persistence\n */\nMixpanelLib.prototype._gdpr_update_persistence = function(options) {\n    var disabled;\n    if (options && options['clear_persistence']) {\n        disabled = true;\n    } else if (options && options['enable_persistence']) {\n        disabled = false;\n    } else {\n        return;\n    }\n\n    if (!this.get_config('disable_persistence') && this['persistence'].disabled !== disabled) {\n        this['persistence'].set_disabled(disabled);\n    }\n\n    if (disabled) {\n        this.stop_batch_senders();\n    } else {\n        // only start batchers after opt-in if they have previously been started\n        // in order to avoid unintentionally starting up batching for the first time\n        if (this._batchers_were_started) {\n            this.start_batch_senders();\n        }\n    }\n};\n\n// call a base gdpr function after constructing the appropriate token and options args\nMixpanelLib.prototype._gdpr_call_func = function(func, options) {\n    options = _.extend({\n        'track': _.bind(this.track, this),\n        'persistence_type': this.get_config('opt_out_tracking_persistence_type'),\n        'cookie_prefix': this.get_config('opt_out_tracking_cookie_prefix'),\n        'cookie_expiration': this.get_config('cookie_expiration'),\n        'cross_site_cookie': this.get_config('cross_site_cookie'),\n        'cross_subdomain_cookie': this.get_config('cross_subdomain_cookie'),\n        'cookie_domain': this.get_config('cookie_domain'),\n        'secure_cookie': this.get_config('secure_cookie'),\n        'ignore_dnt': this.get_config('ignore_dnt')\n    }, options);\n\n    // check if localStorage can be used for recording opt out status, fall back to cookie if not\n    if (!_.localStorage.is_supported()) {\n        options['persistence_type'] = 'cookie';\n    }\n\n    return func(this.get_config('token'), {\n        track: options['track'],\n        trackEventName: options['track_event_name'],\n        trackProperties: options['track_properties'],\n        persistenceType: options['persistence_type'],\n        persistencePrefix: options['cookie_prefix'],\n        cookieDomain: options['cookie_domain'],\n        cookieExpiration: options['cookie_expiration'],\n        crossSiteCookie: options['cross_site_cookie'],\n        crossSubdomainCookie: options['cross_subdomain_cookie'],\n        secureCookie: options['secure_cookie'],\n        ignoreDnt: options['ignore_dnt']\n    });\n};\n\n/**\n * Opt the user in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user in\n *     mixpanel.opt_in_tracking();\n *\n *     // opt user in with specific event name, properties, cookie configuration\n *     mixpanel.opt_in_tracking({\n *         track_event_name: 'User opted in',\n *         track_event_properties: {\n *             'Email': 'jdoe@example.com'\n *         },\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {function} [options.track] Function used for tracking a Mixpanel event to record the opt-in action (default is this Mixpanel instance's track method)\n * @param {string} [options.track_event_name=$opt_in] Event name to be used for tracking the opt-in action\n * @param {Object} [options.track_properties] Set of properties to be tracked along with the opt-in action\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_in_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(optIn, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Opt the user out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // opt user out\n *     mixpanel.opt_out_tracking();\n *\n *     // opt user out with different cookie configuration from Mixpanel instance\n *     mixpanel.opt_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.delete_user=true] If true, will delete the currently identified user's profile and clear all charges after opting the user out\n * @param {boolean} [options.clear_persistence=true] If true, will delete all data stored by the sdk in persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.opt_out_tracking = function(options) {\n    options = _.extend({\n        'clear_persistence': true,\n        'delete_user': true\n    }, options);\n\n    // delete user and clear charges since these methods may be disabled by opt-out\n    if (options['delete_user'] && this['people'] && this['people']._identify_called()) {\n        this['people'].delete_user();\n        this['people'].clear_charges();\n    }\n\n    this._gdpr_call_func(optOut, options);\n    this._gdpr_update_persistence(options);\n};\n\n/**\n * Check whether the user has opted in to data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_in = mixpanel.has_opted_in_tracking();\n *     // use has_opted_in value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-in status\n */\nMixpanelLib.prototype.has_opted_in_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedIn, options);\n};\n\n/**\n * Check whether the user has opted out of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     var has_opted_out = mixpanel.has_opted_out_tracking();\n *     // use has_opted_out value\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @returns {boolean} current opt-out status\n */\nMixpanelLib.prototype.has_opted_out_tracking = function(options) {\n    return this._gdpr_call_func(hasOptedOut, options);\n};\n\n/**\n * Clear the user's opt in/out status of data tracking and cookies/localstorage for this Mixpanel instance\n *\n * ### Usage:\n *\n *     // clear user's opt-in/out status\n *     mixpanel.clear_opt_in_out_tracking();\n *\n *     // clear user's opt-in/out status with specific cookie configuration - should match\n *     // configuration used when opt_in_tracking/opt_out_tracking methods were called.\n *     mixpanel.clear_opt_in_out_tracking({\n *         cookie_expiration: 30,\n *         secure_cookie: true\n *     });\n *\n * @param {Object} [options] A dictionary of config options to override\n * @param {boolean} [options.enable_persistence=true] If true, will re-enable sdk persistence\n * @param {string} [options.persistence_type=localStorage] Persistence mechanism used - cookie or localStorage - falls back to cookie if localStorage is unavailable\n * @param {string} [options.cookie_prefix=__mp_opt_in_out] Custom prefix to be used in the cookie/localstorage name\n * @param {Number} [options.cookie_expiration] Number of days until the opt-in cookie expires (overrides value specified in this Mixpanel instance's config)\n * @param {string} [options.cookie_domain] Custom cookie domain (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_site_cookie] Whether the opt-in cookie is set as cross-site-enabled (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.cross_subdomain_cookie] Whether the opt-in cookie is set as cross-subdomain or not (overrides value specified in this Mixpanel instance's config)\n * @param {boolean} [options.secure_cookie] Whether the opt-in cookie is set as secure or not (overrides value specified in this Mixpanel instance's config)\n */\nMixpanelLib.prototype.clear_opt_in_out_tracking = function(options) {\n    options = _.extend({\n        'enable_persistence': true\n    }, options);\n\n    this._gdpr_call_func(clearOptInOut, options);\n    this._gdpr_update_persistence(options);\n};\n\nMixpanelLib.prototype.report_error = function(msg, err) {\n    console$1.error.apply(console$1.error, arguments);\n    try {\n        if (!err && !(msg instanceof Error)) {\n            msg = new Error(msg);\n        }\n        this.get_config('error_reporter')(msg, err);\n    } catch(err) {\n        console$1.error(err);\n    }\n};\n\n// EXPORTS (for closure compiler)\n\n// MixpanelLib Exports\nMixpanelLib.prototype['init']                               = MixpanelLib.prototype.init;\nMixpanelLib.prototype['reset']                              = MixpanelLib.prototype.reset;\nMixpanelLib.prototype['disable']                            = MixpanelLib.prototype.disable;\nMixpanelLib.prototype['time_event']                         = MixpanelLib.prototype.time_event;\nMixpanelLib.prototype['track']                              = MixpanelLib.prototype.track;\nMixpanelLib.prototype['track_links']                        = MixpanelLib.prototype.track_links;\nMixpanelLib.prototype['track_forms']                        = MixpanelLib.prototype.track_forms;\nMixpanelLib.prototype['track_pageview']                     = MixpanelLib.prototype.track_pageview;\nMixpanelLib.prototype['register']                           = MixpanelLib.prototype.register;\nMixpanelLib.prototype['register_once']                      = MixpanelLib.prototype.register_once;\nMixpanelLib.prototype['unregister']                         = MixpanelLib.prototype.unregister;\nMixpanelLib.prototype['identify']                           = MixpanelLib.prototype.identify;\nMixpanelLib.prototype['alias']                              = MixpanelLib.prototype.alias;\nMixpanelLib.prototype['name_tag']                           = MixpanelLib.prototype.name_tag;\nMixpanelLib.prototype['set_config']                         = MixpanelLib.prototype.set_config;\nMixpanelLib.prototype['get_config']                         = MixpanelLib.prototype.get_config;\nMixpanelLib.prototype['get_property']                       = MixpanelLib.prototype.get_property;\nMixpanelLib.prototype['get_distinct_id']                    = MixpanelLib.prototype.get_distinct_id;\nMixpanelLib.prototype['toString']                           = MixpanelLib.prototype.toString;\nMixpanelLib.prototype['opt_out_tracking']                   = MixpanelLib.prototype.opt_out_tracking;\nMixpanelLib.prototype['opt_in_tracking']                    = MixpanelLib.prototype.opt_in_tracking;\nMixpanelLib.prototype['has_opted_out_tracking']             = MixpanelLib.prototype.has_opted_out_tracking;\nMixpanelLib.prototype['has_opted_in_tracking']              = MixpanelLib.prototype.has_opted_in_tracking;\nMixpanelLib.prototype['clear_opt_in_out_tracking']          = MixpanelLib.prototype.clear_opt_in_out_tracking;\nMixpanelLib.prototype['get_group']                          = MixpanelLib.prototype.get_group;\nMixpanelLib.prototype['set_group']                          = MixpanelLib.prototype.set_group;\nMixpanelLib.prototype['add_group']                          = MixpanelLib.prototype.add_group;\nMixpanelLib.prototype['remove_group']                       = MixpanelLib.prototype.remove_group;\nMixpanelLib.prototype['track_with_groups']                  = MixpanelLib.prototype.track_with_groups;\nMixpanelLib.prototype['start_batch_senders']                = MixpanelLib.prototype.start_batch_senders;\nMixpanelLib.prototype['stop_batch_senders']                 = MixpanelLib.prototype.stop_batch_senders;\nMixpanelLib.prototype['start_session_recording']            = MixpanelLib.prototype.start_session_recording;\nMixpanelLib.prototype['stop_session_recording']             = MixpanelLib.prototype.stop_session_recording;\nMixpanelLib.prototype['get_session_recording_properties']   = MixpanelLib.prototype.get_session_recording_properties;\nMixpanelLib.prototype['get_session_replay_url']             = MixpanelLib.prototype.get_session_replay_url;\nMixpanelLib.prototype['DEFAULT_API_ROUTES']                 = DEFAULT_API_ROUTES;\n\n// MixpanelPersistence Exports\nMixpanelPersistence.prototype['properties']            = MixpanelPersistence.prototype.properties;\nMixpanelPersistence.prototype['update_search_keyword'] = MixpanelPersistence.prototype.update_search_keyword;\nMixpanelPersistence.prototype['update_referrer_info']  = MixpanelPersistence.prototype.update_referrer_info;\nMixpanelPersistence.prototype['get_cross_subdomain']   = MixpanelPersistence.prototype.get_cross_subdomain;\nMixpanelPersistence.prototype['clear']                 = MixpanelPersistence.prototype.clear;\n\n\nvar instances = {};\nvar extend_mp = function() {\n    // add all the sub mixpanel instances\n    _.each(instances, function(instance, name) {\n        if (name !== PRIMARY_INSTANCE_NAME) { mixpanel_master[name] = instance; }\n    });\n\n    // add private functions as _\n    mixpanel_master['_'] = _;\n};\n\nvar override_mp_init_func = function() {\n    // we override the snippets init function to handle the case where a\n    // user initializes the mixpanel library after the script loads & runs\n    mixpanel_master['init'] = function(token, config, name) {\n        if (name) {\n            // initialize a sub library\n            if (!mixpanel_master[name]) {\n                mixpanel_master[name] = instances[name] = create_mplib(token, config, name);\n                mixpanel_master[name]._loaded();\n            }\n            return mixpanel_master[name];\n        } else {\n            var instance = mixpanel_master;\n\n            if (instances[PRIMARY_INSTANCE_NAME]) {\n                // main mixpanel lib already initialized\n                instance = instances[PRIMARY_INSTANCE_NAME];\n            } else if (token) {\n                // intialize the main mixpanel lib\n                instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);\n                instance._loaded();\n                instances[PRIMARY_INSTANCE_NAME] = instance;\n            }\n\n            mixpanel_master = instance;\n            if (init_type === INIT_SNIPPET) {\n                win[PRIMARY_INSTANCE_NAME] = mixpanel_master;\n            }\n            extend_mp();\n        }\n    };\n};\n\nvar add_dom_loaded_handler = function() {\n    // Cross browser DOM Loaded support\n    function dom_loaded_handler() {\n        // function flag since we only want to execute this once\n        if (dom_loaded_handler.done) { return; }\n        dom_loaded_handler.done = true;\n\n        DOM_LOADED = true;\n        ENQUEUE_REQUESTS = false;\n\n        _.each(instances, function(inst) {\n            inst._dom_loaded();\n        });\n    }\n\n    function do_scroll_check() {\n        try {\n            document$1.documentElement.doScroll('left');\n        } catch(e) {\n            setTimeout(do_scroll_check, 1);\n            return;\n        }\n\n        dom_loaded_handler();\n    }\n\n    if (document$1.addEventListener) {\n        if (document$1.readyState === 'complete') {\n            // safari 4 can fire the DOMContentLoaded event before loading all\n            // external JS (including this file). you will see some copypasta\n            // on the internet that checks for 'complete' and 'loaded', but\n            // 'loaded' is an IE thing\n            dom_loaded_handler();\n        } else {\n            document$1.addEventListener('DOMContentLoaded', dom_loaded_handler, false);\n        }\n    } else if (document$1.attachEvent) {\n        // IE\n        document$1.attachEvent('onreadystatechange', dom_loaded_handler);\n\n        // check to make sure we arn't in a frame\n        var toplevel = false;\n        try {\n            toplevel = win.frameElement === null;\n        } catch(e) {\n            // noop\n        }\n\n        if (document$1.documentElement.doScroll && toplevel) {\n            do_scroll_check();\n        }\n    }\n\n    // fallback handler, always will work\n    _.register_event(win, 'load', dom_loaded_handler, true);\n};\n\nfunction init_as_module(bundle_loader) {\n    load_extra_bundle = bundle_loader;\n    init_type = INIT_MODULE;\n    mixpanel_master = new MixpanelLib();\n\n    override_mp_init_func();\n    mixpanel_master['init']();\n    add_dom_loaded_handler();\n\n    return mixpanel_master;\n}\n\n// For loading separate bundles asynchronously via script tag\n\n// For builds that have everything in one bundle, no extra work.\nfunction loadNoop (_src, onload) {\n    onload();\n}\n\n/* eslint camelcase: \"off\" */\n\nvar mixpanel = init_as_module(loadNoop);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELDBEQUEwRDtBQUMxRCwwREFBMEQsb0NBQW9DLHNCQUFzQjtBQUNwSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0EseUNBQXlDLDBCQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxlQUFlO0FBQy9DO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUErRDtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDN0Q7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsU0FBUyxFQUFFLFdBQVc7QUFDN0Q7QUFDQTtBQUNBLDBCQUEwQixXQUFXLEVBQUUsK0JBQStCLEVBQUUsV0FBVztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsV0FBVyxFQUFFLGdCQUFnQixFQUFFLFdBQVc7QUFDaEUsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwwRkFBMEYsOENBQThDLDRFQUE0RTtBQUNoTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUVBQXVFLGtDQUFrQyxvRkFBb0Y7QUFDek07QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGlCQUFpQixXQUFXLElBQUk7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0IsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMElBQTBJLDhEQUE4RCwrTUFBK007QUFDbmEsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsNEJBQTRCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELElBQUk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNFpBQTRaO0FBQ3hhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG1CQUFtQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkJBQTJCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx5QkFBeUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0JBQW9CO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEdBQUcsR0FBRyxTQUFTO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGFBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlDQUFpQztBQUNqQyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMseUNBQXlDO0FBQ3pDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFzTTtBQUNsTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsT0FBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0NBQXNDO0FBQ3BGLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLGVBQWUsZ0JBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxJQUFJO0FBQ2YsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUE2QztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHVDQUF1QztBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUpBQXVKO0FBQ3ZKLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGdDQUFnQztBQUNoQyxpQ0FBaUMsTUFBTSwwQkFBMEI7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FB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QXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxT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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6Qjs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLElBQUk7QUFDZCxVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixVQUFVLFNBQVM7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUEsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVcsR0FBRyxRQUFRLFdBQVc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNB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Q0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RUFBeUUsNkJBQTZCO0FBQ3RHLGtDQUFrQyw0QkFBNEI7QUFDOUQ7QUFDQSwyRUFBMkUsNkJBQTZCO0FBQ3hHLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QywwQkFBMEI7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUUrQiIsInNvdXJjZXMiOlsid2VicGFjazovL215LXYwLXByb2plY3QvLi9ub2RlX21vZHVsZXMvbWl4cGFuZWwtYnJvd3Nlci9kaXN0L21peHBhbmVsLm1vZHVsZS5qcz84MzU3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBOb2RlVHlwZTtcclxuKGZ1bmN0aW9uIChOb2RlVHlwZSkge1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJEb2N1bWVudFwiXSA9IDBdID0gXCJEb2N1bWVudFwiO1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJEb2N1bWVudFR5cGVcIl0gPSAxXSA9IFwiRG9jdW1lbnRUeXBlXCI7XHJcbiAgICBOb2RlVHlwZVtOb2RlVHlwZVtcIkVsZW1lbnRcIl0gPSAyXSA9IFwiRWxlbWVudFwiO1xyXG4gICAgTm9kZVR5cGVbTm9kZVR5cGVbXCJUZXh0XCJdID0gM10gPSBcIlRleHRcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiQ0RBVEFcIl0gPSA0XSA9IFwiQ0RBVEFcIjtcclxuICAgIE5vZGVUeXBlW05vZGVUeXBlW1wiQ29tbWVudFwiXSA9IDVdID0gXCJDb21tZW50XCI7XHJcbn0pKE5vZGVUeXBlIHx8IChOb2RlVHlwZSA9IHt9KSk7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChuKSB7XHJcbiAgICByZXR1cm4gbi5ub2RlVHlwZSA9PT0gbi5FTEVNRU5UX05PREU7XHJcbn1cclxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG4pIHtcclxuICAgIGNvbnN0IGhvc3QgPSBuID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uaG9zdDtcclxuICAgIHJldHVybiBCb29sZWFuKChob3N0ID09PSBudWxsIHx8IGhvc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGhvc3Quc2hhZG93Um9vdCkgPT09IG4pO1xyXG59XHJcbmZ1bmN0aW9uIGlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QpIHtcclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc2hhZG93Um9vdCkgPT09ICdbb2JqZWN0IFNoYWRvd1Jvb3RdJztcclxufVxyXG5mdW5jdGlvbiBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKGNzc1RleHQpIHtcclxuICAgIGlmIChjc3NUZXh0LmluY2x1ZGVzKCcgYmFja2dyb3VuZC1jbGlwOiB0ZXh0OycpICYmXHJcbiAgICAgICAgIWNzc1RleHQuaW5jbHVkZXMoJyAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDsnKSkge1xyXG4gICAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoJyBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7JywgJyAtd2Via2l0LWJhY2tncm91bmQtY2xpcDogdGV4dDsgYmFja2dyb3VuZC1jbGlwOiB0ZXh0OycpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNzc1RleHQ7XHJcbn1cclxuZnVuY3Rpb24gZXNjYXBlSW1wb3J0U3RhdGVtZW50KHJ1bGUpIHtcclxuICAgIGNvbnN0IHsgY3NzVGV4dCB9ID0gcnVsZTtcclxuICAgIGlmIChjc3NUZXh0LnNwbGl0KCdcIicpLmxlbmd0aCA8IDMpXHJcbiAgICAgICAgcmV0dXJuIGNzc1RleHQ7XHJcbiAgICBjb25zdCBzdGF0ZW1lbnQgPSBbJ0BpbXBvcnQnLCBgdXJsKCR7SlNPTi5zdHJpbmdpZnkocnVsZS5ocmVmKX0pYF07XHJcbiAgICBpZiAocnVsZS5sYXllck5hbWUgPT09ICcnKSB7XHJcbiAgICAgICAgc3RhdGVtZW50LnB1c2goYGxheWVyYCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChydWxlLmxheWVyTmFtZSkge1xyXG4gICAgICAgIHN0YXRlbWVudC5wdXNoKGBsYXllcigke3J1bGUubGF5ZXJOYW1lfSlgKTtcclxuICAgIH1cclxuICAgIGlmIChydWxlLnN1cHBvcnRzVGV4dCkge1xyXG4gICAgICAgIHN0YXRlbWVudC5wdXNoKGBzdXBwb3J0cygke3J1bGUuc3VwcG9ydHNUZXh0fSlgKTtcclxuICAgIH1cclxuICAgIGlmIChydWxlLm1lZGlhLmxlbmd0aCkge1xyXG4gICAgICAgIHN0YXRlbWVudC5wdXNoKHJ1bGUubWVkaWEubWVkaWFUZXh0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGF0ZW1lbnQuam9pbignICcpICsgJzsnO1xyXG59XHJcbmZ1bmN0aW9uIHN0cmluZ2lmeVN0eWxlc2hlZXQocykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBydWxlcyA9IHMucnVsZXMgfHwgcy5jc3NSdWxlcztcclxuICAgICAgICByZXR1cm4gcnVsZXNcclxuICAgICAgICAgICAgPyBmaXhCcm93c2VyQ29tcGF0aWJpbGl0eUlzc3Vlc0luQ1NTKEFycmF5LmZyb20ocnVsZXMsIHN0cmluZ2lmeVJ1bGUpLmpvaW4oJycpKVxyXG4gICAgICAgICAgICA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBzdHJpbmdpZnlSdWxlKHJ1bGUpIHtcclxuICAgIGxldCBpbXBvcnRTdHJpbmdpZmllZDtcclxuICAgIGlmIChpc0NTU0ltcG9ydFJ1bGUocnVsZSkpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpbXBvcnRTdHJpbmdpZmllZCA9XHJcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnlTdHlsZXNoZWV0KHJ1bGUuc3R5bGVTaGVldCkgfHxcclxuICAgICAgICAgICAgICAgICAgICBlc2NhcGVJbXBvcnRTdGF0ZW1lbnQocnVsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzQ1NTU3R5bGVSdWxlKHJ1bGUpICYmIHJ1bGUuc2VsZWN0b3JUZXh0LmluY2x1ZGVzKCc6JykpIHtcclxuICAgICAgICByZXR1cm4gZml4U2FmYXJpQ29sb25zKHJ1bGUuY3NzVGV4dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW1wb3J0U3RyaW5naWZpZWQgfHwgcnVsZS5jc3NUZXh0O1xyXG59XHJcbmZ1bmN0aW9uIGZpeFNhZmFyaUNvbG9ucyhjc3NTdHJpbmdpZmllZCkge1xyXG4gICAgY29uc3QgcmVnZXggPSAvKFxcWyg/OltcXHctXSspW15cXFxcXSkoOig/OltcXHctXSspXFxdKS9nbTtcclxuICAgIHJldHVybiBjc3NTdHJpbmdpZmllZC5yZXBsYWNlKHJlZ2V4LCAnJDFcXFxcJDInKTtcclxufVxyXG5mdW5jdGlvbiBpc0NTU0ltcG9ydFJ1bGUocnVsZSkge1xyXG4gICAgcmV0dXJuICdzdHlsZVNoZWV0JyBpbiBydWxlO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ1NTU3R5bGVSdWxlKHJ1bGUpIHtcclxuICAgIHJldHVybiAnc2VsZWN0b3JUZXh0JyBpbiBydWxlO1xyXG59XHJcbmNsYXNzIE1pcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmlkTm9kZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm5vZGVNZXRhTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxuICAgIGdldElkKG4pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCFuKVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgY29uc3QgaWQgPSAoX2EgPSB0aGlzLmdldE1ldGEobikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZDtcclxuICAgICAgICByZXR1cm4gaWQgIT09IG51bGwgJiYgaWQgIT09IHZvaWQgMCA/IGlkIDogLTE7XHJcbiAgICB9XHJcbiAgICBnZXROb2RlKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWROb2RlTWFwLmdldChpZCkgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIGdldElkcygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmlkTm9kZU1hcC5rZXlzKCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0TWV0YShuKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuZ2V0KG4pIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICByZW1vdmVOb2RlRnJvbU1hcChuKSB7XHJcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLmdldElkKG4pO1xyXG4gICAgICAgIHRoaXMuaWROb2RlTWFwLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgaWYgKG4uY2hpbGROb2Rlcykge1xyXG4gICAgICAgICAgICBuLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB0aGlzLnJlbW92ZU5vZGVGcm9tTWFwKGNoaWxkTm9kZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhhcyhpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlkTm9kZU1hcC5oYXMoaWQpO1xyXG4gICAgfVxyXG4gICAgaGFzTm9kZShub2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZU1ldGFNYXAuaGFzKG5vZGUpO1xyXG4gICAgfVxyXG4gICAgYWRkKG4sIG1ldGEpIHtcclxuICAgICAgICBjb25zdCBpZCA9IG1ldGEuaWQ7XHJcbiAgICAgICAgdGhpcy5pZE5vZGVNYXAuc2V0KGlkLCBuKTtcclxuICAgICAgICB0aGlzLm5vZGVNZXRhTWFwLnNldChuLCBtZXRhKTtcclxuICAgIH1cclxuICAgIHJlcGxhY2UoaWQsIG4pIHtcclxuICAgICAgICBjb25zdCBvbGROb2RlID0gdGhpcy5nZXROb2RlKGlkKTtcclxuICAgICAgICBpZiAob2xkTm9kZSkge1xyXG4gICAgICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5ub2RlTWV0YU1hcC5nZXQob2xkTm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChtZXRhKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlTWV0YU1hcC5zZXQobiwgbWV0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWROb2RlTWFwLnNldChpZCwgbik7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLmlkTm9kZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLm5vZGVNZXRhTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBjcmVhdGVNaXJyb3IoKSB7XHJcbiAgICByZXR1cm4gbmV3IE1pcnJvcigpO1xyXG59XHJcbmZ1bmN0aW9uIG1hc2tJbnB1dFZhbHVlKHsgZWxlbWVudCwgbWFza0lucHV0T3B0aW9ucywgdGFnTmFtZSwgdHlwZSwgdmFsdWUsIG1hc2tJbnB1dEZuLCB9KSB7XHJcbiAgICBsZXQgdGV4dCA9IHZhbHVlIHx8ICcnO1xyXG4gICAgY29uc3QgYWN0dWFsVHlwZSA9IHR5cGUgJiYgdG9Mb3dlckNhc2UodHlwZSk7XHJcbiAgICBpZiAobWFza0lucHV0T3B0aW9uc1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8XHJcbiAgICAgICAgKGFjdHVhbFR5cGUgJiYgbWFza0lucHV0T3B0aW9uc1thY3R1YWxUeXBlXSkpIHtcclxuICAgICAgICBpZiAobWFza0lucHV0Rm4pIHtcclxuICAgICAgICAgICAgdGV4dCA9IG1hc2tJbnB1dEZuKHRleHQsIGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGV4dCA9ICcqJy5yZXBlYXQodGV4dC5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0ZXh0O1xyXG59XHJcbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbmNvbnN0IE9SSUdJTkFMX0FUVFJJQlVURV9OQU1FID0gJ19fcnJ3ZWJfb3JpZ2luYWxfXyc7XHJcbmZ1bmN0aW9uIGlzMkRDYW52YXNCbGFuayhjYW52YXMpIHtcclxuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgaWYgKCFjdHgpXHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBjb25zdCBjaHVua1NpemUgPSA1MDtcclxuICAgIGZvciAobGV0IHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4ICs9IGNodW5rU2l6ZSkge1xyXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSArPSBjaHVua1NpemUpIHtcclxuICAgICAgICAgICAgY29uc3QgZ2V0SW1hZ2VEYXRhID0gY3R4LmdldEltYWdlRGF0YTtcclxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxHZXRJbWFnZURhdGEgPSBPUklHSU5BTF9BVFRSSUJVVEVfTkFNRSBpbiBnZXRJbWFnZURhdGFcclxuICAgICAgICAgICAgICAgID8gZ2V0SW1hZ2VEYXRhW09SSUdJTkFMX0FUVFJJQlVURV9OQU1FXVxyXG4gICAgICAgICAgICAgICAgOiBnZXRJbWFnZURhdGE7XHJcbiAgICAgICAgICAgIGNvbnN0IHBpeGVsQnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KG9yaWdpbmFsR2V0SW1hZ2VEYXRhLmNhbGwoY3R4LCB4LCB5LCBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy53aWR0aCAtIHgpLCBNYXRoLm1pbihjaHVua1NpemUsIGNhbnZhcy5oZWlnaHQgLSB5KSkuZGF0YS5idWZmZXIpO1xyXG4gICAgICAgICAgICBpZiAocGl4ZWxCdWZmZXIuc29tZSgocGl4ZWwpID0+IHBpeGVsICE9PSAwKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBnZXRJbnB1dFR5cGUoZWxlbWVudCkge1xyXG4gICAgY29uc3QgdHlwZSA9IGVsZW1lbnQudHlwZTtcclxuICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGF0YS1yci1pcy1wYXNzd29yZCcpXHJcbiAgICAgICAgPyAncGFzc3dvcmQnXHJcbiAgICAgICAgOiB0eXBlXHJcbiAgICAgICAgICAgID9cclxuICAgICAgICAgICAgICAgIHRvTG93ZXJDYXNlKHR5cGUpXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0RmlsZUV4dGVuc2lvbihwYXRoLCBiYXNlVVJMKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBsZXQgdXJsO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGJhc2VVUkwgIT09IG51bGwgJiYgYmFzZVVSTCAhPT0gdm9pZCAwID8gYmFzZVVSTCA6IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlZ2V4ID0gL1xcLihbMC05YS16XSspKD86JCkvaTtcclxuICAgIGNvbnN0IG1hdGNoID0gdXJsLnBhdGhuYW1lLm1hdGNoKHJlZ2V4KTtcclxuICAgIHJldHVybiAoX2EgPSBtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF0Y2hbMV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XHJcbn1cblxubGV0IF9pZCA9IDE7XHJcbmNvbnN0IHRhZ05hbWVSZWdleCA9IG5ldyBSZWdFeHAoJ1teYS16MC05LV86XScpO1xyXG5jb25zdCBJR05PUkVEX05PREUgPSAtMjtcclxuZnVuY3Rpb24gZ2VuSWQoKSB7XHJcbiAgICByZXR1cm4gX2lkKys7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VmFsaWRUYWdOYW1lKGVsZW1lbnQpIHtcclxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuICdmb3JtJztcclxuICAgIH1cclxuICAgIGNvbnN0IHByb2Nlc3NlZFRhZ05hbWUgPSB0b0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xyXG4gICAgaWYgKHRhZ05hbWVSZWdleC50ZXN0KHByb2Nlc3NlZFRhZ05hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICdkaXYnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHByb2Nlc3NlZFRhZ05hbWU7XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdE9yaWdpbih1cmwpIHtcclxuICAgIGxldCBvcmlnaW4gPSAnJztcclxuICAgIGlmICh1cmwuaW5kZXhPZignLy8nKSA+IC0xKSB7XHJcbiAgICAgICAgb3JpZ2luID0gdXJsLnNwbGl0KCcvJykuc2xpY2UoMCwgMykuam9pbignLycpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgb3JpZ2luID0gdXJsLnNwbGl0KCcvJylbMF07XHJcbiAgICB9XHJcbiAgICBvcmlnaW4gPSBvcmlnaW4uc3BsaXQoJz8nKVswXTtcclxuICAgIHJldHVybiBvcmlnaW47XHJcbn1cclxubGV0IGNhbnZhc1NlcnZpY2U7XHJcbmxldCBjYW52YXNDdHg7XHJcbmNvbnN0IFVSTF9JTl9DU1NfUkVGID0gL3VybFxcKCg/OignKShbXiddKiknfChcIikoLio/KVwifChbXildKikpXFwpL2dtO1xyXG5jb25zdCBVUkxfUFJPVE9DT0xfTUFUQ0ggPSAvXig/OlthLXorXSs6KT9cXC9cXC8vaTtcclxuY29uc3QgVVJMX1dXV19NQVRDSCA9IC9ed3d3XFwuLiovaTtcclxuY29uc3QgREFUQV9VUkkgPSAvXihkYXRhOikoW14sXSopLCguKikvaTtcclxuZnVuY3Rpb24gYWJzb2x1dGVUb1N0eWxlc2hlZXQoY3NzVGV4dCwgaHJlZikge1xyXG4gICAgcmV0dXJuIChjc3NUZXh0IHx8ICcnKS5yZXBsYWNlKFVSTF9JTl9DU1NfUkVGLCAob3JpZ2luLCBxdW90ZTEsIHBhdGgxLCBxdW90ZTIsIHBhdGgyLCBwYXRoMykgPT4ge1xyXG4gICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aDEgfHwgcGF0aDIgfHwgcGF0aDM7XHJcbiAgICAgICAgY29uc3QgbWF5YmVRdW90ZSA9IHF1b3RlMSB8fCBxdW90ZTIgfHwgJyc7XHJcbiAgICAgICAgaWYgKCFmaWxlUGF0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoVVJMX1BST1RPQ09MX01BVENILnRlc3QoZmlsZVBhdGgpIHx8IFVSTF9XV1dfTUFUQ0gudGVzdChmaWxlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZmlsZVBhdGh9JHttYXliZVF1b3RlfSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoREFUQV9VUkkudGVzdChmaWxlUGF0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGB1cmwoJHttYXliZVF1b3RlfSR7ZmlsZVBhdGh9JHttYXliZVF1b3RlfSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmlsZVBhdGhbMF0gPT09ICcvJykge1xyXG4gICAgICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtleHRyYWN0T3JpZ2luKGhyZWYpICsgZmlsZVBhdGh9JHttYXliZVF1b3RlfSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzdGFjayA9IGhyZWYuc3BsaXQoJy8nKTtcclxuICAgICAgICBjb25zdCBwYXJ0cyA9IGZpbGVQYXRoLnNwbGl0KCcvJyk7XHJcbiAgICAgICAgc3RhY2sucG9wKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnRzKSB7XHJcbiAgICAgICAgICAgIGlmIChwYXJ0ID09PSAnLicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHBhcnQgPT09ICcuLicpIHtcclxuICAgICAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChwYXJ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYHVybCgke21heWJlUXVvdGV9JHtzdGFjay5qb2luKCcvJyl9JHttYXliZVF1b3RlfSlgO1xyXG4gICAgfSk7XHJcbn1cclxuY29uc3QgU1JDU0VUX05PVF9TUEFDRVMgPSAvXlteIFxcdFxcblxcclxcdTAwMGNdKy87XHJcbmNvbnN0IFNSQ1NFVF9DT01NQVNfT1JfU1BBQ0VTID0gL15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvO1xyXG5mdW5jdGlvbiBnZXRBYnNvbHV0ZVNyY3NldFN0cmluZyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XHJcbiAgICBpZiAoYXR0cmlidXRlVmFsdWUudHJpbSgpID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZTtcclxuICAgIH1cclxuICAgIGxldCBwb3MgPSAwO1xyXG4gICAgZnVuY3Rpb24gY29sbGVjdENoYXJhY3RlcnMocmVnRXgpIHtcclxuICAgICAgICBsZXQgY2hhcnM7XHJcbiAgICAgICAgY29uc3QgbWF0Y2ggPSByZWdFeC5leGVjKGF0dHJpYnV0ZVZhbHVlLnN1YnN0cmluZyhwb3MpKTtcclxuICAgICAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgICAgICAgY2hhcnMgPSBtYXRjaFswXTtcclxuICAgICAgICAgICAgcG9zICs9IGNoYXJzLmxlbmd0aDtcclxuICAgICAgICAgICAgcmV0dXJuIGNoYXJzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX0NPTU1BU19PUl9TUEFDRVMpO1xyXG4gICAgICAgIGlmIChwb3MgPj0gYXR0cmlidXRlVmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgdXJsID0gY29sbGVjdENoYXJhY3RlcnMoU1JDU0VUX05PVF9TUEFDRVMpO1xyXG4gICAgICAgIGlmICh1cmwuc2xpY2UoLTEpID09PSAnLCcpIHtcclxuICAgICAgICAgICAgdXJsID0gYWJzb2x1dGVUb0RvYyhkb2MsIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxlbmd0aCAtIDEpKTtcclxuICAgICAgICAgICAgb3V0cHV0LnB1c2godXJsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBkZXNjcmlwdG9yc1N0ciA9ICcnO1xyXG4gICAgICAgICAgICB1cmwgPSBhYnNvbHV0ZVRvRG9jKGRvYywgdXJsKTtcclxuICAgICAgICAgICAgbGV0IGluUGFyZW5zID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjID0gYXR0cmlidXRlVmFsdWUuY2hhckF0KHBvcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgodXJsICsgZGVzY3JpcHRvcnNTdHIpLnRyaW0oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghaW5QYXJlbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJywnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgodXJsICsgZGVzY3JpcHRvcnNTdHIpLnRyaW0oKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5QYXJlbnMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjID09PSAnKScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5QYXJlbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yc1N0ciArPSBjO1xyXG4gICAgICAgICAgICAgICAgcG9zICs9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0LmpvaW4oJywgJyk7XHJcbn1cclxuZnVuY3Rpb24gYWJzb2x1dGVUb0RvYyhkb2MsIGF0dHJpYnV0ZVZhbHVlKSB7XHJcbiAgICBpZiAoIWF0dHJpYnV0ZVZhbHVlIHx8IGF0dHJpYnV0ZVZhbHVlLnRyaW0oKSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gYXR0cmlidXRlVmFsdWU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICAgIGEuaHJlZiA9IGF0dHJpYnV0ZVZhbHVlO1xyXG4gICAgcmV0dXJuIGEuaHJlZjtcclxufVxyXG5mdW5jdGlvbiBpc1NWR0VsZW1lbnQoZWwpIHtcclxuICAgIHJldHVybiBCb29sZWFuKGVsLnRhZ05hbWUgPT09ICdzdmcnIHx8IGVsLm93bmVyU1ZHRWxlbWVudCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0SHJlZigpIHtcclxuICAgIGNvbnN0IGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XHJcbiAgICBhLmhyZWYgPSAnJztcclxuICAgIHJldHVybiBhLmhyZWY7XHJcbn1cclxuZnVuY3Rpb24gdHJhbnNmb3JtQXR0cmlidXRlKGRvYywgdGFnTmFtZSwgbmFtZSwgdmFsdWUpIHtcclxuICAgIGlmICghdmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZSA9PT0gJ3NyYycgfHxcclxuICAgICAgICAobmFtZSA9PT0gJ2hyZWYnICYmICEodGFnTmFtZSA9PT0gJ3VzZScgJiYgdmFsdWVbMF0gPT09ICcjJykpKSB7XHJcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuYW1lID09PSAneGxpbms6aHJlZicgJiYgdmFsdWVbMF0gIT09ICcjJykge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ2JhY2tncm91bmQnICYmXHJcbiAgICAgICAgKHRhZ05hbWUgPT09ICd0YWJsZScgfHwgdGFnTmFtZSA9PT0gJ3RkJyB8fCB0YWdOYW1lID09PSAndGgnKSkge1xyXG4gICAgICAgIHJldHVybiBhYnNvbHV0ZVRvRG9jKGRvYywgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gJ3NyY3NldCcpIHtcclxuICAgICAgICByZXR1cm4gZ2V0QWJzb2x1dGVTcmNzZXRTdHJpbmcoZG9jLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChuYW1lID09PSAnc3R5bGUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9TdHlsZXNoZWV0KHZhbHVlLCBnZXRIcmVmKCkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGFnTmFtZSA9PT0gJ29iamVjdCcgJiYgbmFtZSA9PT0gJ2RhdGEnKSB7XHJcbiAgICAgICAgcmV0dXJuIGFic29sdXRlVG9Eb2MoZG9jLCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gaWdub3JlQXR0cmlidXRlKHRhZ05hbWUsIG5hbWUsIF92YWx1ZSkge1xyXG4gICAgcmV0dXJuICh0YWdOYW1lID09PSAndmlkZW8nIHx8IHRhZ05hbWUgPT09ICdhdWRpbycpICYmIG5hbWUgPT09ICdhdXRvcGxheSc7XHJcbn1cclxuZnVuY3Rpb24gX2lzQmxvY2tlZEVsZW1lbnQoZWxlbWVudCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrQ2xhc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhibG9ja0NsYXNzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGVJbmRleCA9IGVsZW1lbnQuY2xhc3NMaXN0Lmxlbmd0aDsgZUluZGV4LS07KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBlbGVtZW50LmNsYXNzTGlzdFtlSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrQ2xhc3MudGVzdChjbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGJsb2NrU2VsZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQubWF0Y2hlcyhibG9ja1NlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIGNsYXNzTWF0Y2hlc1JlZ2V4KG5vZGUsIHJlZ2V4LCBjaGVja0FuY2VzdG9ycykge1xyXG4gICAgaWYgKCFub2RlKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBub2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICAgIGlmICghY2hlY2tBbmNlc3RvcnMpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gY2xhc3NNYXRjaGVzUmVnZXgobm9kZS5wYXJlbnROb2RlLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpO1xyXG4gICAgfVxyXG4gICAgZm9yIChsZXQgZUluZGV4ID0gbm9kZS5jbGFzc0xpc3QubGVuZ3RoOyBlSW5kZXgtLTspIHtcclxuICAgICAgICBjb25zdCBjbGFzc05hbWUgPSBub2RlLmNsYXNzTGlzdFtlSW5kZXhdO1xyXG4gICAgICAgIGlmIChyZWdleC50ZXN0KGNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFjaGVja0FuY2VzdG9ycylcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gY2xhc3NNYXRjaGVzUmVnZXgobm9kZS5wYXJlbnROb2RlLCByZWdleCwgY2hlY2tBbmNlc3RvcnMpO1xyXG59XHJcbmZ1bmN0aW9uIG5lZWRNYXNraW5nVGV4dChub2RlLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBjaGVja0FuY2VzdG9ycykge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBlbCA9IG5vZGUubm9kZVR5cGUgPT09IG5vZGUuRUxFTUVOVF9OT0RFXHJcbiAgICAgICAgICAgID8gbm9kZVxyXG4gICAgICAgICAgICA6IG5vZGUucGFyZW50RWxlbWVudDtcclxuICAgICAgICBpZiAoZWwgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICBpZiAodHlwZW9mIG1hc2tUZXh0Q2xhc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGVja0FuY2VzdG9ycykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLmNsb3Nlc3QoYC4ke21hc2tUZXh0Q2xhc3N9YCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG1hc2tUZXh0Q2xhc3MpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY2xhc3NNYXRjaGVzUmVnZXgoZWwsIG1hc2tUZXh0Q2xhc3MsIGNoZWNrQW5jZXN0b3JzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWFza1RleHRTZWxlY3Rvcikge1xyXG4gICAgICAgICAgICBpZiAoY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlbC5jbG9zZXN0KG1hc2tUZXh0U2VsZWN0b3IpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsLm1hdGNoZXMobWFza1RleHRTZWxlY3RvcikpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbmZ1bmN0aW9uIG9uY2VJZnJhbWVMb2FkZWQoaWZyYW1lRWwsIGxpc3RlbmVyLCBpZnJhbWVMb2FkVGltZW91dCkge1xyXG4gICAgY29uc3Qgd2luID0gaWZyYW1lRWwuY29udGVudFdpbmRvdztcclxuICAgIGlmICghd2luKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IGZpcmVkID0gZmFsc2U7XHJcbiAgICBsZXQgcmVhZHlTdGF0ZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVhZHlTdGF0ZSA9IHdpbi5kb2N1bWVudC5yZWFkeVN0YXRlO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpIHtcclxuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWZpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcigpO1xyXG4gICAgICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgaWZyYW1lTG9hZFRpbWVvdXQpO1xyXG4gICAgICAgIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XHJcbiAgICAgICAgICAgIGZpcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBjb25zdCBibGFua1VybCA9ICdhYm91dDpibGFuayc7XHJcbiAgICBpZiAod2luLmxvY2F0aW9uLmhyZWYgIT09IGJsYW5rVXJsIHx8XHJcbiAgICAgICAgaWZyYW1lRWwuc3JjID09PSBibGFua1VybCB8fFxyXG4gICAgICAgIGlmcmFtZUVsLnNyYyA9PT0gJycpIHtcclxuICAgICAgICBzZXRUaW1lb3V0KGxpc3RlbmVyLCAwKTtcclxuICAgICAgICByZXR1cm4gaWZyYW1lRWwuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxpc3RlbmVyKTtcclxuICAgIH1cclxuICAgIGlmcmFtZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBsaXN0ZW5lcik7XHJcbn1cclxuZnVuY3Rpb24gb25jZVN0eWxlc2hlZXRMb2FkZWQobGluaywgbGlzdGVuZXIsIHN0eWxlU2hlZXRMb2FkVGltZW91dCkge1xyXG4gICAgbGV0IGZpcmVkID0gZmFsc2U7XHJcbiAgICBsZXQgc3R5bGVTaGVldExvYWRlZDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgc3R5bGVTaGVldExvYWRlZCA9IGxpbmsuc2hlZXQ7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoc3R5bGVTaGVldExvYWRlZClcclxuICAgICAgICByZXR1cm47XHJcbiAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGlmICghZmlyZWQpIHtcclxuICAgICAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgICAgICAgICAgZmlyZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0sIHN0eWxlU2hlZXRMb2FkVGltZW91dCk7XHJcbiAgICBsaW5rLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgICBmaXJlZCA9IHRydWU7XHJcbiAgICAgICAgbGlzdGVuZXIoKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZU5vZGUobiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbmVlZHNNYXNrLCBpbmxpbmVTdHlsZXNoZWV0LCBtYXNrSW5wdXRPcHRpb25zID0ge30sIG1hc2tUZXh0Rm4sIG1hc2tJbnB1dEZuLCBkYXRhVVJMT3B0aW9ucyA9IHt9LCBpbmxpbmVJbWFnZXMsIHJlY29yZENhbnZhcywga2VlcElmcmFtZVNyY0ZuLCBuZXdseUFkZGVkRWxlbWVudCA9IGZhbHNlLCB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHJvb3RJZCA9IGdldFJvb3RJZChkb2MsIG1pcnJvcik7XHJcbiAgICBzd2l0Y2ggKG4ubm9kZVR5cGUpIHtcclxuICAgICAgICBjYXNlIG4uRE9DVU1FTlRfTk9ERTpcclxuICAgICAgICAgICAgaWYgKG4uY29tcGF0TW9kZSAhPT0gJ0NTUzFDb21wYXQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlLkRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhdE1vZGU6IG4uY29tcGF0TW9kZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlLkRvY3VtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkTm9kZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIGNhc2Ugbi5ET0NVTUVOVF9UWVBFX05PREU6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Eb2N1bWVudFR5cGUsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBuLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBwdWJsaWNJZDogbi5wdWJsaWNJZCxcclxuICAgICAgICAgICAgICAgIHN5c3RlbUlkOiBuLnN5c3RlbUlkLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNhc2Ugbi5FTEVNRU5UX05PREU6XHJcbiAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemVFbGVtZW50Tm9kZShuLCB7XHJcbiAgICAgICAgICAgICAgICBkb2MsXHJcbiAgICAgICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICAgICAgICAgIG5ld2x5QWRkZWRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgcm9vdElkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICBjYXNlIG4uVEVYVF9OT0RFOlxyXG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVGV4dE5vZGUobiwge1xyXG4gICAgICAgICAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgICAgIHJvb3RJZCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY2FzZSBuLkNEQVRBX1NFQ1RJT05fTk9ERTpcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6IE5vZGVUeXBlLkNEQVRBLFxyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQ6ICcnLFxyXG4gICAgICAgICAgICAgICAgcm9vdElkLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGNhc2Ugbi5DT01NRU5UX05PREU6XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBOb2RlVHlwZS5Db21tZW50LFxyXG4gICAgICAgICAgICAgICAgdGV4dENvbnRlbnQ6IG4udGV4dENvbnRlbnQgfHwgJycsXHJcbiAgICAgICAgICAgICAgICByb290SWQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFJvb3RJZChkb2MsIG1pcnJvcikge1xyXG4gICAgaWYgKCFtaXJyb3IuaGFzTm9kZShkb2MpKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBkb2NJZCA9IG1pcnJvci5nZXRJZChkb2MpO1xyXG4gICAgcmV0dXJuIGRvY0lkID09PSAxID8gdW5kZWZpbmVkIDogZG9jSWQ7XHJcbn1cclxuZnVuY3Rpb24gc2VyaWFsaXplVGV4dE5vZGUobiwgb3B0aW9ucykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgY29uc3QgeyBuZWVkc01hc2ssIG1hc2tUZXh0Rm4sIHJvb3RJZCB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHBhcmVudFRhZ05hbWUgPSBuLnBhcmVudE5vZGUgJiYgbi5wYXJlbnROb2RlLnRhZ05hbWU7XHJcbiAgICBsZXQgdGV4dENvbnRlbnQgPSBuLnRleHRDb250ZW50O1xyXG4gICAgY29uc3QgaXNTdHlsZSA9IHBhcmVudFRhZ05hbWUgPT09ICdTVFlMRScgPyB0cnVlIDogdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaXNTY3JpcHQgPSBwYXJlbnRUYWdOYW1lID09PSAnU0NSSVBUJyA/IHRydWUgOiB1bmRlZmluZWQ7XHJcbiAgICBpZiAoaXNTdHlsZSAmJiB0ZXh0Q29udGVudCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChuLm5leHRTaWJsaW5nIHx8IG4ucHJldmlvdXNTaWJsaW5nKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKF9hID0gbi5wYXJlbnROb2RlLnNoZWV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3NzUnVsZXMpIHtcclxuICAgICAgICAgICAgICAgIHRleHRDb250ZW50ID0gc3RyaW5naWZ5U3R5bGVzaGVldChuLnBhcmVudE5vZGUuc2hlZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKGBDYW5ub3QgZ2V0IENTUyBzdHlsZXMgZnJvbSB0ZXh0J3MgcGFyZW50Tm9kZS4gRXJyb3I6ICR7ZXJyfWAsIG4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXh0Q29udGVudCA9IGFic29sdXRlVG9TdHlsZXNoZWV0KHRleHRDb250ZW50LCBnZXRIcmVmKCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzU2NyaXB0KSB7XHJcbiAgICAgICAgdGV4dENvbnRlbnQgPSAnU0NSSVBUX1BMQUNFSE9MREVSJztcclxuICAgIH1cclxuICAgIGlmICghaXNTdHlsZSAmJiAhaXNTY3JpcHQgJiYgdGV4dENvbnRlbnQgJiYgbmVlZHNNYXNrKSB7XHJcbiAgICAgICAgdGV4dENvbnRlbnQgPSBtYXNrVGV4dEZuXHJcbiAgICAgICAgICAgID8gbWFza1RleHRGbih0ZXh0Q29udGVudCwgbi5wYXJlbnRFbGVtZW50KVxyXG4gICAgICAgICAgICA6IHRleHRDb250ZW50LnJlcGxhY2UoL1tcXFNdL2csICcqJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IE5vZGVUeXBlLlRleHQsXHJcbiAgICAgICAgdGV4dENvbnRlbnQ6IHRleHRDb250ZW50IHx8ICcnLFxyXG4gICAgICAgIGlzU3R5bGUsXHJcbiAgICAgICAgcm9vdElkLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVFbGVtZW50Tm9kZShuLCBvcHRpb25zKSB7XHJcbiAgICBjb25zdCB7IGRvYywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgaW5saW5lU3R5bGVzaGVldCwgbWFza0lucHV0T3B0aW9ucyA9IHt9LCBtYXNrSW5wdXRGbiwgZGF0YVVSTE9wdGlvbnMgPSB7fSwgaW5saW5lSW1hZ2VzLCByZWNvcmRDYW52YXMsIGtlZXBJZnJhbWVTcmNGbiwgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSwgcm9vdElkLCB9ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IG5lZWRCbG9jayA9IF9pc0Jsb2NrZWRFbGVtZW50KG4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpO1xyXG4gICAgY29uc3QgdGFnTmFtZSA9IGdldFZhbGlkVGFnTmFtZShuKTtcclxuICAgIGxldCBhdHRyaWJ1dGVzID0ge307XHJcbiAgICBjb25zdCBsZW4gPSBuLmF0dHJpYnV0ZXMubGVuZ3RoO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGF0dHIgPSBuLmF0dHJpYnV0ZXNbaV07XHJcbiAgICAgICAgaWYgKCFpZ25vcmVBdHRyaWJ1dGUodGFnTmFtZSwgYXR0ci5uYW1lLCBhdHRyLnZhbHVlKSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzW2F0dHIubmFtZV0gPSB0cmFuc2Zvcm1BdHRyaWJ1dGUoZG9jLCB0YWdOYW1lLCB0b0xvd2VyQ2FzZShhdHRyLm5hbWUpLCBhdHRyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2xpbmsnICYmIGlubGluZVN0eWxlc2hlZXQpIHtcclxuICAgICAgICBjb25zdCBzdHlsZXNoZWV0ID0gQXJyYXkuZnJvbShkb2Muc3R5bGVTaGVldHMpLmZpbmQoKHMpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHMuaHJlZiA9PT0gbi5ocmVmO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGxldCBjc3NUZXh0ID0gbnVsbDtcclxuICAgICAgICBpZiAoc3R5bGVzaGVldCkge1xyXG4gICAgICAgICAgICBjc3NUZXh0ID0gc3RyaW5naWZ5U3R5bGVzaGVldChzdHlsZXNoZWV0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNzc1RleHQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXMucmVsO1xyXG4gICAgICAgICAgICBkZWxldGUgYXR0cmlidXRlcy5ocmVmO1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLl9jc3NUZXh0ID0gYWJzb2x1dGVUb1N0eWxlc2hlZXQoY3NzVGV4dCwgc3R5bGVzaGVldC5ocmVmKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ3N0eWxlJyAmJlxyXG4gICAgICAgIG4uc2hlZXQgJiZcclxuICAgICAgICAhKG4uaW5uZXJUZXh0IHx8IG4udGV4dENvbnRlbnQgfHwgJycpLnRyaW0oKS5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjc3NUZXh0ID0gc3RyaW5naWZ5U3R5bGVzaGVldChuLnNoZWV0KTtcclxuICAgICAgICBpZiAoY3NzVGV4dCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLl9jc3NUZXh0ID0gYWJzb2x1dGVUb1N0eWxlc2hlZXQoY3NzVGV4dCwgZ2V0SHJlZigpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2lucHV0JyB8fCB0YWdOYW1lID09PSAndGV4dGFyZWEnIHx8IHRhZ05hbWUgPT09ICdzZWxlY3QnKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBuLnZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGNoZWNrZWQgPSBuLmNoZWNrZWQ7XHJcbiAgICAgICAgaWYgKGF0dHJpYnV0ZXMudHlwZSAhPT0gJ3JhZGlvJyAmJlxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnR5cGUgIT09ICdjaGVja2JveCcgJiZcclxuICAgICAgICAgICAgYXR0cmlidXRlcy50eXBlICE9PSAnc3VibWl0JyAmJlxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnR5cGUgIT09ICdidXR0b24nICYmXHJcbiAgICAgICAgICAgIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMudmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBuLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0SW5wdXRUeXBlKG4pLFxyXG4gICAgICAgICAgICAgICAgdGFnTmFtZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY2hlY2tlZCkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmNoZWNrZWQgPSBjaGVja2VkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0YWdOYW1lID09PSAnb3B0aW9uJykge1xyXG4gICAgICAgIGlmIChuLnNlbGVjdGVkICYmICFtYXNrSW5wdXRPcHRpb25zWydzZWxlY3QnXSkge1xyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnNlbGVjdGVkO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICh0YWdOYW1lID09PSAnY2FudmFzJyAmJiByZWNvcmRDYW52YXMpIHtcclxuICAgICAgICBpZiAobi5fX2NvbnRleHQgPT09ICcyZCcpIHtcclxuICAgICAgICAgICAgaWYgKCFpczJEQ2FudmFzQmxhbmsobikpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IG4udG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCEoJ19fY29udGV4dCcgaW4gbikpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FudmFzRGF0YVVSTCA9IG4udG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xyXG4gICAgICAgICAgICBjb25zdCBibGFua0NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICBibGFua0NhbnZhcy53aWR0aCA9IG4ud2lkdGg7XHJcbiAgICAgICAgICAgIGJsYW5rQ2FudmFzLmhlaWdodCA9IG4uaGVpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBibGFua0NhbnZhc0RhdGFVUkwgPSBibGFua0NhbnZhcy50b0RhdGFVUkwoZGF0YVVSTE9wdGlvbnMudHlwZSwgZGF0YVVSTE9wdGlvbnMucXVhbGl0eSk7XHJcbiAgICAgICAgICAgIGlmIChjYW52YXNEYXRhVVJMICE9PSBibGFua0NhbnZhc0RhdGFVUkwpIHtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IGNhbnZhc0RhdGFVUkw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2ltZycgJiYgaW5saW5lSW1hZ2VzKSB7XHJcbiAgICAgICAgaWYgKCFjYW52YXNTZXJ2aWNlKSB7XHJcbiAgICAgICAgICAgIGNhbnZhc1NlcnZpY2UgPSBkb2MuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgIGNhbnZhc0N0eCA9IGNhbnZhc1NlcnZpY2UuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuO1xyXG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gaW1hZ2UuY3Jvc3NPcmlnaW47XHJcbiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgICAgICBjb25zdCByZWNvcmRJbmxpbmVJbWFnZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgaW1hZ2UucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIHJlY29yZElubGluZUltYWdlKTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNhbnZhc1NlcnZpY2Uud2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNTZXJ2aWNlLmhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNDdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfZGF0YVVSTCA9IGNhbnZhc1NlcnZpY2UudG9EYXRhVVJMKGRhdGFVUkxPcHRpb25zLnR5cGUsIGRhdGFVUkxPcHRpb25zLnF1YWxpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ2Fubm90IGlubGluZSBpbWcgc3JjPSR7aW1hZ2UuY3VycmVudFNyY30hIEVycm9yOiAke2Vycn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvbGRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgPyAoYXR0cmlidXRlcy5jcm9zc09yaWdpbiA9IG9sZFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgOiBpbWFnZS5yZW1vdmVBdHRyaWJ1dGUoJ2Nyb3Nzb3JpZ2luJyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoaW1hZ2UuY29tcGxldGUgJiYgaW1hZ2UubmF0dXJhbFdpZHRoICE9PSAwKVxyXG4gICAgICAgICAgICByZWNvcmRJbmxpbmVJbWFnZSgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHJlY29yZElubGluZUltYWdlKTtcclxuICAgIH1cclxuICAgIGlmICh0YWdOYW1lID09PSAnYXVkaW8nIHx8IHRhZ05hbWUgPT09ICd2aWRlbycpIHtcclxuICAgICAgICBjb25zdCBtZWRpYUF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xyXG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYVN0YXRlID0gbi5wYXVzZWRcclxuICAgICAgICAgICAgPyAncGF1c2VkJ1xyXG4gICAgICAgICAgICA6ICdwbGF5ZWQnO1xyXG4gICAgICAgIG1lZGlhQXR0cmlidXRlcy5ycl9tZWRpYUN1cnJlbnRUaW1lID0gbi5jdXJyZW50VGltZTtcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFQbGF5YmFja1JhdGUgPSBuLnBsYXliYWNrUmF0ZTtcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFNdXRlZCA9IG4ubXV0ZWQ7XHJcbiAgICAgICAgbWVkaWFBdHRyaWJ1dGVzLnJyX21lZGlhTG9vcCA9IG4ubG9vcDtcclxuICAgICAgICBtZWRpYUF0dHJpYnV0ZXMucnJfbWVkaWFWb2x1bWUgPSBuLnZvbHVtZTtcclxuICAgIH1cclxuICAgIGlmICghbmV3bHlBZGRlZEVsZW1lbnQpIHtcclxuICAgICAgICBpZiAobi5zY3JvbGxMZWZ0KSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfc2Nyb2xsTGVmdCA9IG4uc2Nyb2xsTGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uc2Nyb2xsVG9wKSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfc2Nyb2xsVG9wID0gbi5zY3JvbGxUb3A7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5lZWRCbG9jaykge1xyXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICBhdHRyaWJ1dGVzID0ge1xyXG4gICAgICAgICAgICBjbGFzczogYXR0cmlidXRlcy5jbGFzcyxcclxuICAgICAgICAgICAgcnJfd2lkdGg6IGAke3dpZHRofXB4YCxcclxuICAgICAgICAgICAgcnJfaGVpZ2h0OiBgJHtoZWlnaHR9cHhgLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpZiAodGFnTmFtZSA9PT0gJ2lmcmFtZScgJiYgIWtlZXBJZnJhbWVTcmNGbihhdHRyaWJ1dGVzLnNyYykpIHtcclxuICAgICAgICBpZiAoIW4uY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGF0dHJpYnV0ZXMucnJfc3JjID0gYXR0cmlidXRlcy5zcmM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzLnNyYztcclxuICAgIH1cclxuICAgIGxldCBpc0N1c3RvbUVsZW1lbnQ7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmIChjdXN0b21FbGVtZW50cy5nZXQodGFnTmFtZSkpXHJcbiAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBOb2RlVHlwZS5FbGVtZW50LFxyXG4gICAgICAgIHRhZ05hbWUsXHJcbiAgICAgICAgYXR0cmlidXRlcyxcclxuICAgICAgICBjaGlsZE5vZGVzOiBbXSxcclxuICAgICAgICBpc1NWRzogaXNTVkdFbGVtZW50KG4pIHx8IHVuZGVmaW5lZCxcclxuICAgICAgICBuZWVkQmxvY2ssXHJcbiAgICAgICAgcm9vdElkLFxyXG4gICAgICAgIGlzQ3VzdG9tOiBpc0N1c3RvbUVsZW1lbnQsXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGxvd2VySWZFeGlzdHMobWF5YmVBdHRyKSB7XHJcbiAgICBpZiAobWF5YmVBdHRyID09PSB1bmRlZmluZWQgfHwgbWF5YmVBdHRyID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIG1heWJlQXR0ci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIHNsaW1ET01FeGNsdWRlZChzbiwgc2xpbURPTU9wdGlvbnMpIHtcclxuICAgIGlmIChzbGltRE9NT3B0aW9ucy5jb21tZW50ICYmIHNuLnR5cGUgPT09IE5vZGVUeXBlLkNvbW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNuLnR5cGUgPT09IE5vZGVUeXBlLkVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoc2xpbURPTU9wdGlvbnMuc2NyaXB0ICYmXHJcbiAgICAgICAgICAgIChzbi50YWdOYW1lID09PSAnc2NyaXB0JyB8fFxyXG4gICAgICAgICAgICAgICAgKHNuLnRhZ05hbWUgPT09ICdsaW5rJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIChzbi5hdHRyaWJ1dGVzLnJlbCA9PT0gJ3ByZWxvYWQnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuLmF0dHJpYnV0ZXMucmVsID09PSAnbW9kdWxlcHJlbG9hZCcpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc24uYXR0cmlidXRlcy5hcyA9PT0gJ3NjcmlwdCcpIHx8XHJcbiAgICAgICAgICAgICAgICAoc24udGFnTmFtZSA9PT0gJ2xpbmsnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc24uYXR0cmlidXRlcy5yZWwgPT09ICdwcmVmZXRjaCcgJiZcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2Ygc24uYXR0cmlidXRlcy5ocmVmID09PSAnc3RyaW5nJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHNuLmF0dHJpYnV0ZXMuaHJlZikgPT09ICdqcycpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2xpbURPTU9wdGlvbnMuaGVhZEZhdmljb24gJiZcclxuICAgICAgICAgICAgKChzbi50YWdOYW1lID09PSAnbGluaycgJiYgc24uYXR0cmlidXRlcy5yZWwgPT09ICdzaG9ydGN1dCBpY29uJykgfHxcclxuICAgICAgICAgICAgICAgIChzbi50YWdOYW1lID09PSAnbWV0YScgJiZcclxuICAgICAgICAgICAgICAgICAgICAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9ebXNhcHBsaWNhdGlvbi10aWxlKGltYWdlfGNvbG9yKSQvKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdhcHBsaWNhdGlvbi1uYW1lJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucmVsKSA9PT0gJ2ljb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5yZWwpID09PSAnYXBwbGUtdG91Y2gtaWNvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnJlbCkgPT09ICdzaG9ydGN1dCBpY29uJykpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc24udGFnTmFtZSA9PT0gJ21ldGEnKSB7XHJcbiAgICAgICAgICAgIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YURlc2NLZXl3b3JkcyAmJlxyXG4gICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpLm1hdGNoKC9eZGVzY3JpcHRpb258a2V5d29yZHMkLykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhU29jaWFsICYmXHJcbiAgICAgICAgICAgICAgICAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXihvZ3x0d2l0dGVyfGZiKTovKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKS5tYXRjaCgvXihvZ3x0d2l0dGVyKTovKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3BpbnRlcmVzdCcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YVJvYm90cyAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3JvYm90cycgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdnb29nbGVib3QnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnYmluZ2JvdCcpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkTWV0YUh0dHBFcXVpdiAmJlxyXG4gICAgICAgICAgICAgICAgc24uYXR0cmlidXRlc1snaHR0cC1lcXVpdiddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhQXV0aG9yc2hpcCAmJlxyXG4gICAgICAgICAgICAgICAgKGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ2F1dGhvcicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdnZW5lcmF0b3InIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZnJhbWV3b3JrJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3B1Ymxpc2hlcicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwcm9naWQnIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLnByb3BlcnR5KS5tYXRjaCgvXmFydGljbGU6LykgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMucHJvcGVydHkpLm1hdGNoKC9ecHJvZHVjdDovKSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHNsaW1ET01PcHRpb25zLmhlYWRNZXRhVmVyaWZpY2F0aW9uICYmXHJcbiAgICAgICAgICAgICAgICAobG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnZ29vZ2xlLXNpdGUtdmVyaWZpY2F0aW9uJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3lhbmRleC12ZXJpZmljYXRpb24nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAnY3NyZi10b2tlbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdwOmRvbWFpbl92ZXJpZnknIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgbG93ZXJJZkV4aXN0cyhzbi5hdHRyaWJ1dGVzLm5hbWUpID09PSAndmVyaWZ5LXYxJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIGxvd2VySWZFeGlzdHMoc24uYXR0cmlidXRlcy5uYW1lKSA9PT0gJ3ZlcmlmaWNhdGlvbicgfHxcclxuICAgICAgICAgICAgICAgICAgICBsb3dlcklmRXhpc3RzKHNuLmF0dHJpYnV0ZXMubmFtZSkgPT09ICdzaG9waWZ5LWNoZWNrb3V0LWFwaS10b2tlbicpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlV2l0aElkKG4sIG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHsgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG1hc2tUZXh0Q2xhc3MsIG1hc2tUZXh0U2VsZWN0b3IsIHNraXBDaGlsZCA9IGZhbHNlLCBpbmxpbmVTdHlsZXNoZWV0ID0gdHJ1ZSwgbWFza0lucHV0T3B0aW9ucyA9IHt9LCBtYXNrVGV4dEZuLCBtYXNrSW5wdXRGbiwgc2xpbURPTU9wdGlvbnMsIGRhdGFVUkxPcHRpb25zID0ge30sIGlubGluZUltYWdlcyA9IGZhbHNlLCByZWNvcmRDYW52YXMgPSBmYWxzZSwgb25TZXJpYWxpemUsIG9uSWZyYW1lTG9hZCwgaWZyYW1lTG9hZFRpbWVvdXQgPSA1MDAwLCBvblN0eWxlc2hlZXRMb2FkLCBzdHlsZXNoZWV0TG9hZFRpbWVvdXQgPSA1MDAwLCBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSwgbmV3bHlBZGRlZEVsZW1lbnQgPSBmYWxzZSwgfSA9IG9wdGlvbnM7XHJcbiAgICBsZXQgeyBuZWVkc01hc2sgfSA9IG9wdGlvbnM7XHJcbiAgICBsZXQgeyBwcmVzZXJ2ZVdoaXRlU3BhY2UgPSB0cnVlIH0gPSBvcHRpb25zO1xyXG4gICAgaWYgKCFuZWVkc01hc2sgJiZcclxuICAgICAgICBuLmNoaWxkTm9kZXMpIHtcclxuICAgICAgICBjb25zdCBjaGVja0FuY2VzdG9ycyA9IG5lZWRzTWFzayA9PT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIG5lZWRzTWFzayA9IG5lZWRNYXNraW5nVGV4dChuLCBtYXNrVGV4dENsYXNzLCBtYXNrVGV4dFNlbGVjdG9yLCBjaGVja0FuY2VzdG9ycyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBfc2VyaWFsaXplZE5vZGUgPSBzZXJpYWxpemVOb2RlKG4sIHtcclxuICAgICAgICBkb2MsXHJcbiAgICAgICAgbWlycm9yLFxyXG4gICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICBuZWVkc01hc2ssXHJcbiAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQsXHJcbiAgICB9KTtcclxuICAgIGlmICghX3NlcmlhbGl6ZWROb2RlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKG4sICdub3Qgc2VyaWFsaXplZCcpO1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgbGV0IGlkO1xyXG4gICAgaWYgKG1pcnJvci5oYXNOb2RlKG4pKSB7XHJcbiAgICAgICAgaWQgPSBtaXJyb3IuZ2V0SWQobik7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzbGltRE9NRXhjbHVkZWQoX3NlcmlhbGl6ZWROb2RlLCBzbGltRE9NT3B0aW9ucykgfHxcclxuICAgICAgICAoIXByZXNlcnZlV2hpdGVTcGFjZSAmJlxyXG4gICAgICAgICAgICBfc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuVGV4dCAmJlxyXG4gICAgICAgICAgICAhX3NlcmlhbGl6ZWROb2RlLmlzU3R5bGUgJiZcclxuICAgICAgICAgICAgIV9zZXJpYWxpemVkTm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nbSwgJycpLmxlbmd0aCkpIHtcclxuICAgICAgICBpZCA9IElHTk9SRURfTk9ERTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlkID0gZ2VuSWQoKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHNlcmlhbGl6ZWROb2RlID0gT2JqZWN0LmFzc2lnbihfc2VyaWFsaXplZE5vZGUsIHsgaWQgfSk7XHJcbiAgICBtaXJyb3IuYWRkKG4sIHNlcmlhbGl6ZWROb2RlKTtcclxuICAgIGlmIChpZCA9PT0gSUdOT1JFRF9OT0RFKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAob25TZXJpYWxpemUpIHtcclxuICAgICAgICBvblNlcmlhbGl6ZShuKTtcclxuICAgIH1cclxuICAgIGxldCByZWNvcmRDaGlsZCA9ICFza2lwQ2hpbGQ7XHJcbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCkge1xyXG4gICAgICAgIHJlY29yZENoaWxkID0gcmVjb3JkQ2hpbGQgJiYgIXNlcmlhbGl6ZWROb2RlLm5lZWRCbG9jaztcclxuICAgICAgICBkZWxldGUgc2VyaWFsaXplZE5vZGUubmVlZEJsb2NrO1xyXG4gICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBuLnNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgaXNOYXRpdmVTaGFkb3dEb20oc2hhZG93Um9vdCkpXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmlzU2hhZG93SG9zdCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoKHNlcmlhbGl6ZWROb2RlLnR5cGUgPT09IE5vZGVUeXBlLkRvY3VtZW50IHx8XHJcbiAgICAgICAgc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCkgJiZcclxuICAgICAgICByZWNvcmRDaGlsZCkge1xyXG4gICAgICAgIGlmIChzbGltRE9NT3B0aW9ucy5oZWFkV2hpdGVzcGFjZSAmJlxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS50eXBlID09PSBOb2RlVHlwZS5FbGVtZW50ICYmXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09ICdoZWFkJykge1xyXG4gICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYnlwYXNzT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgZG9jLFxyXG4gICAgICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgIG5lZWRzTWFzayxcclxuICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgc2tpcENoaWxkLFxyXG4gICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICBtYXNrSW5wdXRGbixcclxuICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgICAgICBvblNlcmlhbGl6ZSxcclxuICAgICAgICAgICAgb25JZnJhbWVMb2FkLFxyXG4gICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZCxcclxuICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxyXG4gICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgICAgICBzZXJpYWxpemVkTm9kZS50YWdOYW1lID09PSAndGV4dGFyZWEnICYmXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMudmFsdWUgIT09IHVuZGVmaW5lZCkgO1xyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTiBvZiBBcnJheS5mcm9tKG4uY2hpbGROb2RlcykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRDaGlsZE5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGNoaWxkTiwgYnlwYXNzT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VyaWFsaXplZENoaWxkTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNFbGVtZW50KG4pICYmIG4uc2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTiBvZiBBcnJheS5mcm9tKG4uc2hhZG93Um9vdC5jaGlsZE5vZGVzKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZENoaWxkTm9kZSA9IHNlcmlhbGl6ZU5vZGVXaXRoSWQoY2hpbGROLCBieXBhc3NPcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkQ2hpbGROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNOYXRpdmVTaGFkb3dEb20obi5zaGFkb3dSb290KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VyaWFsaXplZENoaWxkTm9kZS5pc1NoYWRvdyA9IHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWROb2RlLmNoaWxkTm9kZXMucHVzaChzZXJpYWxpemVkQ2hpbGROb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChuLnBhcmVudE5vZGUgJiZcclxuICAgICAgICBpc1NoYWRvd1Jvb3Qobi5wYXJlbnROb2RlKSAmJlxyXG4gICAgICAgIGlzTmF0aXZlU2hhZG93RG9tKG4ucGFyZW50Tm9kZSkpIHtcclxuICAgICAgICBzZXJpYWxpemVkTm9kZS5pc1NoYWRvdyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09ICdpZnJhbWUnKSB7XHJcbiAgICAgICAgb25jZUlmcmFtZUxvYWRlZChuLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlmcmFtZURvYyA9IG4uY29udGVudERvY3VtZW50O1xyXG4gICAgICAgICAgICBpZiAoaWZyYW1lRG9jICYmIG9uSWZyYW1lTG9hZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZElmcmFtZU5vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKGlmcmFtZURvYywge1xyXG4gICAgICAgICAgICAgICAgICAgIGRvYzogaWZyYW1lRG9jLFxyXG4gICAgICAgICAgICAgICAgICAgIG1pcnJvcixcclxuICAgICAgICAgICAgICAgICAgICBibG9ja0NsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbmVlZHNNYXNrLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZCxcclxuICAgICAgICAgICAgICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgICAgICAgICBvblN0eWxlc2hlZXRMb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcclxuICAgICAgICAgICAgICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIGlmIChzZXJpYWxpemVkSWZyYW1lTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uSWZyYW1lTG9hZChuLCBzZXJpYWxpemVkSWZyYW1lTm9kZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBpZnJhbWVMb2FkVGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc2VyaWFsaXplZE5vZGUudHlwZSA9PT0gTm9kZVR5cGUuRWxlbWVudCAmJlxyXG4gICAgICAgIHNlcmlhbGl6ZWROb2RlLnRhZ05hbWUgPT09ICdsaW5rJyAmJlxyXG4gICAgICAgIHR5cGVvZiBzZXJpYWxpemVkTm9kZS5hdHRyaWJ1dGVzLnJlbCA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAoc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09ICdzdHlsZXNoZWV0JyB8fFxyXG4gICAgICAgICAgICAoc2VyaWFsaXplZE5vZGUuYXR0cmlidXRlcy5yZWwgPT09ICdwcmVsb2FkJyAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuaHJlZiA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAgICAgICAgIGV4dHJhY3RGaWxlRXh0ZW5zaW9uKHNlcmlhbGl6ZWROb2RlLmF0dHJpYnV0ZXMuaHJlZikgPT09ICdjc3MnKSkpIHtcclxuICAgICAgICBvbmNlU3R5bGVzaGVldExvYWRlZChuLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChvblN0eWxlc2hlZXRMb2FkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkTGlua05vZGUgPSBzZXJpYWxpemVOb2RlV2l0aElkKG4sIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2MsXHJcbiAgICAgICAgICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBuZWVkc01hc2ssXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dFNlbGVjdG9yLFxyXG4gICAgICAgICAgICAgICAgICAgIHNraXBDaGlsZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlU3BhY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgb25TZXJpYWxpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgb25JZnJhbWVMb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZUxvYWRUaW1lb3V0LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzaGVldExvYWRUaW1lb3V0LFxyXG4gICAgICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlcmlhbGl6ZWRMaW5rTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQobiwgc2VyaWFsaXplZExpbmtOb2RlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHN0eWxlc2hlZXRMb2FkVGltZW91dCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VyaWFsaXplZE5vZGU7XHJcbn1cclxuZnVuY3Rpb24gc25hcHNob3Qobiwgb3B0aW9ucykge1xyXG4gICAgY29uc3QgeyBtaXJyb3IgPSBuZXcgTWlycm9yKCksIGJsb2NrQ2xhc3MgPSAncnItYmxvY2snLCBibG9ja1NlbGVjdG9yID0gbnVsbCwgbWFza1RleHRDbGFzcyA9ICdyci1tYXNrJywgbWFza1RleHRTZWxlY3RvciA9IG51bGwsIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLCBpbmxpbmVJbWFnZXMgPSBmYWxzZSwgcmVjb3JkQ2FudmFzID0gZmFsc2UsIG1hc2tBbGxJbnB1dHMgPSBmYWxzZSwgbWFza1RleHRGbiwgbWFza0lucHV0Rm4sIHNsaW1ET00gPSBmYWxzZSwgZGF0YVVSTE9wdGlvbnMsIHByZXNlcnZlV2hpdGVTcGFjZSwgb25TZXJpYWxpemUsIG9uSWZyYW1lTG9hZCwgaWZyYW1lTG9hZFRpbWVvdXQsIG9uU3R5bGVzaGVldExvYWQsIHN0eWxlc2hlZXRMb2FkVGltZW91dCwga2VlcElmcmFtZVNyY0ZuID0gKCkgPT4gZmFsc2UsIH0gPSBvcHRpb25zIHx8IHt9O1xyXG4gICAgY29uc3QgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWVcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgY29sb3I6IHRydWUsXHJcbiAgICAgICAgICAgIGRhdGU6IHRydWUsXHJcbiAgICAgICAgICAgICdkYXRldGltZS1sb2NhbCc6IHRydWUsXHJcbiAgICAgICAgICAgIGVtYWlsOiB0cnVlLFxyXG4gICAgICAgICAgICBtb250aDogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYmVyOiB0cnVlLFxyXG4gICAgICAgICAgICByYW5nZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2VhcmNoOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZWw6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IHRydWUsXHJcbiAgICAgICAgICAgIHRpbWU6IHRydWUsXHJcbiAgICAgICAgICAgIHVybDogdHJ1ZSxcclxuICAgICAgICAgICAgd2VlazogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dGFyZWE6IHRydWUsXHJcbiAgICAgICAgICAgIHNlbGVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDogbWFza0FsbElucHV0cyA9PT0gZmFsc2VcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogdHJ1ZSxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICA6IG1hc2tBbGxJbnB1dHM7XHJcbiAgICBjb25zdCBzbGltRE9NT3B0aW9ucyA9IHNsaW1ET00gPT09IHRydWUgfHwgc2xpbURPTSA9PT0gJ2FsbCdcclxuICAgICAgICA/XHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHNjcmlwdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbW1lbnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkRmF2aWNvbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRXaGl0ZXNwYWNlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFEZXNjS2V5d29yZHM6IHNsaW1ET00gPT09ICdhbGwnLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBoZWFkTWV0YVJvYm90czogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGhlYWRNZXRhSHR0cEVxdWl2OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFBdXRob3JzaGlwOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWUsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICA6IHNsaW1ET00gPT09IGZhbHNlXHJcbiAgICAgICAgICAgID8ge31cclxuICAgICAgICAgICAgOiBzbGltRE9NO1xyXG4gICAgcmV0dXJuIHNlcmlhbGl6ZU5vZGVXaXRoSWQobiwge1xyXG4gICAgICAgIGRvYzogbixcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICBza2lwQ2hpbGQ6IGZhbHNlLFxyXG4gICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICBtYXNrVGV4dEZuLFxyXG4gICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgcHJlc2VydmVXaGl0ZVNwYWNlLFxyXG4gICAgICAgIG9uU2VyaWFsaXplLFxyXG4gICAgICAgIG9uSWZyYW1lTG9hZCxcclxuICAgICAgICBpZnJhbWVMb2FkVGltZW91dCxcclxuICAgICAgICBvblN0eWxlc2hlZXRMb2FkLFxyXG4gICAgICAgIHN0eWxlc2hlZXRMb2FkVGltZW91dCxcclxuICAgICAgICBrZWVwSWZyYW1lU3JjRm4sXHJcbiAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IGZhbHNlLFxyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gb24odHlwZSwgZm4sIHRhcmdldCA9IGRvY3VtZW50KSB7XHJcbiAgICBjb25zdCBvcHRpb25zID0geyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH07XHJcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZm4sIG9wdGlvbnMpO1xyXG59XHJcbmNvbnN0IERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyA9ICdQbGVhc2Ugc3RvcCBpbXBvcnQgbWlycm9yIGRpcmVjdGx5LiBJbnN0ZWFkIG9mIHRoYXQsJyArXHJcbiAgICAnXFxyXFxuJyArXHJcbiAgICAnbm93IHlvdSBjYW4gdXNlIHJlcGxheWVyLmdldE1pcnJvcigpIHRvIGFjY2VzcyB0aGUgbWlycm9yIGluc3RhbmNlIG9mIGEgcmVwbGF5ZXIsJyArXHJcbiAgICAnXFxyXFxuJyArXHJcbiAgICAnb3IgeW91IGNhbiB1c2UgcmVjb3JkLm1pcnJvciB0byBhY2Nlc3MgdGhlIG1pcnJvciBpbnN0YW5jZSBkdXJpbmcgcmVjb3JkaW5nLic7XHJcbmxldCBfbWlycm9yID0ge1xyXG4gICAgbWFwOiB7fSxcclxuICAgIGdldElkKCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9LFxyXG4gICAgZ2V0Tm9kZSgpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlTm9kZUZyb21NYXAoKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgfSxcclxuICAgIGhhcygpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKERFUEFSVEVEX01JUlJPUl9BQ0NFU1NfV0FSTklORyk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfSxcclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoREVQQVJURURfTUlSUk9SX0FDQ0VTU19XQVJOSU5HKTtcclxuICAgIH0sXHJcbn07XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuUHJveHkgJiYgd2luZG93LlJlZmxlY3QpIHtcclxuICAgIF9taXJyb3IgPSBuZXcgUHJveHkoX21pcnJvciwge1xyXG4gICAgICAgIGdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSB7XHJcbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnbWFwJykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihERVBBUlRFRF9NSVJST1JfQUNDRVNTX1dBUk5JTkcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICBsZXQgdGltZW91dCA9IG51bGw7XHJcbiAgICBsZXQgcHJldmlvdXMgPSAwO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcclxuICAgICAgICBpZiAoIXByZXZpb3VzICYmIG9wdGlvbnMubGVhZGluZyA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcHJldmlvdXMgPSBub3c7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gcHJldmlvdXMpO1xyXG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwcmV2aW91cyA9IG5vdztcclxuICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IERhdGUubm93KCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XHJcbiAgICAgICAgICAgIH0sIHJlbWFpbmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBkLCBpc1Jldm9rZWQsIHdpbiA9IHdpbmRvdykge1xyXG4gICAgY29uc3Qgb3JpZ2luYWwgPSB3aW4uT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XHJcbiAgICB3aW4uT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBpc1Jldm9rZWRcclxuICAgICAgICA/IGRcclxuICAgICAgICA6IHtcclxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBkLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsICYmIG9yaWdpbmFsLnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgIHJldHVybiAoKSA9PiBob29rU2V0dGVyKHRhcmdldCwga2V5LCBvcmlnaW5hbCB8fCB7fSwgdHJ1ZSk7XHJcbn1cclxuZnVuY3Rpb24gcGF0Y2goc291cmNlLCBuYW1lLCByZXBsYWNlbWVudCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAoIShuYW1lIGluIHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBzb3VyY2VbbmFtZV07XHJcbiAgICAgICAgY29uc3Qgd3JhcHBlZCA9IHJlcGxhY2VtZW50KG9yaWdpbmFsKTtcclxuICAgICAgICBpZiAodHlwZW9mIHdyYXBwZWQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgd3JhcHBlZC5wcm90b3R5cGUgPSB3cmFwcGVkLnByb3RvdHlwZSB8fCB7fTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcHBlZCwge1xyXG4gICAgICAgICAgICAgICAgX19ycndlYl9vcmlnaW5hbF9fOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9yaWdpbmFsLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvdXJjZVtuYW1lXSA9IHdyYXBwZWQ7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgc291cmNlW25hbWVdID0gb3JpZ2luYWw7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5sZXQgbm93VGltZXN0YW1wID0gRGF0ZS5ub3c7XHJcbmlmICghKC9bMS05XVswLTldezEyfS8udGVzdChEYXRlLm5vdygpLnRvU3RyaW5nKCkpKSkge1xyXG4gICAgbm93VGltZXN0YW1wID0gKCkgPT4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKHdpbikge1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICBjb25zdCBkb2MgPSB3aW4uZG9jdW1lbnQ7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGRvYy5zY3JvbGxpbmdFbGVtZW50XHJcbiAgICAgICAgICAgID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsTGVmdFxyXG4gICAgICAgICAgICA6IHdpbi5wYWdlWE9mZnNldCAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgICAgICA/IHdpbi5wYWdlWE9mZnNldFxyXG4gICAgICAgICAgICAgICAgOiAoZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICgoX2IgPSAoX2EgPSBkb2MgPT09IG51bGwgfHwgZG9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2MuYm9keSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zY3JvbGxMZWZ0KSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICgoX2MgPSBkb2MgPT09IG51bGwgfHwgZG9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2MuYm9keSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNjcm9sbExlZnQpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgMCxcclxuICAgICAgICB0b3A6IGRvYy5zY3JvbGxpbmdFbGVtZW50XHJcbiAgICAgICAgICAgID8gZG9jLnNjcm9sbGluZ0VsZW1lbnQuc2Nyb2xsVG9wXHJcbiAgICAgICAgICAgIDogd2luLnBhZ2VZT2Zmc2V0ICE9PSB1bmRlZmluZWRcclxuICAgICAgICAgICAgICAgID8gd2luLnBhZ2VZT2Zmc2V0XHJcbiAgICAgICAgICAgICAgICA6IChkb2MgPT09IG51bGwgfHwgZG9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2MuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAoKF9lID0gKF9kID0gZG9jID09PSBudWxsIHx8IGRvYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9jLmJvZHkpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Uuc2Nyb2xsVG9wKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICgoX2YgPSBkb2MgPT09IG51bGwgfHwgZG9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkb2MuYm9keSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLnNjcm9sbFRvcCkgfHxcclxuICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBnZXRXaW5kb3dIZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gKHdpbmRvdy5pbm5lckhlaWdodCB8fFxyXG4gICAgICAgIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCkgfHxcclxuICAgICAgICAoZG9jdW1lbnQuYm9keSAmJiBkb2N1bWVudC5ib2R5LmNsaWVudEhlaWdodCkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFdpbmRvd1dpZHRoKCkge1xyXG4gICAgcmV0dXJuICh3aW5kb3cuaW5uZXJXaWR0aCB8fFxyXG4gICAgICAgIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSB8fFxyXG4gICAgICAgIChkb2N1bWVudC5ib2R5ICYmIGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgpKTtcclxufVxyXG5mdW5jdGlvbiBjbG9zZXN0RWxlbWVudE9mTm9kZShub2RlKSB7XHJcbiAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnN0IGVsID0gbm9kZS5ub2RlVHlwZSA9PT0gbm9kZS5FTEVNRU5UX05PREVcclxuICAgICAgICA/IG5vZGVcclxuICAgICAgICA6IG5vZGUucGFyZW50RWxlbWVudDtcclxuICAgIHJldHVybiBlbDtcclxufVxyXG5mdW5jdGlvbiBpc0Jsb2NrZWQobm9kZSwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgY2hlY2tBbmNlc3RvcnMpIHtcclxuICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVsID0gY2xvc2VzdEVsZW1lbnRPZk5vZGUobm9kZSk7XHJcbiAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodHlwZW9mIGJsb2NrQ2xhc3MgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QuY29udGFpbnMoYmxvY2tDbGFzcykpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKGNoZWNrQW5jZXN0b3JzICYmIGVsLmNsb3Nlc3QoJy4nICsgYmxvY2tDbGFzcykgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjbGFzc01hdGNoZXNSZWdleChlbCwgYmxvY2tDbGFzcywgY2hlY2tBbmNlc3RvcnMpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgIH1cclxuICAgIGlmIChibG9ja1NlbGVjdG9yKSB7XHJcbiAgICAgICAgaWYgKGVsLm1hdGNoZXMoYmxvY2tTZWxlY3RvcikpXHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIGlmIChjaGVja0FuY2VzdG9ycyAmJiBlbC5jbG9zZXN0KGJsb2NrU2VsZWN0b3IpICE9PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWQobiwgbWlycm9yKSB7XHJcbiAgICByZXR1cm4gbWlycm9yLmdldElkKG4pICE9PSAtMTtcclxufVxyXG5mdW5jdGlvbiBpc0lnbm9yZWQobiwgbWlycm9yKSB7XHJcbiAgICByZXR1cm4gbWlycm9yLmdldElkKG4pID09PSBJR05PUkVEX05PREU7XHJcbn1cclxuZnVuY3Rpb24gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LCBtaXJyb3IpIHtcclxuICAgIGlmIChpc1NoYWRvd1Jvb3QodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGlkID0gbWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICBpZiAoIW1pcnJvci5oYXMoaWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUgJiZcclxuICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gdGFyZ2V0LkRPQ1VNRU5UX05PREUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoIXRhcmdldC5wYXJlbnROb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNBbmNlc3RvclJlbW92ZWQodGFyZ2V0LnBhcmVudE5vZGUsIG1pcnJvcik7XHJcbn1cclxuZnVuY3Rpb24gbGVnYWN5X2lzVG91Y2hFdmVudChldmVudCkge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oZXZlbnQuY2hhbmdlZFRvdWNoZXMpO1xyXG59XHJcbmZ1bmN0aW9uIHBvbHlmaWxsKHdpbiA9IHdpbmRvdykge1xyXG4gICAgaWYgKCdOb2RlTGlzdCcgaW4gd2luICYmICF3aW4uTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2gpIHtcclxuICAgICAgICB3aW4uTm9kZUxpc3QucHJvdG90eXBlLmZvckVhY2ggPSBBcnJheS5wcm90b3R5cGVcclxuICAgICAgICAgICAgLmZvckVhY2g7XHJcbiAgICB9XHJcbiAgICBpZiAoJ0RPTVRva2VuTGlzdCcgaW4gd2luICYmICF3aW4uRE9NVG9rZW5MaXN0LnByb3RvdHlwZS5mb3JFYWNoKSB7XHJcbiAgICAgICAgd2luLkRPTVRva2VuTGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZVxyXG4gICAgICAgICAgICAuZm9yRWFjaDtcclxuICAgIH1cclxuICAgIGlmICghTm9kZS5wcm90b3R5cGUuY29udGFpbnMpIHtcclxuICAgICAgICBOb2RlLnByb3RvdHlwZS5jb250YWlucyA9ICguLi5hcmdzKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBub2RlID0gYXJnc1swXTtcclxuICAgICAgICAgICAgaWYgKCEoMCBpbiBhcmdzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignMSBhcmd1bWVudCBpcyByZXF1aXJlZCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKChub2RlID0gbm9kZSAmJiBub2RlLnBhcmVudE5vZGUpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gaXNTZXJpYWxpemVkSWZyYW1lKG4sIG1pcnJvcikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4obi5ub2RlTmFtZSA9PT0gJ0lGUkFNRScgJiYgbWlycm9yLmdldE1ldGEobikpO1xyXG59XHJcbmZ1bmN0aW9uIGlzU2VyaWFsaXplZFN0eWxlc2hlZXQobiwgbWlycm9yKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihuLm5vZGVOYW1lID09PSAnTElOSycgJiZcclxuICAgICAgICBuLm5vZGVUeXBlID09PSBuLkVMRU1FTlRfTk9ERSAmJlxyXG4gICAgICAgIG4uZ2V0QXR0cmlidXRlICYmXHJcbiAgICAgICAgbi5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnc3R5bGVzaGVldCcgJiZcclxuICAgICAgICBtaXJyb3IuZ2V0TWV0YShuKSk7XHJcbn1cclxuZnVuY3Rpb24gaGFzU2hhZG93Um9vdChuKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbihuID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uc2hhZG93Um9vdCk7XHJcbn1cclxuY2xhc3MgU3R5bGVTaGVldE1pcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmlkID0gMTtcclxuICAgICAgICB0aGlzLnN0eWxlSURNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuaWRTdHlsZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldElkKHN0eWxlc2hlZXQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuc3R5bGVJRE1hcC5nZXQoc3R5bGVzaGVldCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xO1xyXG4gICAgfVxyXG4gICAgaGFzKHN0eWxlc2hlZXQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdHlsZUlETWFwLmhhcyhzdHlsZXNoZWV0KTtcclxuICAgIH1cclxuICAgIGFkZChzdHlsZXNoZWV0LCBpZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhcyhzdHlsZXNoZWV0KSlcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SWQoc3R5bGVzaGVldCk7XHJcbiAgICAgICAgbGV0IG5ld0lkO1xyXG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIG5ld0lkID0gdGhpcy5pZCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIG5ld0lkID0gaWQ7XHJcbiAgICAgICAgdGhpcy5zdHlsZUlETWFwLnNldChzdHlsZXNoZWV0LCBuZXdJZCk7XHJcbiAgICAgICAgdGhpcy5pZFN0eWxlTWFwLnNldChuZXdJZCwgc3R5bGVzaGVldCk7XHJcbiAgICAgICAgcmV0dXJuIG5ld0lkO1xyXG4gICAgfVxyXG4gICAgZ2V0U3R5bGUoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZFN0eWxlTWFwLmdldChpZCkgfHwgbnVsbDtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuc3R5bGVJRE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pZFN0eWxlTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAxO1xyXG4gICAgfVxyXG4gICAgZ2VuZXJhdGVJZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pZCsrO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFNoYWRvd0hvc3Qobikge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIGxldCBzaGFkb3dIb3N0ID0gbnVsbDtcclxuICAgIGlmICgoKF9iID0gKF9hID0gbi5nZXRSb290Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwobikpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ub2RlVHlwZSkgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJlxyXG4gICAgICAgIG4uZ2V0Um9vdE5vZGUoKS5ob3N0KVxyXG4gICAgICAgIHNoYWRvd0hvc3QgPSBuLmdldFJvb3ROb2RlKCkuaG9zdDtcclxuICAgIHJldHVybiBzaGFkb3dIb3N0O1xyXG59XHJcbmZ1bmN0aW9uIGdldFJvb3RTaGFkb3dIb3N0KG4pIHtcclxuICAgIGxldCByb290U2hhZG93SG9zdCA9IG47XHJcbiAgICBsZXQgc2hhZG93SG9zdDtcclxuICAgIHdoaWxlICgoc2hhZG93SG9zdCA9IGdldFNoYWRvd0hvc3Qocm9vdFNoYWRvd0hvc3QpKSlcclxuICAgICAgICByb290U2hhZG93SG9zdCA9IHNoYWRvd0hvc3Q7XHJcbiAgICByZXR1cm4gcm9vdFNoYWRvd0hvc3Q7XHJcbn1cclxuZnVuY3Rpb24gc2hhZG93SG9zdEluRG9tKG4pIHtcclxuICAgIGNvbnN0IGRvYyA9IG4ub3duZXJEb2N1bWVudDtcclxuICAgIGlmICghZG9jKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIGNvbnN0IHNoYWRvd0hvc3QgPSBnZXRSb290U2hhZG93SG9zdChuKTtcclxuICAgIHJldHVybiBkb2MuY29udGFpbnMoc2hhZG93SG9zdCk7XHJcbn1cclxuZnVuY3Rpb24gaW5Eb20obikge1xyXG4gICAgY29uc3QgZG9jID0gbi5vd25lckRvY3VtZW50O1xyXG4gICAgaWYgKCFkb2MpXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgcmV0dXJuIGRvYy5jb250YWlucyhuKSB8fCBzaGFkb3dIb3N0SW5Eb20obik7XHJcbn1cblxudmFyIEV2ZW50VHlwZSQxID0gLyogQF9fUFVSRV9fICovICgoRXZlbnRUeXBlMikgPT4ge1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJEb21Db250ZW50TG9hZGVkXCJdID0gMF0gPSBcIkRvbUNvbnRlbnRMb2FkZWRcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTG9hZFwiXSA9IDFdID0gXCJMb2FkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkZ1bGxTbmFwc2hvdFwiXSA9IDJdID0gXCJGdWxsU25hcHNob3RcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiSW5jcmVtZW50YWxTbmFwc2hvdFwiXSA9IDNdID0gXCJJbmNyZW1lbnRhbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIk1ldGFcIl0gPSA0XSA9IFwiTWV0YVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJDdXN0b21cIl0gPSA1XSA9IFwiQ3VzdG9tXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIlBsdWdpblwiXSA9IDZdID0gXCJQbHVnaW5cIjtcbiAgcmV0dXJuIEV2ZW50VHlwZTI7XG59KShFdmVudFR5cGUkMSB8fCB7fSk7XG52YXIgSW5jcmVtZW50YWxTb3VyY2UkMSA9IC8qIEBfX1BVUkVfXyAqLyAoKEluY3JlbWVudGFsU291cmNlMikgPT4ge1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTXV0YXRpb25cIl0gPSAwXSA9IFwiTXV0YXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlTW92ZVwiXSA9IDFdID0gXCJNb3VzZU1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1vdXNlSW50ZXJhY3Rpb25cIl0gPSAyXSA9IFwiTW91c2VJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2Nyb2xsXCJdID0gM10gPSBcIlNjcm9sbFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiVmlld3BvcnRSZXNpemVcIl0gPSA0XSA9IFwiVmlld3BvcnRSZXNpemVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIklucHV0XCJdID0gNV0gPSBcIklucHV0XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJUb3VjaE1vdmVcIl0gPSA2XSA9IFwiVG91Y2hNb3ZlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNZWRpYUludGVyYWN0aW9uXCJdID0gN10gPSBcIk1lZGlhSW50ZXJhY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlU2hlZXRSdWxlXCJdID0gOF0gPSBcIlN0eWxlU2hlZXRSdWxlXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJDYW52YXNNdXRhdGlvblwiXSA9IDldID0gXCJDYW52YXNNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRm9udFwiXSA9IDEwXSA9IFwiRm9udFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTG9nXCJdID0gMTFdID0gXCJMb2dcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkRyYWdcIl0gPSAxMl0gPSBcIkRyYWdcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlN0eWxlRGVjbGFyYXRpb25cIl0gPSAxM10gPSBcIlN0eWxlRGVjbGFyYXRpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlNlbGVjdGlvblwiXSA9IDE0XSA9IFwiU2VsZWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJBZG9wdGVkU3R5bGVTaGVldFwiXSA9IDE1XSA9IFwiQWRvcHRlZFN0eWxlU2hlZXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkN1c3RvbUVsZW1lbnRcIl0gPSAxNl0gPSBcIkN1c3RvbUVsZW1lbnRcIjtcbiAgcmV0dXJuIEluY3JlbWVudGFsU291cmNlMjtcbn0pKEluY3JlbWVudGFsU291cmNlJDEgfHwge30pO1xudmFyIE1vdXNlSW50ZXJhY3Rpb25zID0gLyogQF9fUFVSRV9fICovICgoTW91c2VJbnRlcmFjdGlvbnMyKSA9PiB7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJNb3VzZVVwXCJdID0gMF0gPSBcIk1vdXNlVXBcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIk1vdXNlRG93blwiXSA9IDFdID0gXCJNb3VzZURvd25cIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkNsaWNrXCJdID0gMl0gPSBcIkNsaWNrXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJDb250ZXh0TWVudVwiXSA9IDNdID0gXCJDb250ZXh0TWVudVwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiRGJsQ2xpY2tcIl0gPSA0XSA9IFwiRGJsQ2xpY2tcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIkZvY3VzXCJdID0gNV0gPSBcIkZvY3VzXCI7XG4gIE1vdXNlSW50ZXJhY3Rpb25zMltNb3VzZUludGVyYWN0aW9uczJbXCJCbHVyXCJdID0gNl0gPSBcIkJsdXJcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoU3RhcnRcIl0gPSA3XSA9IFwiVG91Y2hTdGFydFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hNb3ZlX0RlcGFydGVkXCJdID0gOF0gPSBcIlRvdWNoTW92ZV9EZXBhcnRlZFwiO1xuICBNb3VzZUludGVyYWN0aW9uczJbTW91c2VJbnRlcmFjdGlvbnMyW1wiVG91Y2hFbmRcIl0gPSA5XSA9IFwiVG91Y2hFbmRcIjtcbiAgTW91c2VJbnRlcmFjdGlvbnMyW01vdXNlSW50ZXJhY3Rpb25zMltcIlRvdWNoQ2FuY2VsXCJdID0gMTBdID0gXCJUb3VjaENhbmNlbFwiO1xuICByZXR1cm4gTW91c2VJbnRlcmFjdGlvbnMyO1xufSkoTW91c2VJbnRlcmFjdGlvbnMgfHwge30pO1xudmFyIFBvaW50ZXJUeXBlcyA9IC8qIEBfX1BVUkVfXyAqLyAoKFBvaW50ZXJUeXBlczIpID0+IHtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiTW91c2VcIl0gPSAwXSA9IFwiTW91c2VcIjtcbiAgUG9pbnRlclR5cGVzMltQb2ludGVyVHlwZXMyW1wiUGVuXCJdID0gMV0gPSBcIlBlblwiO1xuICBQb2ludGVyVHlwZXMyW1BvaW50ZXJUeXBlczJbXCJUb3VjaFwiXSA9IDJdID0gXCJUb3VjaFwiO1xuICByZXR1cm4gUG9pbnRlclR5cGVzMjtcbn0pKFBvaW50ZXJUeXBlcyB8fCB7fSk7XG52YXIgQ2FudmFzQ29udGV4dCA9IC8qIEBfX1BVUkVfXyAqLyAoKENhbnZhc0NvbnRleHQyKSA9PiB7XG4gIENhbnZhc0NvbnRleHQyW0NhbnZhc0NvbnRleHQyW1wiMkRcIl0gPSAwXSA9IFwiMkRcIjtcbiAgQ2FudmFzQ29udGV4dDJbQ2FudmFzQ29udGV4dDJbXCJXZWJHTFwiXSA9IDFdID0gXCJXZWJHTFwiO1xuICBDYW52YXNDb250ZXh0MltDYW52YXNDb250ZXh0MltcIldlYkdMMlwiXSA9IDJdID0gXCJXZWJHTDJcIjtcbiAgcmV0dXJuIENhbnZhc0NvbnRleHQyO1xufSkoQ2FudmFzQ29udGV4dCB8fCB7fSk7XG5cbmZ1bmN0aW9uIGlzTm9kZUluTGlua2VkTGlzdChuKSB7XHJcbiAgICByZXR1cm4gJ19fbG4nIGluIG47XHJcbn1cclxuY2xhc3MgRG91YmxlTGlua2VkTGlzdCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5oZWFkID0gbnVsbDtcclxuICAgICAgICB0aGlzLnRhaWwgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0KHBvc2l0aW9uKSB7XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IHRoaXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9zaXRpb24gb3V0c2lkZSBvZiBsaXN0IHJhbmdlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwb3NpdGlvbjsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5uZXh0KSB8fCBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuICAgIGFkZE5vZGUobikge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBuLFxyXG4gICAgICAgICAgICBwcmV2aW91czogbnVsbCxcclxuICAgICAgICAgICAgbmV4dDogbnVsbCxcclxuICAgICAgICB9O1xyXG4gICAgICAgIG4uX19sbiA9IG5vZGU7XHJcbiAgICAgICAgaWYgKG4ucHJldmlvdXNTaWJsaW5nICYmIGlzTm9kZUluTGlua2VkTGlzdChuLnByZXZpb3VzU2libGluZykpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IG4ucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dDtcclxuICAgICAgICAgICAgbm9kZS5uZXh0ID0gY3VycmVudDtcclxuICAgICAgICAgICAgbm9kZS5wcmV2aW91cyA9IG4ucHJldmlvdXNTaWJsaW5nLl9fbG47XHJcbiAgICAgICAgICAgIG4ucHJldmlvdXNTaWJsaW5nLl9fbG4ubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50LnByZXZpb3VzID0gbm9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChuLm5leHRTaWJsaW5nICYmXHJcbiAgICAgICAgICAgIGlzTm9kZUluTGlua2VkTGlzdChuLm5leHRTaWJsaW5nKSAmJlxyXG4gICAgICAgICAgICBuLm5leHRTaWJsaW5nLl9fbG4ucHJldmlvdXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IG4ubmV4dFNpYmxpbmcuX19sbi5wcmV2aW91cztcclxuICAgICAgICAgICAgbm9kZS5wcmV2aW91cyA9IGN1cnJlbnQ7XHJcbiAgICAgICAgICAgIG5vZGUubmV4dCA9IG4ubmV4dFNpYmxpbmcuX19sbjtcclxuICAgICAgICAgICAgbi5uZXh0U2libGluZy5fX2xuLnByZXZpb3VzID0gbm9kZTtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQubmV4dCA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlYWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVhZC5wcmV2aW91cyA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbm9kZS5uZXh0ID0gdGhpcy5oZWFkO1xyXG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5uZXh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFpbCA9IG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVuZ3RoKys7XHJcbiAgICB9XHJcbiAgICByZW1vdmVOb2RlKG4pIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50ID0gbi5fX2xuO1xyXG4gICAgICAgIGlmICghdGhpcy5oZWFkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFjdXJyZW50LnByZXZpb3VzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWFkLnByZXZpb3VzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQucHJldmlvdXMubmV4dCA9IGN1cnJlbnQubmV4dDtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQubmV4dCkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudC5uZXh0LnByZXZpb3VzID0gY3VycmVudC5wcmV2aW91cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGFpbCA9IGN1cnJlbnQucHJldmlvdXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG4uX19sbikge1xyXG4gICAgICAgICAgICBkZWxldGUgbi5fX2xuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxlbmd0aC0tO1xyXG4gICAgfVxyXG59XHJcbmNvbnN0IG1vdmVLZXkgPSAoaWQsIHBhcmVudElkKSA9PiBgJHtpZH1AJHtwYXJlbnRJZH1gO1xyXG5jbGFzcyBNdXRhdGlvbkJ1ZmZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmZyb3plbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy50ZXh0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICB0aGlzLnJlbW92ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm1hcFJlbW92ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm1vdmVkTWFwID0ge307XHJcbiAgICAgICAgdGhpcy5hZGRlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLm1vdmVkU2V0ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuZHJvcHBlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbnMgPSAobXV0YXRpb25zKSA9PiB7XHJcbiAgICAgICAgICAgIG11dGF0aW9ucy5mb3JFYWNoKHRoaXMucHJvY2Vzc011dGF0aW9uKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmVtaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZyb3plbiB8fCB0aGlzLmxvY2tlZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZHMgPSBbXTtcclxuICAgICAgICAgICAgY29uc3QgYWRkZWRJZHMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFkZExpc3QgPSBuZXcgRG91YmxlTGlua2VkTGlzdCgpO1xyXG4gICAgICAgICAgICBjb25zdCBnZXROZXh0SWQgPSAobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IG5zID0gbjtcclxuICAgICAgICAgICAgICAgIGxldCBuZXh0SWQgPSBJR05PUkVEX05PREU7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dElkID09PSBJR05PUkVEX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICBucyA9IG5zICYmIG5zLm5leHRTaWJsaW5nO1xyXG4gICAgICAgICAgICAgICAgICAgIG5leHRJZCA9IG5zICYmIHRoaXMubWlycm9yLmdldElkKG5zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0SWQ7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHB1c2hBZGQgPSAobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuLnBhcmVudE5vZGUgfHxcclxuICAgICAgICAgICAgICAgICAgICAhaW5Eb20obikgfHxcclxuICAgICAgICAgICAgICAgICAgICBuLnBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gaXNTaGFkb3dSb290KG4ucGFyZW50Tm9kZSlcclxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMubWlycm9yLmdldElkKGdldFNoYWRvd0hvc3QobikpXHJcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLm1pcnJvci5nZXRJZChuLnBhcmVudE5vZGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKG4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudElkID09PSAtMSB8fCBuZXh0SWQgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZExpc3QuYWRkTm9kZShuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHNuID0gc2VyaWFsaXplTm9kZVdpdGhJZChuLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jOiB0aGlzLmRvYyxcclxuICAgICAgICAgICAgICAgICAgICBtaXJyb3I6IHRoaXMubWlycm9yLFxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrQ2xhc3M6IHRoaXMuYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgICAgICBibG9ja1NlbGVjdG9yOiB0aGlzLmJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza1RleHRDbGFzczogdGhpcy5tYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3I6IHRoaXMubWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgICAgICBza2lwQ2hpbGQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgbmV3bHlBZGRlZEVsZW1lbnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldDogdGhpcy5pbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnM6IHRoaXMubWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICBtYXNrVGV4dEZuOiB0aGlzLm1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgICAgICAgICAgbWFza0lucHV0Rm46IHRoaXMubWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgICAgICAgICAgc2xpbURPTU9wdGlvbnM6IHRoaXMuc2xpbURPTU9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IHRoaXMuZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkQ2FudmFzOiB0aGlzLnJlY29yZENhbnZhcyxcclxuICAgICAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXM6IHRoaXMuaW5saW5lSW1hZ2VzLFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU2VyaWFsaXplOiAoY3VycmVudE4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShjdXJyZW50TiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlmcmFtZU1hbmFnZXIuYWRkSWZyYW1lKGN1cnJlbnROKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkU3R5bGVzaGVldChjdXJyZW50TiwgdGhpcy5taXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnRyYWNrTGlua0VsZW1lbnQoY3VycmVudE4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYWRvd0RvbU1hbmFnZXIuYWRkU2hhZG93Um9vdChuLnNoYWRvd1Jvb3QsIHRoaXMuZG9jKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb25JZnJhbWVMb2FkOiAoaWZyYW1lLCBjaGlsZFNuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaWZyYW1lTWFuYWdlci5hdHRhY2hJZnJhbWUoaWZyYW1lLCBjaGlsZFNuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLm9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIG9uU3R5bGVzaGVldExvYWQ6IChsaW5rLCBjaGlsZFNuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGluaywgY2hpbGRTbik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogc24sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYWRkZWRJZHMuYWRkKHNuLmlkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgd2hpbGUgKHRoaXMubWFwUmVtb3Zlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubWlycm9yLnJlbW92ZU5vZGVGcm9tTWFwKHRoaXMubWFwUmVtb3Zlcy5zaGlmdCgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5tb3ZlZFNldCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzUGFyZW50UmVtb3ZlZCh0aGlzLnJlbW92ZXMsIG4sIHRoaXMubWlycm9yKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLm1vdmVkU2V0LmhhcyhuLnBhcmVudE5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwdXNoQWRkKG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbiBvZiB0aGlzLmFkZGVkU2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQW5jZXN0b3JJblNldCh0aGlzLmRyb3BwZWRTZXQsIG4pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWlzUGFyZW50UmVtb3ZlZCh0aGlzLnJlbW92ZXMsIG4sIHRoaXMubWlycm9yKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHB1c2hBZGQobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FuY2VzdG9ySW5TZXQodGhpcy5tb3ZlZFNldCwgbikpIHtcclxuICAgICAgICAgICAgICAgICAgICBwdXNoQWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcm9wcGVkU2V0LmFkZChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gbnVsbDtcclxuICAgICAgICAgICAgd2hpbGUgKGFkZExpc3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SWQgPSB0aGlzLm1pcnJvci5nZXRJZChjYW5kaWRhdGUudmFsdWUucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dElkID0gZ2V0TmV4dElkKGNhbmRpZGF0ZS52YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudElkICE9PSAtMSAmJiBuZXh0SWQgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjYW5kaWRhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRhaWxOb2RlID0gYWRkTGlzdC50YWlsO1xyXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0YWlsTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfbm9kZSA9IHRhaWxOb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX25vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoX25vZGUudmFsdWUucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0SWQgPSBnZXROZXh0SWQoX25vZGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRJZCA9PT0gLTEpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJlbnRJZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gX25vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1bmhhbmRsZWROb2RlID0gX25vZGUudmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVuaGFuZGxlZE5vZGUucGFyZW50Tm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bmhhbmRsZWROb2RlLnBhcmVudE5vZGUubm9kZVR5cGUgPT09XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhZG93SG9zdCA9IHVuaGFuZGxlZE5vZGUucGFyZW50Tm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhvc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudElkID0gdGhpcy5taXJyb3IuZ2V0SWQoc2hhZG93SG9zdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRJZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBfbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGFkZExpc3QuaGVhZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRMaXN0LnJlbW92ZU5vZGUoYWRkTGlzdC5oZWFkLnZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBub2RlLnByZXZpb3VzO1xyXG4gICAgICAgICAgICAgICAgYWRkTGlzdC5yZW1vdmVOb2RlKG5vZGUudmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgcHVzaEFkZChub2RlLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0ge1xyXG4gICAgICAgICAgICAgICAgdGV4dHM6IHRoaXMudGV4dHNcclxuICAgICAgICAgICAgICAgICAgICAubWFwKCh0ZXh0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IHRleHQubm9kZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobi5wYXJlbnROb2RlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4ucGFyZW50Tm9kZS50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuVGV4dEFyZWFWYWx1ZU11dGF0aW9uKG4ucGFyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLm1pcnJvci5nZXRJZChuKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRleHQudmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigodGV4dCkgPT4gIWFkZGVkSWRzLmhhcyh0ZXh0LmlkKSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh0ZXh0KSA9PiB0aGlzLm1pcnJvci5oYXModGV4dC5pZCkpLFxyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdGhpcy5hdHRyaWJ1dGVzXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgoYXR0cmlidXRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhdHRyaWJ1dGVzIH0gPSBhdHRyaWJ1dGU7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGVzLnN0eWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmQXNTdHIgPSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGUuc3R5bGVEaWZmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkQXNTdHIgPSBKU09OLnN0cmluZ2lmeShhdHRyaWJ1dGUuX3VuY2hhbmdlZFN0eWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaWZmQXNTdHIubGVuZ3RoIDwgYXR0cmlidXRlcy5zdHlsZS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZGlmZkFzU3RyICsgdW5jaGFuZ2VkQXNTdHIpLnNwbGl0KCd2YXIoJykubGVuZ3RoID09PVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuc3R5bGUuc3BsaXQoJ3ZhcignKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gYXR0cmlidXRlLnN0eWxlRGlmZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5taXJyb3IuZ2V0SWQoYXR0cmlidXRlLm5vZGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBhdHRyaWJ1dGVzLFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGF0dHJpYnV0ZSkgPT4gIWFkZGVkSWRzLmhhcyhhdHRyaWJ1dGUuaWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGF0dHJpYnV0ZSkgPT4gdGhpcy5taXJyb3IuaGFzKGF0dHJpYnV0ZS5pZCkpLFxyXG4gICAgICAgICAgICAgICAgcmVtb3ZlczogdGhpcy5yZW1vdmVzLFxyXG4gICAgICAgICAgICAgICAgYWRkcyxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKCFwYXlsb2FkLnRleHRzLmxlbmd0aCAmJlxyXG4gICAgICAgICAgICAgICAgIXBheWxvYWQuYXR0cmlidXRlcy5sZW5ndGggJiZcclxuICAgICAgICAgICAgICAgICFwYXlsb2FkLnJlbW92ZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAhcGF5bG9hZC5hZGRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudGV4dHMgPSBbXTtcclxuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuYWRkZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMubW92ZWRTZXQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJvcHBlZFNldCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgdGhpcy5tb3ZlZE1hcCA9IHt9O1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uQ2IocGF5bG9hZCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmdlblRleHRBcmVhVmFsdWVNdXRhdGlvbiA9ICh0ZXh0YXJlYSkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgaXRlbSA9IHRoaXMuYXR0cmlidXRlTWFwLmdldCh0ZXh0YXJlYSk7XHJcbiAgICAgICAgICAgIGlmICghaXRlbSkge1xyXG4gICAgICAgICAgICAgICAgaXRlbSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlOiB0ZXh0YXJlYSxcclxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZURpZmY6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIF91bmNoYW5nZWRTdHlsZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KHRleHRhcmVhLCBpdGVtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpdGVtLmF0dHJpYnV0ZXMudmFsdWUgPSBBcnJheS5mcm9tKHRleHRhcmVhLmNoaWxkTm9kZXMsIChjbikgPT4gY24udGV4dENvbnRlbnQgfHwgJycpLmpvaW4oJycpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzTXV0YXRpb24gPSAobSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoaXNJZ25vcmVkKG0udGFyZ2V0LCB0aGlzLm1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzd2l0Y2ggKG0udHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hhcmFjdGVyRGF0YSc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG0udGFyZ2V0LnRleHRDb250ZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKG0udGFyZ2V0LCB0aGlzLmJsb2NrQ2xhc3MsIHRoaXMuYmxvY2tTZWxlY3RvciwgZmFsc2UpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICE9PSBtLm9sZFZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGV4dHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmVlZE1hc2tpbmdUZXh0KG0udGFyZ2V0LCB0aGlzLm1hc2tUZXh0Q2xhc3MsIHRoaXMubWFza1RleHRTZWxlY3RvciwgdHJ1ZSkgJiYgdmFsdWVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubWFza1RleHRGblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubWFza1RleHRGbih2YWx1ZSwgY2xvc2VzdEVsZW1lbnRPZk5vZGUobS50YXJnZXQpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLnJlcGxhY2UoL1tcXFNdL2csICcqJylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbS50YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gbS50YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF0dHJpYnV0ZU5hbWUgPSBtLmF0dHJpYnV0ZU5hbWU7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gbS50YXJnZXQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSAndmFsdWUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBnZXRJbnB1dFR5cGUodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXNrSW5wdXRWYWx1ZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXNrSW5wdXRPcHRpb25zOiB0aGlzLm1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdOYW1lOiB0YXJnZXQudGFnTmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuOiB0aGlzLm1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gbS5vbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGxldCBpdGVtID0gdGhpcy5hdHRyaWJ1dGVNYXAuZ2V0KG0udGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09ICdJRlJBTUUnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWUgPT09ICdzcmMnICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICF0aGlzLmtlZXBJZnJhbWVTcmNGbih2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0YXJnZXQuY29udGVudERvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVOYW1lID0gJ3JyX3NyYyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpdGVtKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBtLnRhcmdldCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVEaWZmOiB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF91bmNoYW5nZWRTdHlsZXM6IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXMucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVNYXAuc2V0KG0udGFyZ2V0LCBpdGVtKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT09ICd0eXBlJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAobS5vbGRWYWx1ZSB8fCAnJykudG9Mb3dlckNhc2UoKSA9PT0gJ3Bhc3N3b3JkJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLXJyLWlzLXBhc3N3b3JkJywgJ3RydWUnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVBdHRyaWJ1dGUodGFyZ2V0LnRhZ05hbWUsIGF0dHJpYnV0ZU5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uYXR0cmlidXRlc1thdHRyaWJ1dGVOYW1lXSA9IHRyYW5zZm9ybUF0dHJpYnV0ZSh0aGlzLmRvYywgdG9Mb3dlckNhc2UodGFyZ2V0LnRhZ05hbWUpLCB0b0xvd2VyQ2FzZShhdHRyaWJ1dGVOYW1lKSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSA9PT0gJ3N0eWxlJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnVuYXR0YWNoZWREb2MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYXR0YWNoZWREb2MgPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5hdHRhY2hlZERvYyA9IHRoaXMuZG9jO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9sZCA9IHRoaXMudW5hdHRhY2hlZERvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobS5vbGRWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZC5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgbS5vbGRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBuYW1lIG9mIEFycmF5LmZyb20odGFyZ2V0LnN0eWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ByaW9yaXR5ID0gdGFyZ2V0LnN0eWxlLmdldFByb3BlcnR5UHJpb3JpdHkocG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocG5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ByaW9yaXR5ICE9PSBvbGQuc3R5bGUuZ2V0UHJvcGVydHlQcmlvcml0eShwbmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1ByaW9yaXR5ID09PSAnJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gbmV3VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnN0eWxlRGlmZltwbmFtZV0gPSBbbmV3VmFsdWUsIG5ld1ByaW9yaXR5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5fdW5jaGFuZ2VkU3R5bGVzW3BuYW1lXSA9IFtuZXdWYWx1ZSwgbmV3UHJpb3JpdHldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG5hbWUgb2YgQXJyYXkuZnJvbShvbGQuc3R5bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHBuYW1lKSA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5zdHlsZURpZmZbcG5hbWVdID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0Jsb2NrZWQobS50YXJnZXQsIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCB0cnVlKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtLnRhcmdldC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuVGV4dEFyZWFWYWx1ZU11dGF0aW9uKG0udGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBtLmFkZGVkTm9kZXMuZm9yRWFjaCgobikgPT4gdGhpcy5nZW5BZGRzKG4sIG0udGFyZ2V0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbS5yZW1vdmVkTm9kZXMuZm9yRWFjaCgobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlSWQgPSB0aGlzLm1pcnJvci5nZXRJZChuKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SWQgPSBpc1NoYWRvd1Jvb3QobS50YXJnZXQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubWlycm9yLmdldElkKG0udGFyZ2V0Lmhvc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMubWlycm9yLmdldElkKG0udGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmxvY2tlZChtLnRhcmdldCwgdGhpcy5ibG9ja0NsYXNzLCB0aGlzLmJsb2NrU2VsZWN0b3IsIGZhbHNlKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNJZ25vcmVkKG4sIHRoaXMubWlycm9yKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzU2VyaWFsaXplZChuLCB0aGlzLm1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hZGRlZFNldC5oYXMobikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBEZWxldGUodGhpcy5hZGRlZFNldCwgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyb3BwZWRTZXQuYWRkKG4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG0udGFyZ2V0KSAmJiBub2RlSWQgPT09IC0xKSA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQW5jZXN0b3JSZW1vdmVkKG0udGFyZ2V0LCB0aGlzLm1pcnJvcikpIDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5tb3ZlZFNldC5oYXMobikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZWRNYXBbbW92ZUtleShub2RlSWQsIHBhcmVudElkKV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBEZWxldGUodGhpcy5tb3ZlZFNldCwgbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGVJZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1NoYWRvdzogaXNTaGFkb3dSb290KG0udGFyZ2V0KSAmJiBpc05hdGl2ZVNoYWRvd0RvbShtLnRhcmdldClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXBSZW1vdmVzLnB1c2gobik7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZ2VuQWRkcyA9IChuLCB0YXJnZXQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuaW5PdGhlckJ1ZmZlcihuLCB0aGlzKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYWRkZWRTZXQuaGFzKG4pIHx8IHRoaXMubW92ZWRTZXQuaGFzKG4pKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5taXJyb3IuaGFzTm9kZShuKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzSWdub3JlZChuLCB0aGlzLm1pcnJvcikpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLm1vdmVkU2V0LmFkZChuKTtcclxuICAgICAgICAgICAgICAgIGxldCB0YXJnZXRJZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICYmIHRoaXMubWlycm9yLmhhc05vZGUodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldElkID0gdGhpcy5taXJyb3IuZ2V0SWQodGFyZ2V0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJZCAmJiB0YXJnZXRJZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVkTWFwW21vdmVLZXkodGhpcy5taXJyb3IuZ2V0SWQobiksIHRhcmdldElkKV0gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRlZFNldC5hZGQobik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRyb3BwZWRTZXQuZGVsZXRlKG4pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghaXNCbG9ja2VkKG4sIHRoaXMuYmxvY2tDbGFzcywgdGhpcy5ibG9ja1NlbGVjdG9yLCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgIG4uY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE4pID0+IHRoaXMuZ2VuQWRkcyhjaGlsZE4pKTtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbi5zaGFkb3dSb290LmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGROKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkTm9kZU1hbmFnZXIuYWRkKGNoaWxkTiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2VuQWRkcyhjaGlsZE4sIG4pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGluaXQob3B0aW9ucykge1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ211dGF0aW9uQ2InLFxyXG4gICAgICAgICAgICAnYmxvY2tDbGFzcycsXHJcbiAgICAgICAgICAgICdibG9ja1NlbGVjdG9yJyxcclxuICAgICAgICAgICAgJ21hc2tUZXh0Q2xhc3MnLFxyXG4gICAgICAgICAgICAnbWFza1RleHRTZWxlY3RvcicsXHJcbiAgICAgICAgICAgICdpbmxpbmVTdHlsZXNoZWV0JyxcclxuICAgICAgICAgICAgJ21hc2tJbnB1dE9wdGlvbnMnLFxyXG4gICAgICAgICAgICAnbWFza1RleHRGbicsXHJcbiAgICAgICAgICAgICdtYXNrSW5wdXRGbicsXHJcbiAgICAgICAgICAgICdrZWVwSWZyYW1lU3JjRm4nLFxyXG4gICAgICAgICAgICAncmVjb3JkQ2FudmFzJyxcclxuICAgICAgICAgICAgJ2lubGluZUltYWdlcycsXHJcbiAgICAgICAgICAgICdzbGltRE9NT3B0aW9ucycsXHJcbiAgICAgICAgICAgICdkYXRhVVJMT3B0aW9ucycsXHJcbiAgICAgICAgICAgICdkb2MnLFxyXG4gICAgICAgICAgICAnbWlycm9yJyxcclxuICAgICAgICAgICAgJ2lmcmFtZU1hbmFnZXInLFxyXG4gICAgICAgICAgICAnc3R5bGVzaGVldE1hbmFnZXInLFxyXG4gICAgICAgICAgICAnc2hhZG93RG9tTWFuYWdlcicsXHJcbiAgICAgICAgICAgICdjYW52YXNNYW5hZ2VyJyxcclxuICAgICAgICAgICAgJ3Byb2Nlc3NlZE5vZGVNYW5hZ2VyJyxcclxuICAgICAgICBdLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzW2tleV0gPSBvcHRpb25zW2tleV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmcmVlemUoKSB7XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuY2FudmFzTWFuYWdlci5mcmVlemUoKTtcclxuICAgIH1cclxuICAgIHVuZnJlZXplKCkge1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLnVuZnJlZXplKCk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCk7XHJcbiAgICB9XHJcbiAgICBpc0Zyb3plbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mcm96ZW47XHJcbiAgICB9XHJcbiAgICBsb2NrKCkge1xyXG4gICAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNhbnZhc01hbmFnZXIubG9jaygpO1xyXG4gICAgfVxyXG4gICAgdW5sb2NrKCkge1xyXG4gICAgICAgIHRoaXMubG9ja2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLnVubG9jaygpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dEb21NYW5hZ2VyLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNNYW5hZ2VyLnJlc2V0KCk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gZGVlcERlbGV0ZShhZGRzU2V0LCBuKSB7XHJcbiAgICBhZGRzU2V0LmRlbGV0ZShuKTtcclxuICAgIG4uY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZE4pID0+IGRlZXBEZWxldGUoYWRkc1NldCwgY2hpbGROKSk7XHJcbn1cclxuZnVuY3Rpb24gaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4sIG1pcnJvcikge1xyXG4gICAgaWYgKHJlbW92ZXMubGVuZ3RoID09PSAwKVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIHJldHVybiBfaXNQYXJlbnRSZW1vdmVkKHJlbW92ZXMsIG4sIG1pcnJvcik7XHJcbn1cclxuZnVuY3Rpb24gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBuLCBtaXJyb3IpIHtcclxuICAgIGNvbnN0IHsgcGFyZW50Tm9kZSB9ID0gbjtcclxuICAgIGlmICghcGFyZW50Tm9kZSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhcmVudElkID0gbWlycm9yLmdldElkKHBhcmVudE5vZGUpO1xyXG4gICAgaWYgKHJlbW92ZXMuc29tZSgocikgPT4gci5pZCA9PT0gcGFyZW50SWQpKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2lzUGFyZW50UmVtb3ZlZChyZW1vdmVzLCBwYXJlbnROb2RlLCBtaXJyb3IpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQW5jZXN0b3JJblNldChzZXQsIG4pIHtcclxuICAgIGlmIChzZXQuc2l6ZSA9PT0gMClcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICByZXR1cm4gX2lzQW5jZXN0b3JJblNldChzZXQsIG4pO1xyXG59XHJcbmZ1bmN0aW9uIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBuKSB7XHJcbiAgICBjb25zdCB7IHBhcmVudE5vZGUgfSA9IG47XHJcbiAgICBpZiAoIXBhcmVudE5vZGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoc2V0LmhhcyhwYXJlbnROb2RlKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc0FuY2VzdG9ySW5TZXQoc2V0LCBwYXJlbnROb2RlKTtcclxufVxuXG5sZXQgZXJyb3JIYW5kbGVyO1xyXG5mdW5jdGlvbiByZWdpc3RlckVycm9ySGFuZGxlcihoYW5kbGVyKSB7XHJcbiAgICBlcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xyXG59XHJcbmZ1bmN0aW9uIHVucmVnaXN0ZXJFcnJvckhhbmRsZXIoKSB7XHJcbiAgICBlcnJvckhhbmRsZXIgPSB1bmRlZmluZWQ7XHJcbn1cclxuY29uc3QgY2FsbGJhY2tXcmFwcGVyID0gKGNiKSA9PiB7XHJcbiAgICBpZiAoIWVycm9ySGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiBjYjtcclxuICAgIH1cclxuICAgIGNvbnN0IHJyd2ViV3JhcHBlZCA9ICgoLi4ucmVzdCkgPT4ge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYiguLi5yZXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvckhhbmRsZXIgJiYgZXJyb3JIYW5kbGVyKGVycm9yKSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHJyd2ViV3JhcHBlZDtcclxufTtcblxuY29uc3QgbXV0YXRpb25CdWZmZXJzID0gW107XHJcbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KGV2ZW50KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGlmICgnY29tcG9zZWRQYXRoJyBpbiBldmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XHJcbiAgICAgICAgICAgIGlmIChwYXRoLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhdGhbMF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3BhdGgnIGluIGV2ZW50ICYmIGV2ZW50LnBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudC5wYXRoWzBdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50ICYmIGV2ZW50LnRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBpbml0TXV0YXRpb25PYnNlcnZlcihvcHRpb25zLCByb290RWwpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBjb25zdCBtdXRhdGlvbkJ1ZmZlciA9IG5ldyBNdXRhdGlvbkJ1ZmZlcigpO1xyXG4gICAgbXV0YXRpb25CdWZmZXJzLnB1c2gobXV0YXRpb25CdWZmZXIpO1xyXG4gICAgbXV0YXRpb25CdWZmZXIuaW5pdChvcHRpb25zKTtcclxuICAgIGxldCBtdXRhdGlvbk9ic2VydmVyQ3RvciA9IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8XHJcbiAgICAgICAgd2luZG93Ll9fcnJNdXRhdGlvbk9ic2VydmVyO1xyXG4gICAgY29uc3QgYW5ndWxhclpvbmVTeW1ib2wgPSAoX2IgPSAoX2EgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuWm9uZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLl9fc3ltYm9sX18pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAnTXV0YXRpb25PYnNlcnZlcicpO1xyXG4gICAgaWYgKGFuZ3VsYXJab25lU3ltYm9sICYmXHJcbiAgICAgICAgd2luZG93W2FuZ3VsYXJab25lU3ltYm9sXSkge1xyXG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXJDdG9yID0gd2luZG93W2FuZ3VsYXJab25lU3ltYm9sXTtcclxuICAgIH1cclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IG11dGF0aW9uT2JzZXJ2ZXJDdG9yKGNhbGxiYWNrV3JhcHBlcihtdXRhdGlvbkJ1ZmZlci5wcm9jZXNzTXV0YXRpb25zLmJpbmQobXV0YXRpb25CdWZmZXIpKSk7XHJcbiAgICBvYnNlcnZlci5vYnNlcnZlKHJvb3RFbCwge1xyXG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXHJcbiAgICAgICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXHJcbiAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcclxuICAgICAgICBjaGFyYWN0ZXJEYXRhT2xkVmFsdWU6IHRydWUsXHJcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxyXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBvYnNlcnZlcjtcclxufVxyXG5mdW5jdGlvbiBpbml0TW92ZU9ic2VydmVyKHsgbW91c2Vtb3ZlQ2IsIHNhbXBsaW5nLCBkb2MsIG1pcnJvciwgfSkge1xyXG4gICAgaWYgKHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0eXBlb2Ygc2FtcGxpbmcubW91c2Vtb3ZlID09PSAnbnVtYmVyJyA/IHNhbXBsaW5nLm1vdXNlbW92ZSA6IDUwO1xyXG4gICAgY29uc3QgY2FsbGJhY2tUaHJlc2hvbGQgPSB0eXBlb2Ygc2FtcGxpbmcubW91c2Vtb3ZlQ2FsbGJhY2sgPT09ICdudW1iZXInXHJcbiAgICAgICAgPyBzYW1wbGluZy5tb3VzZW1vdmVDYWxsYmFja1xyXG4gICAgICAgIDogNTAwO1xyXG4gICAgbGV0IHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgbGV0IHRpbWVCYXNlbGluZTtcclxuICAgIGNvbnN0IHdyYXBwZWRDYiA9IHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcigoc291cmNlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdG90YWxPZmZzZXQgPSBEYXRlLm5vdygpIC0gdGltZUJhc2VsaW5lO1xyXG4gICAgICAgIG1vdXNlbW92ZUNiKHBvc2l0aW9ucy5tYXAoKHApID0+IHtcclxuICAgICAgICAgICAgcC50aW1lT2Zmc2V0IC09IHRvdGFsT2Zmc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gcDtcclxuICAgICAgICB9KSwgc291cmNlKTtcclxuICAgICAgICBwb3NpdGlvbnMgPSBbXTtcclxuICAgICAgICB0aW1lQmFzZWxpbmUgPSBudWxsO1xyXG4gICAgfSksIGNhbGxiYWNrVGhyZXNob2xkKTtcclxuICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9uID0gY2FsbGJhY2tXcmFwcGVyKHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcigoZXZ0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcclxuICAgICAgICBjb25zdCB7IGNsaWVudFgsIGNsaWVudFkgfSA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZ0KVxyXG4gICAgICAgICAgICA/IGV2dC5jaGFuZ2VkVG91Y2hlc1swXVxyXG4gICAgICAgICAgICA6IGV2dDtcclxuICAgICAgICBpZiAoIXRpbWVCYXNlbGluZSkge1xyXG4gICAgICAgICAgICB0aW1lQmFzZWxpbmUgPSBub3dUaW1lc3RhbXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zaXRpb25zLnB1c2goe1xyXG4gICAgICAgICAgICB4OiBjbGllbnRYLFxyXG4gICAgICAgICAgICB5OiBjbGllbnRZLFxyXG4gICAgICAgICAgICBpZDogbWlycm9yLmdldElkKHRhcmdldCksXHJcbiAgICAgICAgICAgIHRpbWVPZmZzZXQ6IG5vd1RpbWVzdGFtcCgpIC0gdGltZUJhc2VsaW5lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHdyYXBwZWRDYih0eXBlb2YgRHJhZ0V2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBldnQgaW5zdGFuY2VvZiBEcmFnRXZlbnRcclxuICAgICAgICAgICAgPyBJbmNyZW1lbnRhbFNvdXJjZSQxLkRyYWdcclxuICAgICAgICAgICAgOiBldnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50XHJcbiAgICAgICAgICAgICAgICA/IEluY3JlbWVudGFsU291cmNlJDEuTW91c2VNb3ZlXHJcbiAgICAgICAgICAgICAgICA6IEluY3JlbWVudGFsU291cmNlJDEuVG91Y2hNb3ZlKTtcclxuICAgIH0pLCB0aHJlc2hvbGQsIHtcclxuICAgICAgICB0cmFpbGluZzogZmFsc2UsXHJcbiAgICB9KSk7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtcclxuICAgICAgICBvbignbW91c2Vtb3ZlJywgdXBkYXRlUG9zaXRpb24sIGRvYyksXHJcbiAgICAgICAgb24oJ3RvdWNobW92ZScsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpLFxyXG4gICAgICAgIG9uKCdkcmFnJywgdXBkYXRlUG9zaXRpb24sIGRvYyksXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRNb3VzZUludGVyYWN0aW9uT2JzZXJ2ZXIoeyBtb3VzZUludGVyYWN0aW9uQ2IsIGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBzYW1wbGluZywgfSkge1xyXG4gICAgaWYgKHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgZGlzYWJsZU1hcCA9IHNhbXBsaW5nLm1vdXNlSW50ZXJhY3Rpb24gPT09IHRydWUgfHxcclxuICAgICAgICBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uID09PSB1bmRlZmluZWRcclxuICAgICAgICA/IHt9XHJcbiAgICAgICAgOiBzYW1wbGluZy5tb3VzZUludGVyYWN0aW9uO1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgIGxldCBjdXJyZW50UG9pbnRlclR5cGUgPSBudWxsO1xyXG4gICAgY29uc3QgZ2V0SGFuZGxlciA9IChldmVudEtleSkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZlbnQpO1xyXG4gICAgICAgICAgICBpZiAoaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgcG9pbnRlclR5cGUgPSBudWxsO1xyXG4gICAgICAgICAgICBsZXQgdGhpc0V2ZW50S2V5ID0gZXZlbnRLZXk7XHJcbiAgICAgICAgICAgIGlmICgncG9pbnRlclR5cGUnIGluIGV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGV2ZW50LnBvaW50ZXJUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbW91c2UnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Nb3VzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG91Y2gnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IFBvaW50ZXJUeXBlcy5Ub3VjaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncGVuJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuUGVuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLlRvdWNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSA9PT0gTW91c2VJbnRlcmFjdGlvbnMuTW91c2VEb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNFdmVudEtleSA9ICdUb3VjaFN0YXJ0JztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoTW91c2VJbnRlcmFjdGlvbnNbZXZlbnRLZXldID09PSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZVVwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNFdmVudEtleSA9ICdUb3VjaEVuZCc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocG9pbnRlclR5cGUgPT09IFBvaW50ZXJUeXBlcy5QZW4pIDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsZWdhY3lfaXNUb3VjaEV2ZW50KGV2ZW50KSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBQb2ludGVyVHlwZXMuVG91Y2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvaW50ZXJUeXBlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcclxuICAgICAgICAgICAgICAgIGlmICgodGhpc0V2ZW50S2V5LnN0YXJ0c1dpdGgoJ1RvdWNoJykgJiZcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLlRvdWNoKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICh0aGlzRXZlbnRLZXkuc3RhcnRzV2l0aCgnTW91c2UnKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9PT0gUG9pbnRlclR5cGVzLk1vdXNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChNb3VzZUludGVyYWN0aW9uc1tldmVudEtleV0gPT09IE1vdXNlSW50ZXJhY3Rpb25zLkNsaWNrKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyVHlwZSA9IGN1cnJlbnRQb2ludGVyVHlwZTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludGVyVHlwZSA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgZSA9IGxlZ2FjeV9pc1RvdWNoRXZlbnQoZXZlbnQpID8gZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gOiBldmVudDtcclxuICAgICAgICAgICAgaWYgKCFlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaWQgPSBtaXJyb3IuZ2V0SWQodGFyZ2V0KTtcclxuICAgICAgICAgICAgY29uc3QgeyBjbGllbnRYLCBjbGllbnRZIH0gPSBlO1xyXG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIobW91c2VJbnRlcmFjdGlvbkNiKShPYmplY3QuYXNzaWduKHsgdHlwZTogTW91c2VJbnRlcmFjdGlvbnNbdGhpc0V2ZW50S2V5XSwgaWQsIHg6IGNsaWVudFgsIHk6IGNsaWVudFkgfSwgKHBvaW50ZXJUeXBlICE9PSBudWxsICYmIHsgcG9pbnRlclR5cGUgfSkpKTtcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIE9iamVjdC5rZXlzKE1vdXNlSW50ZXJhY3Rpb25zKVxyXG4gICAgICAgIC5maWx0ZXIoKGtleSkgPT4gTnVtYmVyLmlzTmFOKE51bWJlcihrZXkpKSAmJlxyXG4gICAgICAgICFrZXkuZW5kc1dpdGgoJ19EZXBhcnRlZCcpICYmXHJcbiAgICAgICAgZGlzYWJsZU1hcFtrZXldICE9PSBmYWxzZSlcclxuICAgICAgICAuZm9yRWFjaCgoZXZlbnRLZXkpID0+IHtcclxuICAgICAgICBsZXQgZXZlbnROYW1lID0gdG9Mb3dlckNhc2UoZXZlbnRLZXkpO1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBnZXRIYW5kbGVyKGV2ZW50S2V5KTtcclxuICAgICAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKE1vdXNlSW50ZXJhY3Rpb25zW2V2ZW50S2V5XSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBNb3VzZUludGVyYWN0aW9ucy5Nb3VzZURvd246XHJcbiAgICAgICAgICAgICAgICBjYXNlIE1vdXNlSW50ZXJhY3Rpb25zLk1vdXNlVXA6XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnJlcGxhY2UoJ21vdXNlJywgJ3BvaW50ZXInKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuVG91Y2hTdGFydDpcclxuICAgICAgICAgICAgICAgIGNhc2UgTW91c2VJbnRlcmFjdGlvbnMuVG91Y2hFbmQ6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGhhbmRsZXJzLnB1c2gob24oZXZlbnROYW1lLCBoYW5kbGVyLCBkb2MpKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRTY3JvbGxPYnNlcnZlcih7IHNjcm9sbENiLCBkb2MsIG1pcnJvciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvciwgc2FtcGxpbmcsIH0pIHtcclxuICAgIGNvbnN0IHVwZGF0ZVBvc2l0aW9uID0gY2FsbGJhY2tXcmFwcGVyKHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcigoZXZ0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQoZXZ0KTtcclxuICAgICAgICBpZiAoIXRhcmdldCB8fFxyXG4gICAgICAgICAgICBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGlkID0gbWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PT0gZG9jICYmIGRvYy5kZWZhdWx0Vmlldykge1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxMZWZ0VG9wID0gZ2V0V2luZG93U2Nyb2xsKGRvYy5kZWZhdWx0Vmlldyk7XHJcbiAgICAgICAgICAgIHNjcm9sbENiKHtcclxuICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgeDogc2Nyb2xsTGVmdFRvcC5sZWZ0LFxyXG4gICAgICAgICAgICAgICAgeTogc2Nyb2xsTGVmdFRvcC50b3AsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2Nyb2xsQ2Ioe1xyXG4gICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICB4OiB0YXJnZXQuc2Nyb2xsTGVmdCxcclxuICAgICAgICAgICAgICAgIHk6IHRhcmdldC5zY3JvbGxUb3AsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH0pLCBzYW1wbGluZy5zY3JvbGwgfHwgMTAwKSk7XHJcbiAgICByZXR1cm4gb24oJ3Njcm9sbCcsIHVwZGF0ZVBvc2l0aW9uLCBkb2MpO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRWaWV3cG9ydFJlc2l6ZU9ic2VydmVyKHsgdmlld3BvcnRSZXNpemVDYiB9LCB7IHdpbiB9KSB7XHJcbiAgICBsZXQgbGFzdEggPSAtMTtcclxuICAgIGxldCBsYXN0VyA9IC0xO1xyXG4gICAgY29uc3QgdXBkYXRlRGltZW5zaW9uID0gY2FsbGJhY2tXcmFwcGVyKHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0V2luZG93SGVpZ2h0KCk7XHJcbiAgICAgICAgY29uc3Qgd2lkdGggPSBnZXRXaW5kb3dXaWR0aCgpO1xyXG4gICAgICAgIGlmIChsYXN0SCAhPT0gaGVpZ2h0IHx8IGxhc3RXICE9PSB3aWR0aCkge1xyXG4gICAgICAgICAgICB2aWV3cG9ydFJlc2l6ZUNiKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBOdW1iZXIod2lkdGgpLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBOdW1iZXIoaGVpZ2h0KSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGxhc3RIID0gaGVpZ2h0O1xyXG4gICAgICAgICAgICBsYXN0VyA9IHdpZHRoO1xyXG4gICAgICAgIH1cclxuICAgIH0pLCAyMDApKTtcclxuICAgIHJldHVybiBvbigncmVzaXplJywgdXBkYXRlRGltZW5zaW9uLCB3aW4pO1xyXG59XHJcbmNvbnN0IElOUFVUX1RBR1MgPSBbJ0lOUFVUJywgJ1RFWFRBUkVBJywgJ1NFTEVDVCddO1xyXG5jb25zdCBsYXN0SW5wdXRWYWx1ZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbmZ1bmN0aW9uIGluaXRJbnB1dE9ic2VydmVyKHsgaW5wdXRDYiwgZG9jLCBtaXJyb3IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIGlnbm9yZUNsYXNzLCBpZ25vcmVTZWxlY3RvciwgbWFza0lucHV0T3B0aW9ucywgbWFza0lucHV0Rm4sIHNhbXBsaW5nLCB1c2VyVHJpZ2dlcmVkT25JbnB1dCwgfSkge1xyXG4gICAgZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGV2ZW50KSB7XHJcbiAgICAgICAgbGV0IHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICBjb25zdCB1c2VyVHJpZ2dlcmVkID0gZXZlbnQuaXNUcnVzdGVkO1xyXG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSB0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWU7XHJcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YWdOYW1lID09PSAnT1BUSU9OJykge1xyXG4gICAgICAgICAgICB0YXJnZXQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHxcclxuICAgICAgICAgICAgIXRhZ05hbWUgfHxcclxuICAgICAgICAgICAgSU5QVVRfVEFHUy5pbmRleE9mKHRhZ05hbWUpIDwgMCB8fFxyXG4gICAgICAgICAgICBpc0Jsb2NrZWQodGFyZ2V0LCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB0cnVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGlnbm9yZUNsYXNzKSB8fFxyXG4gICAgICAgICAgICAoaWdub3JlU2VsZWN0b3IgJiYgdGFyZ2V0Lm1hdGNoZXMoaWdub3JlU2VsZWN0b3IpKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0ZXh0ID0gdGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgIGxldCBpc0NoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB0eXBlID0gZ2V0SW5wdXRUeXBlKHRhcmdldCkgfHwgJyc7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94Jykge1xyXG4gICAgICAgICAgICBpc0NoZWNrZWQgPSB0YXJnZXQuY2hlY2tlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWFza0lucHV0T3B0aW9uc1t0YWdOYW1lLnRvTG93ZXJDYXNlKCldIHx8XHJcbiAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnNbdHlwZV0pIHtcclxuICAgICAgICAgICAgdGV4dCA9IG1hc2tJbnB1dFZhbHVlKHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICB0YWdOYW1lLFxyXG4gICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgbWFza0lucHV0Rm4sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYldpdGhEZWR1cCh0YXJnZXQsIHVzZXJUcmlnZ2VyZWRPbklucHV0XHJcbiAgICAgICAgICAgID8geyB0ZXh0LCBpc0NoZWNrZWQsIHVzZXJUcmlnZ2VyZWQgfVxyXG4gICAgICAgICAgICA6IHsgdGV4dCwgaXNDaGVja2VkIH0pO1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubmFtZTtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICYmIGlzQ2hlY2tlZCkge1xyXG4gICAgICAgICAgICBkb2NcclxuICAgICAgICAgICAgICAgIC5xdWVyeVNlbGVjdG9yQWxsKGBpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIiR7bmFtZX1cIl1gKVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goKGVsKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwgIT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBlbC52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYldpdGhEZWR1cChlbCwgdXNlclRyaWdnZXJlZE9uSW5wdXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHRleHQsIGlzQ2hlY2tlZDogIWlzQ2hlY2tlZCwgdXNlclRyaWdnZXJlZDogZmFsc2UgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgdGV4dCwgaXNDaGVja2VkOiAhaXNDaGVja2VkIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjYldpdGhEZWR1cCh0YXJnZXQsIHYpIHtcclxuICAgICAgICBjb25zdCBsYXN0SW5wdXRWYWx1ZSA9IGxhc3RJbnB1dFZhbHVlTWFwLmdldCh0YXJnZXQpO1xyXG4gICAgICAgIGlmICghbGFzdElucHV0VmFsdWUgfHxcclxuICAgICAgICAgICAgbGFzdElucHV0VmFsdWUudGV4dCAhPT0gdi50ZXh0IHx8XHJcbiAgICAgICAgICAgIGxhc3RJbnB1dFZhbHVlLmlzQ2hlY2tlZCAhPT0gdi5pc0NoZWNrZWQpIHtcclxuICAgICAgICAgICAgbGFzdElucHV0VmFsdWVNYXAuc2V0KHRhcmdldCwgdik7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gbWlycm9yLmdldElkKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihpbnB1dENiKShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHYpLCB7IGlkIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBldmVudHMgPSBzYW1wbGluZy5pbnB1dCA9PT0gJ2xhc3QnID8gWydjaGFuZ2UnXSA6IFsnaW5wdXQnLCAnY2hhbmdlJ107XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IGV2ZW50cy5tYXAoKGV2ZW50TmFtZSkgPT4gb24oZXZlbnROYW1lLCBjYWxsYmFja1dyYXBwZXIoZXZlbnRIYW5kbGVyKSwgZG9jKSk7XHJcbiAgICBjb25zdCBjdXJyZW50V2luZG93ID0gZG9jLmRlZmF1bHRWaWV3O1xyXG4gICAgaWYgKCFjdXJyZW50V2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvcGVydHlEZXNjcmlwdG9yID0gY3VycmVudFdpbmRvdy5PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGN1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsICd2YWx1ZScpO1xyXG4gICAgY29uc3QgaG9va1Byb3BlcnRpZXMgPSBbXHJcbiAgICAgICAgW2N1cnJlbnRXaW5kb3cuSFRNTElucHV0RWxlbWVudC5wcm90b3R5cGUsICd2YWx1ZSddLFxyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxJbnB1dEVsZW1lbnQucHJvdG90eXBlLCAnY2hlY2tlZCddLFxyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSwgJ3ZhbHVlJ10sXHJcbiAgICAgICAgW2N1cnJlbnRXaW5kb3cuSFRNTFRleHRBcmVhRWxlbWVudC5wcm90b3R5cGUsICd2YWx1ZSddLFxyXG4gICAgICAgIFtjdXJyZW50V2luZG93LkhUTUxTZWxlY3RFbGVtZW50LnByb3RvdHlwZSwgJ3NlbGVjdGVkSW5kZXgnXSxcclxuICAgICAgICBbY3VycmVudFdpbmRvdy5IVE1MT3B0aW9uRWxlbWVudC5wcm90b3R5cGUsICdzZWxlY3RlZCddLFxyXG4gICAgXTtcclxuICAgIGlmIChwcm9wZXJ0eURlc2NyaXB0b3IgJiYgcHJvcGVydHlEZXNjcmlwdG9yLnNldCkge1xyXG4gICAgICAgIGhhbmRsZXJzLnB1c2goLi4uaG9va1Byb3BlcnRpZXMubWFwKChwKSA9PiBob29rU2V0dGVyKHBbMF0sIHBbMV0sIHtcclxuICAgICAgICAgICAgc2V0KCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2tXcmFwcGVyKGV2ZW50SGFuZGxlcikoe1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBpc1RydXN0ZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSwgZmFsc2UsIGN1cnJlbnRXaW5kb3cpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyhydWxlKSB7XHJcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcclxuICAgIGZ1bmN0aW9uIHJlY3Vyc2UoY2hpbGRSdWxlLCBwb3MpIHtcclxuICAgICAgICBpZiAoKGhhc05lc3RlZENTU1J1bGUoJ0NTU0dyb3VwaW5nUnVsZScpICYmXHJcbiAgICAgICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTR3JvdXBpbmdSdWxlKSB8fFxyXG4gICAgICAgICAgICAoaGFzTmVzdGVkQ1NTUnVsZSgnQ1NTTWVkaWFSdWxlJykgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTTWVkaWFSdWxlKSB8fFxyXG4gICAgICAgICAgICAoaGFzTmVzdGVkQ1NTUnVsZSgnQ1NTU3VwcG9ydHNSdWxlJykgJiZcclxuICAgICAgICAgICAgICAgIGNoaWxkUnVsZS5wYXJlbnRSdWxlIGluc3RhbmNlb2YgQ1NTU3VwcG9ydHNSdWxlKSB8fFxyXG4gICAgICAgICAgICAoaGFzTmVzdGVkQ1NTUnVsZSgnQ1NTQ29uZGl0aW9uUnVsZScpICYmXHJcbiAgICAgICAgICAgICAgICBjaGlsZFJ1bGUucGFyZW50UnVsZSBpbnN0YW5jZW9mIENTU0NvbmRpdGlvblJ1bGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gQXJyYXkuZnJvbShjaGlsZFJ1bGUucGFyZW50UnVsZS5jc3NSdWxlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcnVsZXMuaW5kZXhPZihjaGlsZFJ1bGUpO1xyXG4gICAgICAgICAgICBwb3MudW5zaGlmdChpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNoaWxkUnVsZS5wYXJlbnRTdHlsZVNoZWV0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gQXJyYXkuZnJvbShjaGlsZFJ1bGUucGFyZW50U3R5bGVTaGVldC5jc3NSdWxlcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcnVsZXMuaW5kZXhPZihjaGlsZFJ1bGUpO1xyXG4gICAgICAgICAgICBwb3MudW5zaGlmdChpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb3M7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVjdXJzZShydWxlLCBwb3NpdGlvbnMpO1xyXG59XHJcbmZ1bmN0aW9uIGdldElkQW5kU3R5bGVJZChzaGVldCwgbWlycm9yLCBzdHlsZU1pcnJvcikge1xyXG4gICAgbGV0IGlkLCBzdHlsZUlkO1xyXG4gICAgaWYgKCFzaGVldClcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICBpZiAoc2hlZXQub3duZXJOb2RlKVxyXG4gICAgICAgIGlkID0gbWlycm9yLmdldElkKHNoZWV0Lm93bmVyTm9kZSk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgc3R5bGVJZCA9IHN0eWxlTWlycm9yLmdldElkKHNoZWV0KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICBpZCxcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcih7IHN0eWxlU2hlZXRSdWxlQ2IsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIgfSwgeyB3aW4gfSkge1xyXG4gICAgaWYgKCF3aW4uQ1NTU3R5bGVTaGVldCB8fCAhd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgY29uc3QgaW5zZXJ0UnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlO1xyXG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBuZXcgUHJveHkoaW5zZXJ0UnVsZSwge1xyXG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBbcnVsZSwgaW5kZXhdID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIGFkZHM6IFt7IHJ1bGUsIGluZGV4IH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICB9KSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgZGVsZXRlUnVsZSA9IHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlO1xyXG4gICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmRlbGV0ZVJ1bGUgPSBuZXcgUHJveHkoZGVsZXRlUnVsZSwge1xyXG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBbaW5kZXhdID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcsIG1pcnJvciwgc3R5bGVzaGVldE1hbmFnZXIuc3R5bGVNaXJyb3IpO1xyXG4gICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZXM6IFt7IGluZGV4IH1dLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICB9KSxcclxuICAgIH0pO1xyXG4gICAgbGV0IHJlcGxhY2U7XHJcbiAgICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UpIHtcclxuICAgICAgICByZXBsYWNlID0gd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2U7XHJcbiAgICAgICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2UgPSBuZXcgUHJveHkocmVwbGFjZSwge1xyXG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFt0ZXh0XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZywgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlOiB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBsZXQgcmVwbGFjZVN5bmM7XHJcbiAgICBpZiAod2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jKSB7XHJcbiAgICAgICAgcmVwbGFjZVN5bmMgPSB3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmM7XHJcbiAgICAgICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLnJlcGxhY2VTeW5jID0gbmV3IFByb3h5KHJlcGxhY2VTeW5jLCB7XHJcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3RleHRdID0gYXJndW1lbnRzTGlzdDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCh0aGlzQXJnLCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcGxhY2VTeW5jOiB0ZXh0LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMgPSB7fTtcclxuICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoJ0NTU0dyb3VwaW5nUnVsZScpKSB7XHJcbiAgICAgICAgc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzLkNTU0dyb3VwaW5nUnVsZSA9IHdpbi5DU1NHcm91cGluZ1J1bGU7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBpZiAoY2FuTW9ua2V5UGF0Y2hOZXN0ZWRDU1NSdWxlKCdDU1NNZWRpYVJ1bGUnKSkge1xyXG4gICAgICAgICAgICBzdXBwb3J0ZWROZXN0ZWRDU1NSdWxlVHlwZXMuQ1NTTWVkaWFSdWxlID0gd2luLkNTU01lZGlhUnVsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZSgnQ1NTQ29uZGl0aW9uUnVsZScpKSB7XHJcbiAgICAgICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NDb25kaXRpb25SdWxlID0gd2luLkNTU0NvbmRpdGlvblJ1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjYW5Nb25rZXlQYXRjaE5lc3RlZENTU1J1bGUoJ0NTU1N1cHBvcnRzUnVsZScpKSB7XHJcbiAgICAgICAgICAgIHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcy5DU1NTdXBwb3J0c1J1bGUgPSB3aW4uQ1NTU3VwcG9ydHNSdWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNvbnN0IHVubW9kaWZpZWRGdW5jdGlvbnMgPSB7fTtcclxuICAgIE9iamVjdC5lbnRyaWVzKHN1cHBvcnRlZE5lc3RlZENTU1J1bGVUeXBlcykuZm9yRWFjaCgoW3R5cGVLZXksIHR5cGVdKSA9PiB7XHJcbiAgICAgICAgdW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XSA9IHtcclxuICAgICAgICAgICAgaW5zZXJ0UnVsZTogdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSxcclxuICAgICAgICAgICAgZGVsZXRlUnVsZTogdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHR5cGUucHJvdG90eXBlLmluc2VydFJ1bGUgPSBuZXcgUHJveHkodW5tb2RpZmllZEZ1bmN0aW9uc1t0eXBlS2V5XS5pbnNlcnRSdWxlLCB7XHJcbiAgICAgICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgW3J1bGUsIGluZGV4XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQodGhpc0FyZy5wYXJlbnRTdHlsZVNoZWV0LCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHM6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4IHx8IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0eXBlLnByb3RvdHlwZS5kZWxldGVSdWxlID0gbmV3IFByb3h5KHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZSwge1xyXG4gICAgICAgICAgICBhcHBseTogY2FsbGJhY2tXcmFwcGVyKCh0YXJnZXQsIHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IFtpbmRleF0gPSBhcmd1bWVudHNMaXN0O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgc3R5bGVJZCB9ID0gZ2V0SWRBbmRTdHlsZUlkKHRoaXNBcmcucGFyZW50U3R5bGVTaGVldCwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGlkICYmIGlkICE9PSAtMSkgfHwgKHN0eWxlSWQgJiYgc3R5bGVJZCAhPT0gLTEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldFJ1bGVDYih7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGluZGV4OiBbLi4uZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnKSwgaW5kZXhdIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KHRoaXNBcmcsIGFyZ3VtZW50c0xpc3QpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgd2luLkNTU1N0eWxlU2hlZXQucHJvdG90eXBlLmluc2VydFJ1bGUgPSBpbnNlcnRSdWxlO1xyXG4gICAgICAgIHdpbi5DU1NTdHlsZVNoZWV0LnByb3RvdHlwZS5kZWxldGVSdWxlID0gZGVsZXRlUnVsZTtcclxuICAgICAgICByZXBsYWNlICYmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZSA9IHJlcGxhY2UpO1xyXG4gICAgICAgIHJlcGxhY2VTeW5jICYmICh3aW4uQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUucmVwbGFjZVN5bmMgPSByZXBsYWNlU3luYyk7XHJcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc3VwcG9ydGVkTmVzdGVkQ1NTUnVsZVR5cGVzKS5mb3JFYWNoKChbdHlwZUtleSwgdHlwZV0pID0+IHtcclxuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuaW5zZXJ0UnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uaW5zZXJ0UnVsZTtcclxuICAgICAgICAgICAgdHlwZS5wcm90b3R5cGUuZGVsZXRlUnVsZSA9IHVubW9kaWZpZWRGdW5jdGlvbnNbdHlwZUtleV0uZGVsZXRlUnVsZTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKHsgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlciwgfSwgaG9zdCkge1xyXG4gICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICBsZXQgaG9zdElkID0gbnVsbDtcclxuICAgIGlmIChob3N0Lm5vZGVOYW1lID09PSAnI2RvY3VtZW50JylcclxuICAgICAgICBob3N0SWQgPSBtaXJyb3IuZ2V0SWQoaG9zdCk7XHJcbiAgICBlbHNlXHJcbiAgICAgICAgaG9zdElkID0gbWlycm9yLmdldElkKGhvc3QuaG9zdCk7XHJcbiAgICBjb25zdCBwYXRjaFRhcmdldCA9IGhvc3Qubm9kZU5hbWUgPT09ICcjZG9jdW1lbnQnXHJcbiAgICAgICAgPyAoX2EgPSBob3N0LmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuRG9jdW1lbnRcclxuICAgICAgICA6IChfYyA9IChfYiA9IGhvc3Qub3duZXJEb2N1bWVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlZmF1bHRWaWV3KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuU2hhZG93Um9vdDtcclxuICAgIGNvbnN0IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yID0gKHBhdGNoVGFyZ2V0ID09PSBudWxsIHx8IHBhdGNoVGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXRjaFRhcmdldC5wcm90b3R5cGUpXHJcbiAgICAgICAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHBhdGNoVGFyZ2V0ID09PSBudWxsIHx8IHBhdGNoVGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXRjaFRhcmdldC5wcm90b3R5cGUsICdhZG9wdGVkU3R5bGVTaGVldHMnKVxyXG4gICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgaWYgKGhvc3RJZCA9PT0gbnVsbCB8fFxyXG4gICAgICAgIGhvc3RJZCA9PT0gLTEgfHxcclxuICAgICAgICAhcGF0Y2hUYXJnZXQgfHxcclxuICAgICAgICAhb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IpXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QsICdhZG9wdGVkU3R5bGVTaGVldHMnLCB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5jb25maWd1cmFibGUsXHJcbiAgICAgICAgZW51bWVyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuZW51bWVyYWJsZSxcclxuICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIChfYSA9IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXQoc2hlZXRzKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gKF9hID0gb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3Iuc2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBzaGVldHMpO1xyXG4gICAgICAgICAgICBpZiAoaG9zdElkICE9PSBudWxsICYmIGhvc3RJZCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYWRvcHRTdHlsZVNoZWV0cyhzaGVldHMsIGhvc3RJZCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGhvc3QsICdhZG9wdGVkU3R5bGVTaGVldHMnLCB7XHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogb3JpZ2luYWxQcm9wZXJ0eURlc2NyaXB0b3IuY29uZmlndXJhYmxlLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5lbnVtZXJhYmxlLFxyXG4gICAgICAgICAgICBnZXQ6IG9yaWdpbmFsUHJvcGVydHlEZXNjcmlwdG9yLmdldCxcclxuICAgICAgICAgICAgc2V0OiBvcmlnaW5hbFByb3BlcnR5RGVzY3JpcHRvci5zZXQsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0U3R5bGVEZWNsYXJhdGlvbk9ic2VydmVyKHsgc3R5bGVEZWNsYXJhdGlvbkNiLCBtaXJyb3IsIGlnbm9yZUNTU0F0dHJpYnV0ZXMsIHN0eWxlc2hlZXRNYW5hZ2VyLCB9LCB7IHdpbiB9KSB7XHJcbiAgICBjb25zdCBzZXRQcm9wZXJ0eSA9IHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eTtcclxuICAgIHdpbi5DU1NTdHlsZURlY2xhcmF0aW9uLnByb3RvdHlwZS5zZXRQcm9wZXJ0eSA9IG5ldyBQcm94eShzZXRQcm9wZXJ0eSwge1xyXG4gICAgICAgIGFwcGx5OiBjYWxsYmFja1dyYXBwZXIoKHRhcmdldCwgdGhpc0FyZywgYXJndW1lbnRzTGlzdCkgPT4ge1xyXG4gICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsdWUsIHByaW9yaXR5XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgIGlmIChpZ25vcmVDU1NBdHRyaWJ1dGVzLmhhcyhwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRQcm9wZXJ0eS5hcHBseSh0aGlzQXJnLCBbcHJvcGVydHksIHZhbHVlLCBwcmlvcml0eV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIHN0eWxlSWQgfSA9IGdldElkQW5kU3R5bGVJZCgoX2EgPSB0aGlzQXJnLnBhcmVudFJ1bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnRTdHlsZVNoZWV0LCBtaXJyb3IsIHN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKTtcclxuICAgICAgICAgICAgaWYgKChpZCAmJiBpZCAhPT0gLTEpIHx8IChzdHlsZUlkICYmIHN0eWxlSWQgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiKHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHNldDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5LFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGdldE5lc3RlZENTU1J1bGVQb3NpdGlvbnModGhpc0FyZy5wYXJlbnRSdWxlKSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzTGlzdCk7XHJcbiAgICAgICAgfSksXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHJlbW92ZVByb3BlcnR5ID0gd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5O1xyXG4gICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gbmV3IFByb3h5KHJlbW92ZVByb3BlcnR5LCB7XHJcbiAgICAgICAgYXBwbHk6IGNhbGxiYWNrV3JhcHBlcigodGFyZ2V0LCB0aGlzQXJnLCBhcmd1bWVudHNMaXN0KSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgY29uc3QgW3Byb3BlcnR5XSA9IGFyZ3VtZW50c0xpc3Q7XHJcbiAgICAgICAgICAgIGlmIChpZ25vcmVDU1NBdHRyaWJ1dGVzLmhhcyhwcm9wZXJ0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZW1vdmVQcm9wZXJ0eS5hcHBseSh0aGlzQXJnLCBbcHJvcGVydHldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB7IGlkLCBzdHlsZUlkIH0gPSBnZXRJZEFuZFN0eWxlSWQoKF9hID0gdGhpc0FyZy5wYXJlbnRSdWxlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50U3R5bGVTaGVldCwgbWlycm9yLCBzdHlsZXNoZWV0TWFuYWdlci5zdHlsZU1pcnJvcik7XHJcbiAgICAgICAgICAgIGlmICgoaWQgJiYgaWQgIT09IC0xKSB8fCAoc3R5bGVJZCAmJiBzdHlsZUlkICE9PSAtMSkpIHtcclxuICAgICAgICAgICAgICAgIHN0eWxlRGVjbGFyYXRpb25DYih7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVJZCxcclxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHksXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBpbmRleDogZ2V0TmVzdGVkQ1NTUnVsZVBvc2l0aW9ucyh0aGlzQXJnLnBhcmVudFJ1bGUpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseSh0aGlzQXJnLCBhcmd1bWVudHNMaXN0KTtcclxuICAgICAgICB9KSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XHJcbiAgICAgICAgd2luLkNTU1N0eWxlRGVjbGFyYXRpb24ucHJvdG90eXBlLnJlbW92ZVByb3BlcnR5ID0gcmVtb3ZlUHJvcGVydHk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBpbml0TWVkaWFJbnRlcmFjdGlvbk9ic2VydmVyKHsgbWVkaWFJbnRlcmFjdGlvbkNiLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBtaXJyb3IsIHNhbXBsaW5nLCBkb2MsIH0pIHtcclxuICAgIGNvbnN0IGhhbmRsZXIgPSBjYWxsYmFja1dyYXBwZXIoKHR5cGUpID0+IHRocm90dGxlKGNhbGxiYWNrV3JhcHBlcigoZXZlbnQpID0+IHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQgfHxcclxuICAgICAgICAgICAgaXNCbG9ja2VkKHRhcmdldCwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB7IGN1cnJlbnRUaW1lLCB2b2x1bWUsIG11dGVkLCBwbGF5YmFja1JhdGUsIGxvb3AgfSA9IHRhcmdldDtcclxuICAgICAgICBtZWRpYUludGVyYWN0aW9uQ2Ioe1xyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBpZDogbWlycm9yLmdldElkKHRhcmdldCksXHJcbiAgICAgICAgICAgIGN1cnJlbnRUaW1lLFxyXG4gICAgICAgICAgICB2b2x1bWUsXHJcbiAgICAgICAgICAgIG11dGVkLFxyXG4gICAgICAgICAgICBwbGF5YmFja1JhdGUsXHJcbiAgICAgICAgICAgIGxvb3AsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9KSwgc2FtcGxpbmcubWVkaWEgfHwgNTAwKSk7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtcclxuICAgICAgICBvbigncGxheScsIGhhbmRsZXIoMCksIGRvYyksXHJcbiAgICAgICAgb24oJ3BhdXNlJywgaGFuZGxlcigxKSwgZG9jKSxcclxuICAgICAgICBvbignc2Vla2VkJywgaGFuZGxlcigyKSwgZG9jKSxcclxuICAgICAgICBvbigndm9sdW1lY2hhbmdlJywgaGFuZGxlcigzKSwgZG9jKSxcclxuICAgICAgICBvbigncmF0ZWNoYW5nZScsIGhhbmRsZXIoNCksIGRvYyksXHJcbiAgICBdO1xyXG4gICAgcmV0dXJuIGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRGb250T2JzZXJ2ZXIoeyBmb250Q2IsIGRvYyB9KSB7XHJcbiAgICBjb25zdCB3aW4gPSBkb2MuZGVmYXVsdFZpZXc7XHJcbiAgICBpZiAoIXdpbikge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICBjb25zdCBmb250TWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgIGNvbnN0IG9yaWdpbmFsRm9udEZhY2UgPSB3aW4uRm9udEZhY2U7XHJcbiAgICB3aW4uRm9udEZhY2UgPSBmdW5jdGlvbiBGb250RmFjZShmYW1pbHksIHNvdXJjZSwgZGVzY3JpcHRvcnMpIHtcclxuICAgICAgICBjb25zdCBmb250RmFjZSA9IG5ldyBvcmlnaW5hbEZvbnRGYWNlKGZhbWlseSwgc291cmNlLCBkZXNjcmlwdG9ycyk7XHJcbiAgICAgICAgZm9udE1hcC5zZXQoZm9udEZhY2UsIHtcclxuICAgICAgICAgICAgZmFtaWx5LFxyXG4gICAgICAgICAgICBidWZmZXI6IHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnLFxyXG4gICAgICAgICAgICBkZXNjcmlwdG9ycyxcclxuICAgICAgICAgICAgZm9udFNvdXJjZTogdHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZydcclxuICAgICAgICAgICAgICAgID8gc291cmNlXHJcbiAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20obmV3IFVpbnQ4QXJyYXkoc291cmNlKSkpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBmb250RmFjZTtcclxuICAgIH07XHJcbiAgICBjb25zdCByZXN0b3JlSGFuZGxlciA9IHBhdGNoKGRvYy5mb250cywgJ2FkZCcsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm9udEZhY2UpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IGZvbnRNYXAuZ2V0KGZvbnRGYWNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9udENiKHApO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvbnRNYXAuZGVsZXRlKGZvbnRGYWNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSksIDApO1xyXG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgW2ZvbnRGYWNlXSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgaGFuZGxlcnMucHVzaCgoKSA9PiB7XHJcbiAgICAgICAgd2luLkZvbnRGYWNlID0gb3JpZ2luYWxGb250RmFjZTtcclxuICAgIH0pO1xyXG4gICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKCgpID0+IHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdFNlbGVjdGlvbk9ic2VydmVyKHBhcmFtKSB7XHJcbiAgICBjb25zdCB7IGRvYywgbWlycm9yLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBzZWxlY3Rpb25DYiB9ID0gcGFyYW07XHJcbiAgICBsZXQgY29sbGFwc2VkID0gdHJ1ZTtcclxuICAgIGNvbnN0IHVwZGF0ZVNlbGVjdGlvbiA9IGNhbGxiYWNrV3JhcHBlcigoKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZG9jLmdldFNlbGVjdGlvbigpO1xyXG4gICAgICAgIGlmICghc2VsZWN0aW9uIHx8IChjb2xsYXBzZWQgJiYgKHNlbGVjdGlvbiA9PT0gbnVsbCB8fCBzZWxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29sbGFwc2VkID0gc2VsZWN0aW9uLmlzQ29sbGFwc2VkIHx8IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gc2VsZWN0aW9uLnJhbmdlQ291bnQgfHwgMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdChpKTtcclxuICAgICAgICAgICAgY29uc3QgeyBzdGFydENvbnRhaW5lciwgc3RhcnRPZmZzZXQsIGVuZENvbnRhaW5lciwgZW5kT2Zmc2V0IH0gPSByYW5nZTtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tlZCA9IGlzQmxvY2tlZChzdGFydENvbnRhaW5lciwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkgfHxcclxuICAgICAgICAgICAgICAgIGlzQmxvY2tlZChlbmRDb250YWluZXIsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoYmxvY2tlZClcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICByYW5nZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgICBzdGFydDogbWlycm9yLmdldElkKHN0YXJ0Q29udGFpbmVyKSxcclxuICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0LFxyXG4gICAgICAgICAgICAgICAgZW5kOiBtaXJyb3IuZ2V0SWQoZW5kQ29udGFpbmVyKSxcclxuICAgICAgICAgICAgICAgIGVuZE9mZnNldCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGlvbkNiKHsgcmFuZ2VzIH0pO1xyXG4gICAgfSk7XHJcbiAgICB1cGRhdGVTZWxlY3Rpb24oKTtcclxuICAgIHJldHVybiBvbignc2VsZWN0aW9uY2hhbmdlJywgdXBkYXRlU2VsZWN0aW9uKTtcclxufVxyXG5mdW5jdGlvbiBpbml0Q3VzdG9tRWxlbWVudE9ic2VydmVyKHsgZG9jLCBjdXN0b21FbGVtZW50Q2IsIH0pIHtcclxuICAgIGNvbnN0IHdpbiA9IGRvYy5kZWZhdWx0VmlldztcclxuICAgIGlmICghd2luIHx8ICF3aW4uY3VzdG9tRWxlbWVudHMpXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcclxuICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2god2luLmN1c3RvbUVsZW1lbnRzLCAnZGVmaW5lJywgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9ucykge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudENiKHtcclxuICAgICAgICAgICAgICAgICAgICBkZWZpbmU6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgQ3VzdG9tIGVsZW1lbnQgY2FsbGJhY2sgZmFpbGVkIGZvciAke25hbWV9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsLmFwcGx5KHRoaXMsIFtuYW1lLCBjb25zdHJ1Y3Rvciwgb3B0aW9uc10pO1xyXG4gICAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN0b3JlSGFuZGxlcjtcclxufVxyXG5mdW5jdGlvbiBtZXJnZUhvb2tzKG8sIGhvb2tzKSB7XHJcbiAgICBjb25zdCB7IG11dGF0aW9uQ2IsIG1vdXNlbW92ZUNiLCBtb3VzZUludGVyYWN0aW9uQ2IsIHNjcm9sbENiLCB2aWV3cG9ydFJlc2l6ZUNiLCBpbnB1dENiLCBtZWRpYUludGVyYWN0aW9uQ2IsIHN0eWxlU2hlZXRSdWxlQ2IsIHN0eWxlRGVjbGFyYXRpb25DYiwgY2FudmFzTXV0YXRpb25DYiwgZm9udENiLCBzZWxlY3Rpb25DYiwgY3VzdG9tRWxlbWVudENiLCB9ID0gbztcclxuICAgIG8ubXV0YXRpb25DYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLm11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLm11dGF0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtdXRhdGlvbkNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8ubW91c2Vtb3ZlQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5tb3VzZW1vdmUpIHtcclxuICAgICAgICAgICAgaG9va3MubW91c2Vtb3ZlKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtb3VzZW1vdmVDYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLm1vdXNlSW50ZXJhY3Rpb25DYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLm1vdXNlSW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgaG9va3MubW91c2VJbnRlcmFjdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uc2Nyb2xsQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5zY3JvbGwpIHtcclxuICAgICAgICAgICAgaG9va3Muc2Nyb2xsKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzY3JvbGxDYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLnZpZXdwb3J0UmVzaXplQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy52aWV3cG9ydFJlc2l6ZSkge1xyXG4gICAgICAgICAgICBob29rcy52aWV3cG9ydFJlc2l6ZSguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmlld3BvcnRSZXNpemVDYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLmlucHV0Q2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5pbnB1dCkge1xyXG4gICAgICAgICAgICBob29rcy5pbnB1dCguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXRDYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLm1lZGlhSW50ZXJhY3Rpb25DYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLm1lZGlhSW50ZWFjdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5tZWRpYUludGVhY3Rpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLnN0eWxlU2hlZXRSdWxlQ2IgPSAoLi4ucCkgPT4ge1xyXG4gICAgICAgIGlmIChob29rcy5zdHlsZVNoZWV0UnVsZSkge1xyXG4gICAgICAgICAgICBob29rcy5zdHlsZVNoZWV0UnVsZSguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGVTaGVldFJ1bGVDYiguLi5wKTtcclxuICAgIH07XHJcbiAgICBvLnN0eWxlRGVjbGFyYXRpb25DYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLnN0eWxlRGVjbGFyYXRpb24pIHtcclxuICAgICAgICAgICAgaG9va3Muc3R5bGVEZWNsYXJhdGlvbiguLi5wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGVEZWNsYXJhdGlvbkNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uY2FudmFzTXV0YXRpb25DYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLmNhbnZhc011dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGhvb2tzLmNhbnZhc011dGF0aW9uKC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYW52YXNNdXRhdGlvbkNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uZm9udENiID0gKC4uLnApID0+IHtcclxuICAgICAgICBpZiAoaG9va3MuZm9udCkge1xyXG4gICAgICAgICAgICBob29rcy5mb250KC4uLnApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb250Q2IoLi4ucCk7XHJcbiAgICB9O1xyXG4gICAgby5zZWxlY3Rpb25DYiA9ICguLi5wKSA9PiB7XHJcbiAgICAgICAgaWYgKGhvb2tzLnNlbGVjdGlvbikge1xyXG4gICAgICAgICAgICBob29rcy5zZWxlY3Rpb24oLi4ucCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbGVjdGlvbkNiKC4uLnApO1xyXG4gICAgfTtcclxuICAgIG8uY3VzdG9tRWxlbWVudENiID0gKC4uLmMpID0+IHtcclxuICAgICAgICBpZiAoaG9va3MuY3VzdG9tRWxlbWVudCkge1xyXG4gICAgICAgICAgICBob29rcy5jdXN0b21FbGVtZW50KC4uLmMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdXN0b21FbGVtZW50Q2IoLi4uYyk7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGluaXRPYnNlcnZlcnMobywgaG9va3MgPSB7fSkge1xyXG4gICAgY29uc3QgY3VycmVudFdpbmRvdyA9IG8uZG9jLmRlZmF1bHRWaWV3O1xyXG4gICAgaWYgKCFjdXJyZW50V2luZG93KSB7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgbWVyZ2VIb29rcyhvLCBob29rcyk7XHJcbiAgICBsZXQgbXV0YXRpb25PYnNlcnZlcjtcclxuICAgIGlmIChvLnJlY29yZERPTSkge1xyXG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIgPSBpbml0TXV0YXRpb25PYnNlcnZlcihvLCBvLmRvYyk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtb3VzZW1vdmVIYW5kbGVyID0gaW5pdE1vdmVPYnNlcnZlcihvKTtcclxuICAgIGNvbnN0IG1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyID0gaW5pdE1vdXNlSW50ZXJhY3Rpb25PYnNlcnZlcihvKTtcclxuICAgIGNvbnN0IHNjcm9sbEhhbmRsZXIgPSBpbml0U2Nyb2xsT2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCB2aWV3cG9ydFJlc2l6ZUhhbmRsZXIgPSBpbml0Vmlld3BvcnRSZXNpemVPYnNlcnZlcihvLCB7XHJcbiAgICAgICAgd2luOiBjdXJyZW50V2luZG93LFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBpbnB1dEhhbmRsZXIgPSBpbml0SW5wdXRPYnNlcnZlcihvKTtcclxuICAgIGNvbnN0IG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyID0gaW5pdE1lZGlhSW50ZXJhY3Rpb25PYnNlcnZlcihvKTtcclxuICAgIGxldCBzdHlsZVNoZWV0T2JzZXJ2ZXIgPSAoKSA9PiB7IH07XHJcbiAgICBsZXQgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlciA9ICgpID0+IHsgfTtcclxuICAgIGxldCBzdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7IH07XHJcbiAgICBsZXQgZm9udE9ic2VydmVyID0gKCkgPT4geyB9O1xyXG4gICAgaWYgKG8ucmVjb3JkRE9NKSB7XHJcbiAgICAgICAgc3R5bGVTaGVldE9ic2VydmVyID0gaW5pdFN0eWxlU2hlZXRPYnNlcnZlcihvLCB7IHdpbjogY3VycmVudFdpbmRvdyB9KTtcclxuICAgICAgICBhZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyID0gaW5pdEFkb3B0ZWRTdHlsZVNoZWV0T2JzZXJ2ZXIobywgby5kb2MpO1xyXG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlciA9IGluaXRTdHlsZURlY2xhcmF0aW9uT2JzZXJ2ZXIobywge1xyXG4gICAgICAgICAgICB3aW46IGN1cnJlbnRXaW5kb3csXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG8uY29sbGVjdEZvbnRzKSB7XHJcbiAgICAgICAgICAgIGZvbnRPYnNlcnZlciA9IGluaXRGb250T2JzZXJ2ZXIobyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VsZWN0aW9uT2JzZXJ2ZXIgPSBpbml0U2VsZWN0aW9uT2JzZXJ2ZXIobyk7XHJcbiAgICBjb25zdCBjdXN0b21FbGVtZW50T2JzZXJ2ZXIgPSBpbml0Q3VzdG9tRWxlbWVudE9ic2VydmVyKG8pO1xyXG4gICAgY29uc3QgcGx1Z2luSGFuZGxlcnMgPSBbXTtcclxuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIG8ucGx1Z2lucykge1xyXG4gICAgICAgIHBsdWdpbkhhbmRsZXJzLnB1c2gocGx1Z2luLm9ic2VydmVyKHBsdWdpbi5jYWxsYmFjaywgY3VycmVudFdpbmRvdywgcGx1Z2luLm9wdGlvbnMpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjYWxsYmFja1dyYXBwZXIoKCkgPT4ge1xyXG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChiKSA9PiBiLnJlc2V0KCkpO1xyXG4gICAgICAgIG11dGF0aW9uT2JzZXJ2ZXIgPT09IG51bGwgfHwgbXV0YXRpb25PYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgbW91c2Vtb3ZlSGFuZGxlcigpO1xyXG4gICAgICAgIG1vdXNlSW50ZXJhY3Rpb25IYW5kbGVyKCk7XHJcbiAgICAgICAgc2Nyb2xsSGFuZGxlcigpO1xyXG4gICAgICAgIHZpZXdwb3J0UmVzaXplSGFuZGxlcigpO1xyXG4gICAgICAgIGlucHV0SGFuZGxlcigpO1xyXG4gICAgICAgIG1lZGlhSW50ZXJhY3Rpb25IYW5kbGVyKCk7XHJcbiAgICAgICAgc3R5bGVTaGVldE9ic2VydmVyKCk7XHJcbiAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXRPYnNlcnZlcigpO1xyXG4gICAgICAgIHN0eWxlRGVjbGFyYXRpb25PYnNlcnZlcigpO1xyXG4gICAgICAgIGZvbnRPYnNlcnZlcigpO1xyXG4gICAgICAgIHNlbGVjdGlvbk9ic2VydmVyKCk7XHJcbiAgICAgICAgY3VzdG9tRWxlbWVudE9ic2VydmVyKCk7XHJcbiAgICAgICAgcGx1Z2luSGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGhhc05lc3RlZENTU1J1bGUocHJvcCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3dbcHJvcF0gIT09ICd1bmRlZmluZWQnO1xyXG59XHJcbmZ1bmN0aW9uIGNhbk1vbmtleVBhdGNoTmVzdGVkQ1NTUnVsZShwcm9wKSB7XHJcbiAgICByZXR1cm4gQm9vbGVhbih0eXBlb2Ygd2luZG93W3Byb3BdICE9PSAndW5kZWZpbmVkJyAmJlxyXG4gICAgICAgIHdpbmRvd1twcm9wXS5wcm90b3R5cGUgJiZcclxuICAgICAgICAnaW5zZXJ0UnVsZScgaW4gd2luZG93W3Byb3BdLnByb3RvdHlwZSAmJlxyXG4gICAgICAgICdkZWxldGVSdWxlJyBpbiB3aW5kb3dbcHJvcF0ucHJvdG90eXBlKTtcclxufVxuXG5jbGFzcyBDcm9zc09yaWdpbklmcmFtZU1pcnJvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZW5lcmF0ZUlkRm4pIHtcclxuICAgICAgICB0aGlzLmdlbmVyYXRlSWRGbiA9IGdlbmVyYXRlSWRGbjtcclxuICAgICAgICB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0SWQoaWZyYW1lLCByZW1vdGVJZCwgaWRUb1JlbW90ZU1hcCwgcmVtb3RlVG9JZE1hcCkge1xyXG4gICAgICAgIGNvbnN0IGlkVG9SZW1vdGVJZE1hcCA9IGlkVG9SZW1vdGVNYXAgfHwgdGhpcy5nZXRJZFRvUmVtb3RlSWRNYXAoaWZyYW1lKTtcclxuICAgICAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSByZW1vdGVUb0lkTWFwIHx8IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgbGV0IGlkID0gaWRUb1JlbW90ZUlkTWFwLmdldChyZW1vdGVJZCk7XHJcbiAgICAgICAgaWYgKCFpZCkge1xyXG4gICAgICAgICAgICBpZCA9IHRoaXMuZ2VuZXJhdGVJZEZuKCk7XHJcbiAgICAgICAgICAgIGlkVG9SZW1vdGVJZE1hcC5zZXQocmVtb3RlSWQsIGlkKTtcclxuICAgICAgICAgICAgcmVtb3RlSWRUb0lkTWFwLnNldChpZCwgcmVtb3RlSWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaWQ7XHJcbiAgICB9XHJcbiAgICBnZXRJZHMoaWZyYW1lLCByZW1vdGVJZCkge1xyXG4gICAgICAgIGNvbnN0IGlkVG9SZW1vdGVJZE1hcCA9IHRoaXMuZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gdGhpcy5nZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlSWQubWFwKChpZCkgPT4gdGhpcy5nZXRJZChpZnJhbWUsIGlkLCBpZFRvUmVtb3RlSWRNYXAsIHJlbW90ZUlkVG9JZE1hcCkpO1xyXG4gICAgfVxyXG4gICAgZ2V0UmVtb3RlSWQoaWZyYW1lLCBpZCwgbWFwKSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3RlSWRUb0lkTWFwID0gbWFwIHx8IHRoaXMuZ2V0UmVtb3RlSWRUb0lkTWFwKGlmcmFtZSk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBpZCAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgIHJldHVybiBpZDtcclxuICAgICAgICBjb25zdCByZW1vdGVJZCA9IHJlbW90ZUlkVG9JZE1hcC5nZXQoaWQpO1xyXG4gICAgICAgIGlmICghcmVtb3RlSWQpXHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICByZXR1cm4gcmVtb3RlSWQ7XHJcbiAgICB9XHJcbiAgICBnZXRSZW1vdGVJZHMoaWZyYW1lLCBpZHMpIHtcclxuICAgICAgICBjb25zdCByZW1vdGVJZFRvSWRNYXAgPSB0aGlzLmdldFJlbW90ZUlkVG9JZE1hcChpZnJhbWUpO1xyXG4gICAgICAgIHJldHVybiBpZHMubWFwKChpZCkgPT4gdGhpcy5nZXRSZW1vdGVJZChpZnJhbWUsIGlkLCByZW1vdGVJZFRvSWRNYXApKTtcclxuICAgIH1cclxuICAgIHJlc2V0KGlmcmFtZSkge1xyXG4gICAgICAgIGlmICghaWZyYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwID0gbmV3IFdlYWtNYXAoKTtcclxuICAgICAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLmRlbGV0ZShpZnJhbWUpO1xyXG4gICAgICAgIHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLmRlbGV0ZShpZnJhbWUpO1xyXG4gICAgfVxyXG4gICAgZ2V0SWRUb1JlbW90ZUlkTWFwKGlmcmFtZSkge1xyXG4gICAgICAgIGxldCBpZFRvUmVtb3RlSWRNYXAgPSB0aGlzLmlmcmFtZUlkVG9SZW1vdGVJZE1hcC5nZXQoaWZyYW1lKTtcclxuICAgICAgICBpZiAoIWlkVG9SZW1vdGVJZE1hcCkge1xyXG4gICAgICAgICAgICBpZFRvUmVtb3RlSWRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaWZyYW1lSWRUb1JlbW90ZUlkTWFwLnNldChpZnJhbWUsIGlkVG9SZW1vdGVJZE1hcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpZFRvUmVtb3RlSWRNYXA7XHJcbiAgICB9XHJcbiAgICBnZXRSZW1vdGVJZFRvSWRNYXAoaWZyYW1lKSB7XHJcbiAgICAgICAgbGV0IHJlbW90ZUlkVG9JZE1hcCA9IHRoaXMuaWZyYW1lUmVtb3RlSWRUb0lkTWFwLmdldChpZnJhbWUpO1xyXG4gICAgICAgIGlmICghcmVtb3RlSWRUb0lkTWFwKSB7XHJcbiAgICAgICAgICAgIHJlbW90ZUlkVG9JZE1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICAgICAgdGhpcy5pZnJhbWVSZW1vdGVJZFRvSWRNYXAuc2V0KGlmcmFtZSwgcmVtb3RlSWRUb0lkTWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbW90ZUlkVG9JZE1hcDtcclxuICAgIH1cclxufVxuXG5jbGFzcyBJZnJhbWVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlmcmFtZXMgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IgPSBuZXcgQ3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IoZ2VuSWQpO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcclxuICAgICAgICB0aGlzLndyYXBwZWRFbWl0ID0gb3B0aW9ucy53cmFwcGVkRW1pdDtcclxuICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyID0gb3B0aW9ucy5zdHlsZXNoZWV0TWFuYWdlcjtcclxuICAgICAgICB0aGlzLnJlY29yZENyb3NzT3JpZ2luSWZyYW1lcyA9IG9wdGlvbnMucmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzO1xyXG4gICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVTdHlsZU1pcnJvciA9IG5ldyBDcm9zc09yaWdpbklmcmFtZU1pcnJvcih0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yLmdlbmVyYXRlSWQuYmluZCh0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLnN0eWxlTWlycm9yKSk7XHJcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcclxuICAgICAgICBpZiAodGhpcy5yZWNvcmRDcm9zc09yaWdpbklmcmFtZXMpIHtcclxuICAgICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkSWZyYW1lKGlmcmFtZUVsKSB7XHJcbiAgICAgICAgdGhpcy5pZnJhbWVzLnNldChpZnJhbWVFbCwgdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGlmcmFtZUVsLmNvbnRlbnRXaW5kb3cpXHJcbiAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuc2V0KGlmcmFtZUVsLmNvbnRlbnRXaW5kb3csIGlmcmFtZUVsKTtcclxuICAgIH1cclxuICAgIGFkZExvYWRMaXN0ZW5lcihjYikge1xyXG4gICAgICAgIHRoaXMubG9hZExpc3RlbmVyID0gY2I7XHJcbiAgICB9XHJcbiAgICBhdHRhY2hJZnJhbWUoaWZyYW1lRWwsIGNoaWxkU24pIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkNiKHtcclxuICAgICAgICAgICAgYWRkczogW1xyXG4gICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiB0aGlzLm1pcnJvci5nZXRJZChpZnJhbWVFbCksXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dElkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkU24sXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICByZW1vdmVzOiBbXSxcclxuICAgICAgICAgICAgdGV4dHM6IFtdLFxyXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcclxuICAgICAgICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgKF9hID0gdGhpcy5sb2FkTGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGlmcmFtZUVsKTtcclxuICAgICAgICBpZiAoaWZyYW1lRWwuY29udGVudERvY3VtZW50ICYmXHJcbiAgICAgICAgICAgIGlmcmFtZUVsLmNvbnRlbnREb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMgJiZcclxuICAgICAgICAgICAgaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICB0aGlzLnN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoaWZyYW1lRWwuY29udGVudERvY3VtZW50LmFkb3B0ZWRTdHlsZVNoZWV0cywgdGhpcy5taXJyb3IuZ2V0SWQoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSk7XHJcbiAgICB9XHJcbiAgICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcclxuICAgICAgICBjb25zdCBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudCA9IG1lc3NhZ2U7XHJcbiAgICAgICAgaWYgKGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEudHlwZSAhPT0gJ3Jyd2ViJyB8fFxyXG4gICAgICAgICAgICBjcm9zc09yaWdpbk1lc3NhZ2VFdmVudC5vcmlnaW4gIT09IGNyb3NzT3JpZ2luTWVzc2FnZUV2ZW50LmRhdGEub3JpZ2luKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgaWZyYW1lU291cmNlV2luZG93ID0gbWVzc2FnZS5zb3VyY2U7XHJcbiAgICAgICAgaWYgKCFpZnJhbWVTb3VyY2VXaW5kb3cpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBpZnJhbWVFbCA9IHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNYXAuZ2V0KG1lc3NhZ2Uuc291cmNlKTtcclxuICAgICAgICBpZiAoIWlmcmFtZUVsKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRFdmVudCA9IHRoaXMudHJhbnNmb3JtQ3Jvc3NPcmlnaW5FdmVudChpZnJhbWVFbCwgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5ldmVudCk7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkRXZlbnQpXHJcbiAgICAgICAgICAgIHRoaXMud3JhcHBlZEVtaXQodHJhbnNmb3JtZWRFdmVudCwgY3Jvc3NPcmlnaW5NZXNzYWdlRXZlbnQuZGF0YS5pc0NoZWNrb3V0KTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybUNyb3NzT3JpZ2luRXZlbnQoaWZyYW1lRWwsIGUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3dpdGNoIChlLnR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5GdWxsU25hcHNob3Q6IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IucmVzZXQoaWZyYW1lRWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLnJlc2V0KGlmcmFtZUVsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkT25Ob2RlKGUuZGF0YS5ub2RlLCBpZnJhbWVFbCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb290SWQgPSBlLmRhdGEubm9kZS5pZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXAuc2V0KGlmcmFtZUVsLCByb290SWQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRjaFJvb3RJZE9uTm9kZShlLmRhdGEubm9kZSwgcm9vdElkKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiBlLnRpbWVzdGFtcCxcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IHRoaXMubWlycm9yLmdldElkKGlmcmFtZUVsKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0SWQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogZS5kYXRhLm5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHM6IFtdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBbXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBdHRhY2hJZnJhbWU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBFdmVudFR5cGUkMS5NZXRhOlxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkxvYWQ6XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuRG9tQ29udGVudExvYWRlZDoge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuUGx1Z2luOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEV2ZW50VHlwZSQxLkN1c3RvbToge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKGUuZGF0YS5wYXlsb2FkLCBpZnJhbWVFbCwgWydpZCcsICdwYXJlbnRJZCcsICdwcmV2aW91c0lkJywgJ25leHRJZCddKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdDoge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmRhdGEuc291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLk11dGF0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5hZGRzLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuLCBpZnJhbWVFbCwgW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwYXJlbnRJZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ25leHRJZCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByZXZpb3VzSWQnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZE9uTm9kZShuLm5vZGUsIGlmcmFtZUVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvb3RJZCA9IHRoaXMuY3Jvc3NPcmlnaW5JZnJhbWVSb290SWRNYXAuZ2V0KGlmcmFtZUVsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RJZCAmJiB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKG4ubm9kZSwgcm9vdElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5yZW1vdmVzLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuLCBpZnJhbWVFbCwgWydwYXJlbnRJZCcsICdpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5hdHRyaWJ1dGVzLmZvckVhY2goKG4pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhuLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS50ZXh0cy5mb3JFYWNoKChuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMobiwgaWZyYW1lRWwsIFsnaWQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLkRyYWc6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLlRvdWNoTW92ZTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuTW91c2VNb3ZlOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZGF0YS5wb3NpdGlvbnMuZm9yRWFjaCgocCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKHAsIGlmcmFtZUVsLCBbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5WaWV3cG9ydFJlc2l6ZToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5NZWRpYUludGVyYWN0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5Nb3VzZUludGVyYWN0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5TY3JvbGw6XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLkNhbnZhc011dGF0aW9uOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5JbnB1dDoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5TdHlsZVNoZWV0UnVsZTpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIEluY3JlbWVudGFsU291cmNlJDEuU3R5bGVEZWNsYXJhdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydpZCddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlU3R5bGVJZHMoZS5kYXRhLCBpZnJhbWVFbCwgWydzdHlsZUlkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLkZvbnQ6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgSW5jcmVtZW50YWxTb3VyY2UkMS5TZWxlY3Rpb246IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5kYXRhLnJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRzKHJhbmdlLCBpZnJhbWVFbCwgWydzdGFydCcsICdlbmQnXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBJbmNyZW1lbnRhbFNvdXJjZSQxLkFkb3B0ZWRTdHlsZVNoZWV0OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZUlkcyhlLmRhdGEsIGlmcmFtZUVsLCBbJ2lkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcGxhY2VTdHlsZUlkcyhlLmRhdGEsIGlmcmFtZUVsLCBbJ3N0eWxlSWRzJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBlLmRhdGEuc3R5bGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoc3R5bGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwbGFjZVN0eWxlSWRzKHN0eWxlLCBpZnJhbWVFbCwgWydzdHlsZUlkJ10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJlcGxhY2UoaWZyYW1lTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xyXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW2tleV0pICYmIHR5cGVvZiBvYmpba2V5XSAhPT0gJ251bWJlcicpXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IGlmcmFtZU1pcnJvci5nZXRJZHMoaWZyYW1lRWwsIG9ialtrZXldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9ialtrZXldID0gaWZyYW1lTWlycm9yLmdldElkKGlmcmFtZUVsLCBvYmpba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH1cclxuICAgIHJlcGxhY2VJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZU1pcnJvciwgb2JqLCBpZnJhbWVFbCwga2V5cyk7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlU3R5bGVJZHMob2JqLCBpZnJhbWVFbCwga2V5cykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5jcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yLCBvYmosIGlmcmFtZUVsLCBrZXlzKTtcclxuICAgIH1cclxuICAgIHJlcGxhY2VJZE9uTm9kZShub2RlLCBpZnJhbWVFbCkge1xyXG4gICAgICAgIHRoaXMucmVwbGFjZUlkcyhub2RlLCBpZnJhbWVFbCwgWydpZCcsICdyb290SWQnXSk7XHJcbiAgICAgICAgaWYgKCdjaGlsZE5vZGVzJyBpbiBub2RlKSB7XHJcbiAgICAgICAgICAgIG5vZGUuY2hpbGROb2Rlcy5mb3JFYWNoKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZXBsYWNlSWRPbk5vZGUoY2hpbGQsIGlmcmFtZUVsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcGF0Y2hSb290SWRPbk5vZGUobm9kZSwgcm9vdElkKSB7XHJcbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gTm9kZVR5cGUuRG9jdW1lbnQgJiYgIW5vZGUucm9vdElkKVxyXG4gICAgICAgICAgICBub2RlLnJvb3RJZCA9IHJvb3RJZDtcclxuICAgICAgICBpZiAoJ2NoaWxkTm9kZXMnIGluIG5vZGUpIHtcclxuICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzLmZvckVhY2goKGNoaWxkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGNoUm9vdElkT25Ob2RlKGNoaWxkLCByb290SWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuY2xhc3MgU2hhZG93RG9tTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5zaGFkb3dEb21zID0gbmV3IFdlYWtTZXQoKTtcclxuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcclxuICAgICAgICB0aGlzLnNjcm9sbENiID0gb3B0aW9ucy5zY3JvbGxDYjtcclxuICAgICAgICB0aGlzLmJ5cGFzc09wdGlvbnMgPSBvcHRpb25zLmJ5cGFzc09wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5taXJyb3IgPSBvcHRpb25zLm1pcnJvcjtcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMucGF0Y2hBdHRhY2hTaGFkb3coRWxlbWVudCwgZG9jdW1lbnQpO1xyXG4gICAgfVxyXG4gICAgYWRkU2hhZG93Um9vdChzaGFkb3dSb290LCBkb2MpIHtcclxuICAgICAgICBpZiAoIWlzTmF0aXZlU2hhZG93RG9tKHNoYWRvd1Jvb3QpKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93RG9tcy5oYXMoc2hhZG93Um9vdCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLnNoYWRvd0RvbXMuYWRkKHNoYWRvd1Jvb3QpO1xyXG4gICAgICAgIGNvbnN0IG9ic2VydmVyID0gaW5pdE11dGF0aW9uT2JzZXJ2ZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJ5cGFzc09wdGlvbnMpLCB7IGRvYywgbXV0YXRpb25DYjogdGhpcy5tdXRhdGlvbkNiLCBtaXJyb3I6IHRoaXMubWlycm9yLCBzaGFkb3dEb21NYW5hZ2VyOiB0aGlzIH0pLCBzaGFkb3dSb290KTtcclxuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKCgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKSk7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMucHVzaChpbml0U2Nyb2xsT2JzZXJ2ZXIoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmJ5cGFzc09wdGlvbnMpLCB7IHNjcm9sbENiOiB0aGlzLnNjcm9sbENiLCBkb2M6IHNoYWRvd1Jvb3QsIG1pcnJvcjogdGhpcy5taXJyb3IgfSkpKTtcclxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzICYmXHJcbiAgICAgICAgICAgICAgICBzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMsIHRoaXMubWlycm9yLmdldElkKHNoYWRvd1Jvb3QuaG9zdCkpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKGluaXRBZG9wdGVkU3R5bGVTaGVldE9ic2VydmVyKHtcclxuICAgICAgICAgICAgICAgIG1pcnJvcjogdGhpcy5taXJyb3IsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogdGhpcy5ieXBhc3NPcHRpb25zLnN0eWxlc2hlZXRNYW5hZ2VyLFxyXG4gICAgICAgICAgICB9LCBzaGFkb3dSb290KSk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICB9XHJcbiAgICBvYnNlcnZlQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoIWlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdyB8fCAhaWZyYW1lRWxlbWVudC5jb250ZW50RG9jdW1lbnQpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLnBhdGNoQXR0YWNoU2hhZG93KGlmcmFtZUVsZW1lbnQuY29udGVudFdpbmRvdy5FbGVtZW50LCBpZnJhbWVFbGVtZW50LmNvbnRlbnREb2N1bWVudCk7XHJcbiAgICB9XHJcbiAgICBwYXRjaEF0dGFjaFNoYWRvdyhlbGVtZW50LCBkb2MpIHtcclxuICAgICAgICBjb25zdCBtYW5hZ2VyID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycy5wdXNoKHBhdGNoKGVsZW1lbnQucHJvdG90eXBlLCAnYXR0YWNoU2hhZG93JywgZnVuY3Rpb24gKG9yaWdpbmFsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAob3B0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaGFkb3dSb290ID0gb3JpZ2luYWwuY2FsbCh0aGlzLCBvcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2hhZG93Um9vdCAmJiBpbkRvbSh0aGlzKSlcclxuICAgICAgICAgICAgICAgICAgICBtYW5hZ2VyLmFkZFNoYWRvd1Jvb3QodGhpcy5zaGFkb3dSb290LCBkb2MpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSkpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5yZXN0b3JlSGFuZGxlcnMuZm9yRWFjaCgoaGFuZGxlcikgPT4ge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnJlc3RvcmVIYW5kbGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc2hhZG93RG9tcyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICB9XHJcbn1cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG4vKlxuICogYmFzZTY0LWFycmF5YnVmZmVyIDEuMC4xIDxodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyPlxuICogQ29weXJpZ2h0IChjKSAyMDIxIE5pa2xhcyB2b24gSGVydHplbiA8aHR0cHM6Ly9oZXJ0emVuLmNvbT5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBMaWNlbnNlXG4gKi9cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcbi8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbnZhciBsb29rdXAgPSB0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBbXSA6IG5ldyBVaW50OEFycmF5KDI1Nik7XG5mb3IgKHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbn1cbnZhciBlbmNvZGUgPSBmdW5jdGlvbiAoYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAzKSB7XG4gICAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG4gICAgaWYgKGxlbiAlIDMgPT09IDIpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyAnPSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyAnPT0nO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTY0O1xufTtcblxuY29uc3QgY2FudmFzVmFyTWFwID0gbmV3IE1hcCgpO1xyXG5mdW5jdGlvbiB2YXJpYWJsZUxpc3RGb3IoY3R4LCBjdG9yKSB7XHJcbiAgICBsZXQgY29udGV4dE1hcCA9IGNhbnZhc1Zhck1hcC5nZXQoY3R4KTtcclxuICAgIGlmICghY29udGV4dE1hcCkge1xyXG4gICAgICAgIGNvbnRleHRNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgY2FudmFzVmFyTWFwLnNldChjdHgsIGNvbnRleHRNYXApO1xyXG4gICAgfVxyXG4gICAgaWYgKCFjb250ZXh0TWFwLmhhcyhjdG9yKSkge1xyXG4gICAgICAgIGNvbnRleHRNYXAuc2V0KGN0b3IsIFtdKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZXh0TWFwLmdldChjdG9yKTtcclxufVxyXG5jb25zdCBzYXZlV2ViR0xWYXIgPSAodmFsdWUsIHdpbiwgY3R4KSA9PiB7XHJcbiAgICBpZiAoIXZhbHVlIHx8XHJcbiAgICAgICAgIShpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCh2YWx1ZSwgd2luKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSlcclxuICAgICAgICByZXR1cm47XHJcbiAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgIGNvbnN0IGxpc3QgPSB2YXJpYWJsZUxpc3RGb3IoY3R4LCBuYW1lKTtcclxuICAgIGxldCBpbmRleCA9IGxpc3QuaW5kZXhPZih2YWx1ZSk7XHJcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgaW5kZXggPSBsaXN0Lmxlbmd0aDtcclxuICAgICAgICBsaXN0LnB1c2godmFsdWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG59O1xyXG5mdW5jdGlvbiBzZXJpYWxpemVBcmcodmFsdWUsIHdpbiwgY3R4KSB7XHJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKGFyZykgPT4gc2VyaWFsaXplQXJnKGFyZywgd2luLCBjdHgpKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxyXG4gICAgICAgIHZhbHVlIGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XHJcbiAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcclxuICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgYXJnczogW09iamVjdC52YWx1ZXModmFsdWUpXSxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgYmFzZTY0LFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGFWaWV3KSB7XHJcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgcnJfdHlwZTogbmFtZSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplQXJnKHZhbHVlLmJ1ZmZlciwgd2luLCBjdHgpLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUuYnl0ZU9mZnNldCxcclxuICAgICAgICAgICAgICAgIHZhbHVlLmJ5dGVMZW5ndGgsXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xyXG4gICAgICAgIGNvbnN0IHsgc3JjIH0gPSB2YWx1ZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBzcmMsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gJ0hUTUxJbWFnZUVsZW1lbnQnO1xyXG4gICAgICAgIGNvbnN0IHNyYyA9IHZhbHVlLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIHNyYyxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBycl90eXBlOiBuYW1lLFxyXG4gICAgICAgICAgICBhcmdzOiBbc2VyaWFsaXplQXJnKHZhbHVlLmRhdGEsIHdpbiwgY3R4KSwgdmFsdWUud2lkdGgsIHZhbHVlLmhlaWdodF0sXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzSW5zdGFuY2VPZldlYkdMT2JqZWN0KHZhbHVlLCB3aW4pIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICBjb25zdCBuYW1lID0gdmFsdWUuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHNhdmVXZWJHTFZhcih2YWx1ZSwgd2luLCBjdHgpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJyX3R5cGU6IG5hbWUsXHJcbiAgICAgICAgICAgIGluZGV4OiBpbmRleCxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbmNvbnN0IHNlcmlhbGl6ZUFyZ3MgPSAoYXJncywgd2luLCBjdHgpID0+IHtcclxuICAgIHJldHVybiBhcmdzLm1hcCgoYXJnKSA9PiBzZXJpYWxpemVBcmcoYXJnLCB3aW4sIGN0eCkpO1xyXG59O1xyXG5jb25zdCBpc0luc3RhbmNlT2ZXZWJHTE9iamVjdCA9ICh2YWx1ZSwgd2luKSA9PiB7XHJcbiAgICBjb25zdCB3ZWJHTENvbnN0cnVjdG9yTmFtZXMgPSBbXHJcbiAgICAgICAgJ1dlYkdMQWN0aXZlSW5mbycsXHJcbiAgICAgICAgJ1dlYkdMQnVmZmVyJyxcclxuICAgICAgICAnV2ViR0xGcmFtZWJ1ZmZlcicsXHJcbiAgICAgICAgJ1dlYkdMUHJvZ3JhbScsXHJcbiAgICAgICAgJ1dlYkdMUmVuZGVyYnVmZmVyJyxcclxuICAgICAgICAnV2ViR0xTaGFkZXInLFxyXG4gICAgICAgICdXZWJHTFNoYWRlclByZWNpc2lvbkZvcm1hdCcsXHJcbiAgICAgICAgJ1dlYkdMVGV4dHVyZScsXHJcbiAgICAgICAgJ1dlYkdMVW5pZm9ybUxvY2F0aW9uJyxcclxuICAgICAgICAnV2ViR0xWZXJ0ZXhBcnJheU9iamVjdCcsXHJcbiAgICAgICAgJ1dlYkdMVmVydGV4QXJyYXlPYmplY3RPRVMnLFxyXG4gICAgXTtcclxuICAgIGNvbnN0IHN1cHBvcnRlZFdlYkdMQ29uc3RydWN0b3JOYW1lcyA9IHdlYkdMQ29uc3RydWN0b3JOYW1lcy5maWx0ZXIoKG5hbWUpID0+IHR5cGVvZiB3aW5bbmFtZV0gPT09ICdmdW5jdGlvbicpO1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oc3VwcG9ydGVkV2ViR0xDb25zdHJ1Y3Rvck5hbWVzLmZpbmQoKG5hbWUpID0+IHZhbHVlIGluc3RhbmNlb2Ygd2luW25hbWVdKSk7XHJcbn07XG5cbmZ1bmN0aW9uIGluaXRDYW52YXMyRE11dGF0aW9uT2JzZXJ2ZXIoY2IsIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcikge1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgIGNvbnN0IHByb3BzMkQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW4uQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJELnByb3RvdHlwZSk7XHJcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMyRCkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGVbcHJvcF0gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2god2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUsIHByb3AsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkQXJncyA9IHNlcmlhbGl6ZUFyZ3MoYXJncywgd2luLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKHRoaXMuY2FudmFzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFsnMkQnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogcHJvcCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiByZWNvcmRBcmdzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChyZXN0b3JlSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICBjb25zdCBob29rSGFuZGxlciA9IGhvb2tTZXR0ZXIod2luLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRC5wcm90b3R5cGUsIHByb3AsIHtcclxuICAgICAgICAgICAgICAgIHNldCh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogQ2FudmFzQ29udGV4dFsnMkQnXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt2XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goaG9va0hhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lKGNvbnRleHRUeXBlKSB7XHJcbiAgICByZXR1cm4gY29udGV4dFR5cGUgPT09ICdleHBlcmltZW50YWwtd2ViZ2wnID8gJ3dlYmdsJyA6IGNvbnRleHRUeXBlO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRDYW52YXNDb250ZXh0T2JzZXJ2ZXIod2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCBzZXRQcmVzZXJ2ZURyYXdpbmdCdWZmZXJUb1RydWUpIHtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IHJlc3RvcmVIYW5kbGVyID0gcGF0Y2god2luLkhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZSwgJ2dldENvbnRleHQnLCBmdW5jdGlvbiAob3JpZ2luYWwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0VHlwZSwgLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0Jsb2NrZWQodGhpcywgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdHhOYW1lID0gZ2V0Tm9ybWFsaXplZENvbnRleHROYW1lKGNvbnRleHRUeXBlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISgnX19jb250ZXh0JyBpbiB0aGlzKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fX2NvbnRleHQgPSBjdHhOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXRQcmVzZXJ2ZURyYXdpbmdCdWZmZXJUb1RydWUgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgWyd3ZWJnbCcsICd3ZWJnbDInXS5pbmNsdWRlcyhjdHhOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1swXSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRleHRBdHRyaWJ1dGVzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGV4dEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dEF0dHJpYnV0ZXMucHJlc2VydmVEcmF3aW5nQnVmZmVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3Muc3BsaWNlKDAsIDEsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbC5hcHBseSh0aGlzLCBbY29udGV4dFR5cGUsIC4uLmFyZ3NdKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBwYXRjaCBIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUuZ2V0Q29udGV4dCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICBoYW5kbGVycy5mb3JFYWNoKChoKSA9PiBoKCkpO1xyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBwYXRjaEdMUHJvdG90eXBlKHByb3RvdHlwZSwgdHlwZSwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG1pcnJvciwgd2luKSB7XHJcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xyXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGUpO1xyXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzKSB7XHJcbiAgICAgICAgaWYgKFtcclxuICAgICAgICAgICAgJ2lzQ29udGV4dExvc3QnLFxyXG4gICAgICAgICAgICAnY2FudmFzJyxcclxuICAgICAgICAgICAgJ2RyYXdpbmdCdWZmZXJXaWR0aCcsXHJcbiAgICAgICAgICAgICdkcmF3aW5nQnVmZmVySGVpZ2h0JyxcclxuICAgICAgICBdLmluY2x1ZGVzKHByb3ApKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZVtwcm9wXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgcmVzdG9yZUhhbmRsZXIgPSBwYXRjaChwcm90b3R5cGUsIHByb3AsIGZ1bmN0aW9uIChvcmlnaW5hbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F2ZVdlYkdMVmFyKHJlc3VsdCwgd2luLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3RhZ05hbWUnIGluIHRoaXMuY2FudmFzICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFpc0Jsb2NrZWQodGhpcy5jYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZEFyZ3MgPSBzZXJpYWxpemVBcmdzKGFyZ3MsIHdpbiwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBwcm9wLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogcmVjb3JkQXJncyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIG11dGF0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKHJlc3RvcmVIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhvb2tIYW5kbGVyID0gaG9va1NldHRlcihwcm90b3R5cGUsIHByb3AsIHtcclxuICAgICAgICAgICAgICAgIHNldCh2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IodGhpcy5jYW52YXMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IHByb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt2XSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGhhbmRsZXJzLnB1c2goaG9va0hhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoYW5kbGVycztcclxufVxyXG5mdW5jdGlvbiBpbml0Q2FudmFzV2ViR0xNdXRhdGlvbk9ic2VydmVyKGNiLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG1pcnJvcikge1xyXG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcclxuICAgIGhhbmRsZXJzLnB1c2goLi4ucGF0Y2hHTFByb3RvdHlwZSh3aW4uV2ViR0xSZW5kZXJpbmdDb250ZXh0LnByb3RvdHlwZSwgQ2FudmFzQ29udGV4dC5XZWJHTCwgY2IsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG1pcnJvciwgd2luKSk7XHJcbiAgICBpZiAodHlwZW9mIHdpbi5XZWJHTDJSZW5kZXJpbmdDb250ZXh0ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGhhbmRsZXJzLnB1c2goLi4ucGF0Y2hHTFByb3RvdHlwZSh3aW4uV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5wcm90b3R5cGUsIENhbnZhc0NvbnRleHQuV2ViR0wyLCBjYiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgbWlycm9yLCB3aW4pKTtcclxuICAgIH1cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gZnVuY1RvU291cmNlKGZuLCBzb3VyY2VtYXBBcmcpIHtcbiAgICB2YXIgc291cmNlbWFwID0gc291cmNlbWFwQXJnID09PSB1bmRlZmluZWQgPyBudWxsIDogc291cmNlbWFwQXJnO1xuICAgIHZhciBzb3VyY2UgPSBmbi50b1N0cmluZygpO1xuICAgIHZhciBsaW5lcyA9IHNvdXJjZS5zcGxpdCgnXFxuJyk7XG4gICAgbGluZXMucG9wKCk7XG4gICAgbGluZXMuc2hpZnQoKTtcbiAgICB2YXIgYmxhbmtQcmVmaXhMZW5ndGggPSBsaW5lc1swXS5zZWFyY2goL1xcUy8pO1xuICAgIHZhciByZWdleCA9IC8oWydcIl0pX193b3JrZXJfbG9hZGVyX3N0cmljdF9fKFsnXCJdKS9nO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGluZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGxpbmVzW2ldID0gbGluZXNbaV0uc3Vic3RyaW5nKGJsYW5rUHJlZml4TGVuZ3RoKS5yZXBsYWNlKHJlZ2V4LCAnJDF1c2Ugc3RyaWN0JDInKSArICdcXG4nO1xuICAgIH1cbiAgICBpZiAoc291cmNlbWFwKSB7XG4gICAgICAgIGxpbmVzLnB1c2goJ1xcL1xcLyMgc291cmNlTWFwcGluZ1VSTD0nICsgc291cmNlbWFwICsgJ1xcbicpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVSTChmbiwgc291cmNlbWFwQXJnKSB7XG4gICAgdmFyIGxpbmVzID0gZnVuY1RvU291cmNlKGZuLCBzb3VyY2VtYXBBcmcpO1xuICAgIHZhciBibG9iID0gbmV3IEJsb2IobGluZXMsIHsgdHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnIH0pO1xuICAgIHJldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbmxpbmVXb3JrZXJGYWN0b3J5KGZuLCBzb3VyY2VtYXBBcmcpIHtcbiAgICB2YXIgdXJsO1xuICAgIHJldHVybiBmdW5jdGlvbiBXb3JrZXJGYWN0b3J5KG9wdGlvbnMpIHtcbiAgICAgICAgdXJsID0gdXJsIHx8IGNyZWF0ZVVSTChmbiwgc291cmNlbWFwQXJnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXIodXJsLCBvcHRpb25zKTtcbiAgICB9O1xufVxuXG52YXIgV29ya2VyRmFjdG9yeSA9IGNyZWF0ZUlubGluZVdvcmtlckZhY3RvcnkoLyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqL2Z1bmN0aW9uICgpIHtcbihmdW5jdGlvbiAoKSB7XG4gICAgJ19fd29ya2VyX2xvYWRlcl9zdHJpY3RfXyc7XG5cbiAgICAvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG4gICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG4gICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG4gICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIGJhc2U2NC1hcnJheWJ1ZmZlciAxLjAuMSA8aHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlcj5cbiAgICAgKiBDb3B5cmlnaHQgKGMpIDIwMjEgTmlrbGFzIHZvbiBIZXJ0emVuIDxodHRwczovL2hlcnR6ZW4uY29tPlxuICAgICAqIFJlbGVhc2VkIHVuZGVyIE1JVCBMaWNlbnNlXG4gICAgICovXG4gICAgdmFyIGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuICAgIC8vIFVzZSBhIGxvb2t1cCB0YWJsZSB0byBmaW5kIHRoZSBpbmRleC5cbiAgICB2YXIgbG9va3VwID0gdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gW10gOiBuZXcgVWludDhBcnJheSgyNTYpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbG9va3VwW2NoYXJzLmNoYXJDb2RlQXQoaSldID0gaTtcbiAgICB9XG4gICAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uIChhcnJheWJ1ZmZlcikge1xuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gJyc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMykge1xuICAgICAgICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICAgICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW4gJSAzID09PSAyKSB7XG4gICAgICAgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArICc9JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICAgICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArICc9PSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhc2U2NDtcbiAgICB9O1xuXG4gICAgY29uc3QgbGFzdEJsb2JNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICBjb25zdCB0cmFuc3BhcmVudEJsb2JNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICBmdW5jdGlvbiBnZXRUcmFuc3BhcmVudEJsb2JGb3Iod2lkdGgsIGhlaWdodCwgZGF0YVVSTE9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBpZCA9IGAke3dpZHRofS0ke2hlaWdodH1gO1xyXG4gICAgICAgICAgICBpZiAoJ09mZnNjcmVlbkNhbnZhcycgaW4gZ2xvYmFsVGhpcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRyYW5zcGFyZW50QmxvYk1hcC5oYXMoaWQpKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc3BhcmVudEJsb2JNYXAuZ2V0KGlkKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNjcmVlbiA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBvZmZzY3JlZW4uZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSB5aWVsZCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheUJ1ZmZlciA9IHlpZWxkIGJsb2IuYXJyYXlCdWZmZXIoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2U2NCA9IGVuY29kZShhcnJheUJ1ZmZlcik7XHJcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVudEJsb2JNYXAuc2V0KGlkLCBiYXNlNjQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U2NDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgd29ya2VyID0gc2VsZjtcclxuICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICgnT2Zmc2NyZWVuQ2FudmFzJyBpbiBnbG9iYWxUaGlzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGlkLCBiaXRtYXAsIHdpZHRoLCBoZWlnaHQsIGRhdGFVUkxPcHRpb25zIH0gPSBlLmRhdGE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BhcmVudEJhc2U2NCA9IGdldFRyYW5zcGFyZW50QmxvYkZvcih3aWR0aCwgaGVpZ2h0LCBkYXRhVVJMT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XHJcbiAgICAgICAgICAgICAgICBiaXRtYXAuY2xvc2UoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSB5aWVsZCBvZmZzY3JlZW4uY29udmVydFRvQmxvYihkYXRhVVJMT3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gYmxvYi50eXBlO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlCdWZmZXIgPSB5aWVsZCBibG9iLmFycmF5QnVmZmVyKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjQgPSBlbmNvZGUoYXJyYXlCdWZmZXIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0QmxvYk1hcC5oYXMoaWQpICYmICh5aWVsZCB0cmFuc3BhcmVudEJhc2U2NCkgPT09IGJhc2U2NCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RCbG9iTWFwLnNldChpZCwgYmFzZTY0KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobGFzdEJsb2JNYXAuZ2V0KGlkKSA9PT0gYmFzZTY0KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrZXIucG9zdE1lc3NhZ2UoeyBpZCB9KTtcclxuICAgICAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICBiYXNlNjQsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBsYXN0QmxvYk1hcC5zZXQoaWQsIGJhc2U2NCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VyLnBvc3RNZXNzYWdlKHsgaWQ6IGUuZGF0YS5pZCB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcblxufSkoKTtcbn0sIG51bGwpO1xuXG5jbGFzcyBDYW52YXNNYW5hZ2VyIHtcclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucmVzZXRPYnNlcnZlcnMgJiYgdGhpcy5yZXNldE9ic2VydmVycygpO1xyXG4gICAgfVxyXG4gICAgZnJlZXplKCkge1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHVuZnJlZXplKCkge1xyXG4gICAgICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBsb2NrKCkge1xyXG4gICAgICAgIHRoaXMubG9ja2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHVubG9jaygpIHtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnJhZlN0YW1wcyA9IHsgbGF0ZXN0SWQ6IDAsIGludm9rZUlkOiBudWxsIH07XHJcbiAgICAgICAgdGhpcy5mcm96ZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmxvY2tlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uID0gKHRhcmdldCwgbXV0YXRpb24pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV3RnJhbWUgPSB0aGlzLnJhZlN0YW1wcy5pbnZva2VJZCAmJlxyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQgIT09IHRoaXMucmFmU3RhbXBzLmludm9rZUlkO1xyXG4gICAgICAgICAgICBpZiAobmV3RnJhbWUgfHwgIXRoaXMucmFmU3RhbXBzLmludm9rZUlkKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yYWZTdGFtcHMuaW52b2tlSWQgPSB0aGlzLnJhZlN0YW1wcy5sYXRlc3RJZDtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuaGFzKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5zZXQodGFyZ2V0LCBbXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmdldCh0YXJnZXQpLnB1c2gobXV0YXRpb24pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgY29uc3QgeyBzYW1wbGluZyA9ICdhbGwnLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHJlY29yZENhbnZhcywgZGF0YVVSTE9wdGlvbnMsIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYiA9IG9wdGlvbnMubXV0YXRpb25DYjtcclxuICAgICAgICB0aGlzLm1pcnJvciA9IG9wdGlvbnMubWlycm9yO1xyXG4gICAgICAgIGlmIChyZWNvcmRDYW52YXMgJiYgc2FtcGxpbmcgPT09ICdhbGwnKVxyXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNNdXRhdGlvbk9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XHJcbiAgICAgICAgaWYgKHJlY29yZENhbnZhcyAmJiB0eXBlb2Ygc2FtcGxpbmcgPT09ICdudW1iZXInKVxyXG4gICAgICAgICAgICB0aGlzLmluaXRDYW52YXNGUFNPYnNlcnZlcihzYW1wbGluZywgd2luLCBibG9ja0NsYXNzLCBibG9ja1NlbGVjdG9yLCB7XHJcbiAgICAgICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpbml0Q2FudmFzRlBTT2JzZXJ2ZXIoZnBzLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBjYW52YXNDb250ZXh0UmVzZXQgPSBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgdHJ1ZSk7XHJcbiAgICAgICAgY29uc3Qgc25hcHNob3RJblByb2dyZXNzTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXJGYWN0b3J5KCk7XHJcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IGUuZGF0YTtcclxuICAgICAgICAgICAgc25hcHNob3RJblByb2dyZXNzTWFwLnNldChpZCwgZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoISgnYmFzZTY0JyBpbiBlLmRhdGEpKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICBjb25zdCB7IGJhc2U2NCwgdHlwZSwgd2lkdGgsIGhlaWdodCB9ID0gZS5kYXRhO1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xyXG4gICAgICAgICAgICAgICAgaWQsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiBDYW52YXNDb250ZXh0WycyRCddLFxyXG4gICAgICAgICAgICAgICAgY29tbWFuZHM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiAnY2xlYXJSZWN0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogWzAsIDAsIHdpZHRoLCBoZWlnaHRdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eTogJ2RyYXdJbWFnZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycl90eXBlOiAnSW1hZ2VCaXRtYXAnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnJfdHlwZTogJ0Jsb2InLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogW3sgcnJfdHlwZTogJ0FycmF5QnVmZmVyJywgYmFzZTY0IH1dLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHRpbWVCZXR3ZWVuU25hcHNob3RzID0gMTAwMCAvIGZwcztcclxuICAgICAgICBsZXQgbGFzdFNuYXBzaG90VGltZSA9IDA7XHJcbiAgICAgICAgbGV0IHJhZklkO1xyXG4gICAgICAgIGNvbnN0IGdldENhbnZhcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbWF0Y2hlZENhbnZhcyA9IFtdO1xyXG4gICAgICAgICAgICB3aW4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnY2FudmFzJykuZm9yRWFjaCgoY2FudmFzKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQmxvY2tlZChjYW52YXMsIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRydWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZENhbnZhcy5wdXNoKGNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlZENhbnZhcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHRha2VDYW52YXNTbmFwc2hvdHMgPSAodGltZXN0YW1wKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0U25hcHNob3RUaW1lICYmXHJcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXAgLSBsYXN0U25hcHNob3RUaW1lIDwgdGltZUJldHdlZW5TbmFwc2hvdHMpIHtcclxuICAgICAgICAgICAgICAgIHJhZklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRha2VDYW52YXNTbmFwc2hvdHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RTbmFwc2hvdFRpbWUgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgIGdldENhbnZhcygpXHJcbiAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY2FudmFzKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMubWlycm9yLmdldElkKGNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc25hcHNob3RJblByb2dyZXNzTWFwLmdldChpZCkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCA9PT0gMCB8fCBjYW52YXMuaGVpZ2h0ID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHNuYXBzaG90SW5Qcm9ncmVzc01hcC5zZXQoaWQsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKFsnd2ViZ2wnLCAnd2ViZ2wyJ10uaW5jbHVkZXMoY2FudmFzLl9fY29udGV4dCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoY2FudmFzLl9fY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuZ2V0Q29udGV4dEF0dHJpYnV0ZXMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZXNlcnZlRHJhd2luZ0J1ZmZlcikgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2xlYXIoY29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRtYXAgPSB5aWVsZCBjcmVhdGVJbWFnZUJpdG1hcChjYW52YXMpO1xyXG4gICAgICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHtcclxuICAgICAgICAgICAgICAgICAgICBpZCxcclxuICAgICAgICAgICAgICAgICAgICBiaXRtYXAsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNhbnZhcy53aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNhbnZhcy5oZWlnaHQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnM6IG9wdGlvbnMuZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICB9LCBbYml0bWFwXSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGFrZUNhbnZhc1NuYXBzaG90cyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByYWZJZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0YWtlQ2FudmFzU25hcHNob3RzKTtcclxuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0UmVzZXQoKTtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBpbml0Q2FudmFzTXV0YXRpb25PYnNlcnZlcih3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0UkFGVGltZXN0YW1waW5nKCk7XHJcbiAgICAgICAgdGhpcy5zdGFydFBlbmRpbmdDYW52YXNNdXRhdGlvbkZsdXNoZXIoKTtcclxuICAgICAgICBjb25zdCBjYW52YXNDb250ZXh0UmVzZXQgPSBpbml0Q2FudmFzQ29udGV4dE9ic2VydmVyKHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3RvciwgZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhczJEUmVzZXQgPSBpbml0Q2FudmFzMkRNdXRhdGlvbk9ic2VydmVyKHRoaXMucHJvY2Vzc011dGF0aW9uLmJpbmQodGhpcyksIHdpbiwgYmxvY2tDbGFzcywgYmxvY2tTZWxlY3Rvcik7XHJcbiAgICAgICAgY29uc3QgY2FudmFzV2ViR0wxYW5kMlJlc2V0ID0gaW5pdENhbnZhc1dlYkdMTXV0YXRpb25PYnNlcnZlcih0aGlzLnByb2Nlc3NNdXRhdGlvbi5iaW5kKHRoaXMpLCB3aW4sIGJsb2NrQ2xhc3MsIGJsb2NrU2VsZWN0b3IsIHRoaXMubWlycm9yKTtcclxuICAgICAgICB0aGlzLnJlc2V0T2JzZXJ2ZXJzID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0UmVzZXQoKTtcclxuICAgICAgICAgICAgY2FudmFzMkRSZXNldCgpO1xyXG4gICAgICAgICAgICBjYW52YXNXZWJHTDFhbmQyUmVzZXQoKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhcnRQZW5kaW5nQ2FudmFzTXV0YXRpb25GbHVzaGVyKCkge1xyXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmZsdXNoUGVuZGluZ0NhbnZhc011dGF0aW9ucygpKTtcclxuICAgIH1cclxuICAgIHN0YXJ0UkFGVGltZXN0YW1waW5nKCkge1xyXG4gICAgICAgIGNvbnN0IHNldExhdGVzdFJBRlRpbWVzdGFtcCA9ICh0aW1lc3RhbXApID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yYWZTdGFtcHMubGF0ZXN0SWQgPSB0aW1lc3RhbXA7XHJcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzZXRMYXRlc3RSQUZUaW1lc3RhbXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNldExhdGVzdFJBRlRpbWVzdGFtcCk7XHJcbiAgICB9XHJcbiAgICBmbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2FudmFzTXV0YXRpb25zLmZvckVhY2goKHZhbHVlcywgY2FudmFzKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5taXJyb3IuZ2V0SWQoY2FudmFzKTtcclxuICAgICAgICAgICAgdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbkZvcihjYW52YXMsIGlkKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5mbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbnMoKSk7XHJcbiAgICB9XHJcbiAgICBmbHVzaFBlbmRpbmdDYW52YXNNdXRhdGlvbkZvcihjYW52YXMsIGlkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZnJvemVuIHx8IHRoaXMubG9ja2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmFsdWVzV2l0aFR5cGUgPSB0aGlzLnBlbmRpbmdDYW52YXNNdXRhdGlvbnMuZ2V0KGNhbnZhcyk7XHJcbiAgICAgICAgaWYgKCF2YWx1ZXNXaXRoVHlwZSB8fCBpZCA9PT0gLTEpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZXNXaXRoVHlwZS5tYXAoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBfX3Jlc3QodmFsdWUsIFtcInR5cGVcIl0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdDtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IHZhbHVlc1dpdGhUeXBlWzBdO1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25DYih7IGlkLCB0eXBlLCBjb21tYW5kczogdmFsdWVzIH0pO1xyXG4gICAgICAgIHRoaXMucGVuZGluZ0NhbnZhc011dGF0aW9ucy5kZWxldGUoY2FudmFzKTtcclxuICAgIH1cclxufVxuXG5jbGFzcyBTdHlsZXNoZWV0TWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy50cmFja2VkTGlua0VsZW1lbnRzID0gbmV3IFdlYWtTZXQoKTtcclxuICAgICAgICB0aGlzLnN0eWxlTWlycm9yID0gbmV3IFN0eWxlU2hlZXRNaXJyb3IoKTtcclxuICAgICAgICB0aGlzLm11dGF0aW9uQ2IgPSBvcHRpb25zLm11dGF0aW9uQ2I7XHJcbiAgICAgICAgdGhpcy5hZG9wdGVkU3R5bGVTaGVldENiID0gb3B0aW9ucy5hZG9wdGVkU3R5bGVTaGVldENiO1xyXG4gICAgfVxyXG4gICAgYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKSB7XHJcbiAgICAgICAgaWYgKCdfY3NzVGV4dCcgaW4gY2hpbGRTbi5hdHRyaWJ1dGVzKVxyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uQ2Ioe1xyXG4gICAgICAgICAgICAgICAgYWRkczogW10sXHJcbiAgICAgICAgICAgICAgICByZW1vdmVzOiBbXSxcclxuICAgICAgICAgICAgICAgIHRleHRzOiBbXSxcclxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IFtcclxuICAgICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZFNuLmlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiBjaGlsZFNuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXR0cmlidXRlcyxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50cmFja0xpbmtFbGVtZW50KGxpbmtFbCk7XHJcbiAgICB9XHJcbiAgICB0cmFja0xpbmtFbGVtZW50KGxpbmtFbCkge1xyXG4gICAgICAgIGlmICh0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuaGFzKGxpbmtFbCkpXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB0aGlzLnRyYWNrZWRMaW5rRWxlbWVudHMuYWRkKGxpbmtFbCk7XHJcbiAgICAgICAgdGhpcy50cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KGxpbmtFbCk7XHJcbiAgICB9XHJcbiAgICBhZG9wdFN0eWxlU2hlZXRzKHNoZWV0cywgaG9zdElkKSB7XHJcbiAgICAgICAgaWYgKHNoZWV0cy5sZW5ndGggPT09IDApXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICBjb25zdCBhZG9wdGVkU3R5bGVTaGVldERhdGEgPSB7XHJcbiAgICAgICAgICAgIGlkOiBob3N0SWQsXHJcbiAgICAgICAgICAgIHN0eWxlSWRzOiBbXSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc2hlZXQgb2Ygc2hlZXRzKSB7XHJcbiAgICAgICAgICAgIGxldCBzdHlsZUlkO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuc3R5bGVNaXJyb3IuaGFzKHNoZWV0KSkge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVJZCA9IHRoaXMuc3R5bGVNaXJyb3IuYWRkKHNoZWV0KTtcclxuICAgICAgICAgICAgICAgIHN0eWxlcy5wdXNoKHtcclxuICAgICAgICAgICAgICAgICAgICBzdHlsZUlkLFxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiBBcnJheS5mcm9tKHNoZWV0LnJ1bGVzIHx8IENTU1J1bGUsIChyLCBpbmRleCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZTogc3RyaW5naWZ5UnVsZShyKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgc3R5bGVJZCA9IHRoaXMuc3R5bGVNaXJyb3IuZ2V0SWQoc2hlZXQpO1xyXG4gICAgICAgICAgICBhZG9wdGVkU3R5bGVTaGVldERhdGEuc3R5bGVJZHMucHVzaChzdHlsZUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPiAwKVxyXG4gICAgICAgICAgICBhZG9wdGVkU3R5bGVTaGVldERhdGEuc3R5bGVzID0gc3R5bGVzO1xyXG4gICAgICAgIHRoaXMuYWRvcHRlZFN0eWxlU2hlZXRDYihhZG9wdGVkU3R5bGVTaGVldERhdGEpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5zdHlsZU1pcnJvci5yZXNldCgpO1xyXG4gICAgICAgIHRoaXMudHJhY2tlZExpbmtFbGVtZW50cyA9IG5ldyBXZWFrU2V0KCk7XHJcbiAgICB9XHJcbiAgICB0cmFja1N0eWxlc2hlZXRJbkxpbmtFbGVtZW50KGxpbmtFbCkge1xyXG4gICAgfVxyXG59XG5cbmNsYXNzIFByb2Nlc3NlZE5vZGVNYW5hZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMubm9kZU1hcCA9IG5ldyBXZWFrTWFwKCk7XHJcbiAgICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnBlcmlvZGljYWxseUNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBwZXJpb2RpY2FsbHlDbGVhcigpIHtcclxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmxvb3ApXHJcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmlvZGljYWxseUNsZWFyKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpbk90aGVyQnVmZmVyKG5vZGUsIHRoaXNCdWZmZXIpIHtcclxuICAgICAgICBjb25zdCBidWZmZXJzID0gdGhpcy5ub2RlTWFwLmdldChub2RlKTtcclxuICAgICAgICByZXR1cm4gKGJ1ZmZlcnMgJiYgQXJyYXkuZnJvbShidWZmZXJzKS5zb21lKChidWZmZXIpID0+IGJ1ZmZlciAhPT0gdGhpc0J1ZmZlcikpO1xyXG4gICAgfVxyXG4gICAgYWRkKG5vZGUsIGJ1ZmZlcikge1xyXG4gICAgICAgIHRoaXMubm9kZU1hcC5zZXQobm9kZSwgKHRoaXMubm9kZU1hcC5nZXQobm9kZSkgfHwgbmV3IFNldCgpKS5hZGQoYnVmZmVyKSk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLm5vZGVNYXAgPSBuZXcgV2Vha01hcCgpO1xyXG4gICAgfVxyXG4gICAgZGVzdHJveSgpIHtcclxuICAgICAgICB0aGlzLmxvb3AgPSBmYWxzZTtcclxuICAgIH1cclxufVxuXG5mdW5jdGlvbiB3cmFwRXZlbnQoZSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZSksIHsgdGltZXN0YW1wOiBub3dUaW1lc3RhbXAoKSB9KTtcclxufVxyXG5sZXQgd3JhcHBlZEVtaXQ7XHJcbmxldCB0YWtlRnVsbFNuYXBzaG90O1xyXG5sZXQgY2FudmFzTWFuYWdlcjtcclxubGV0IHJlY29yZGluZyA9IGZhbHNlO1xyXG5jb25zdCBtaXJyb3IgPSBjcmVhdGVNaXJyb3IoKTtcclxuZnVuY3Rpb24gcmVjb3JkKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgY29uc3QgeyBlbWl0LCBjaGVja291dEV2ZXJ5Tm1zLCBjaGVja291dEV2ZXJ5TnRoLCBibG9ja0NsYXNzID0gJ3JyLWJsb2NrJywgYmxvY2tTZWxlY3RvciA9IG51bGwsIGlnbm9yZUNsYXNzID0gJ3JyLWlnbm9yZScsIGlnbm9yZVNlbGVjdG9yID0gbnVsbCwgbWFza1RleHRDbGFzcyA9ICdyci1tYXNrJywgbWFza1RleHRTZWxlY3RvciA9IG51bGwsIGlubGluZVN0eWxlc2hlZXQgPSB0cnVlLCBtYXNrQWxsSW5wdXRzLCBtYXNrSW5wdXRPcHRpb25zOiBfbWFza0lucHV0T3B0aW9ucywgc2xpbURPTU9wdGlvbnM6IF9zbGltRE9NT3B0aW9ucywgbWFza0lucHV0Rm4sIG1hc2tUZXh0Rm4sIGhvb2tzLCBwYWNrRm4sIHNhbXBsaW5nID0ge30sIGRhdGFVUkxPcHRpb25zID0ge30sIG1vdXNlbW92ZVdhaXQsIHJlY29yZERPTSA9IHRydWUsIHJlY29yZENhbnZhcyA9IGZhbHNlLCByZWNvcmRDcm9zc09yaWdpbklmcmFtZXMgPSBmYWxzZSwgcmVjb3JkQWZ0ZXIgPSBvcHRpb25zLnJlY29yZEFmdGVyID09PSAnRE9NQ29udGVudExvYWRlZCdcclxuICAgICAgICA/IG9wdGlvbnMucmVjb3JkQWZ0ZXJcclxuICAgICAgICA6ICdsb2FkJywgdXNlclRyaWdnZXJlZE9uSW5wdXQgPSBmYWxzZSwgY29sbGVjdEZvbnRzID0gZmFsc2UsIGlubGluZUltYWdlcyA9IGZhbHNlLCBwbHVnaW5zLCBrZWVwSWZyYW1lU3JjRm4gPSAoKSA9PiBmYWxzZSwgaWdub3JlQ1NTQXR0cmlidXRlcyA9IG5ldyBTZXQoW10pLCBlcnJvckhhbmRsZXIsIH0gPSBvcHRpb25zO1xyXG4gICAgcmVnaXN0ZXJFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyKTtcclxuICAgIGNvbnN0IGluRW1pdHRpbmdGcmFtZSA9IHJlY29yZENyb3NzT3JpZ2luSWZyYW1lc1xyXG4gICAgICAgID8gd2luZG93LnBhcmVudCA9PT0gd2luZG93XHJcbiAgICAgICAgOiB0cnVlO1xyXG4gICAgbGV0IHBhc3NFbWl0c1RvUGFyZW50ID0gZmFsc2U7XHJcbiAgICBpZiAoIWluRW1pdHRpbmdGcmFtZSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cucGFyZW50LmRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBwYXNzRW1pdHNUb1BhcmVudCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIHBhc3NFbWl0c1RvUGFyZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoaW5FbWl0dGluZ0ZyYW1lICYmICFlbWl0KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbWl0IGZ1bmN0aW9uIGlzIHJlcXVpcmVkJyk7XHJcbiAgICB9XHJcbiAgICBpZiAobW91c2Vtb3ZlV2FpdCAhPT0gdW5kZWZpbmVkICYmIHNhbXBsaW5nLm1vdXNlbW92ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgc2FtcGxpbmcubW91c2Vtb3ZlID0gbW91c2Vtb3ZlV2FpdDtcclxuICAgIH1cclxuICAgIG1pcnJvci5yZXNldCgpO1xyXG4gICAgY29uc3QgbWFza0lucHV0T3B0aW9ucyA9IG1hc2tBbGxJbnB1dHMgPT09IHRydWVcclxuICAgICAgICA/IHtcclxuICAgICAgICAgICAgY29sb3I6IHRydWUsXHJcbiAgICAgICAgICAgIGRhdGU6IHRydWUsXHJcbiAgICAgICAgICAgICdkYXRldGltZS1sb2NhbCc6IHRydWUsXHJcbiAgICAgICAgICAgIGVtYWlsOiB0cnVlLFxyXG4gICAgICAgICAgICBtb250aDogdHJ1ZSxcclxuICAgICAgICAgICAgbnVtYmVyOiB0cnVlLFxyXG4gICAgICAgICAgICByYW5nZTogdHJ1ZSxcclxuICAgICAgICAgICAgc2VhcmNoOiB0cnVlLFxyXG4gICAgICAgICAgICB0ZWw6IHRydWUsXHJcbiAgICAgICAgICAgIHRleHQ6IHRydWUsXHJcbiAgICAgICAgICAgIHRpbWU6IHRydWUsXHJcbiAgICAgICAgICAgIHVybDogdHJ1ZSxcclxuICAgICAgICAgICAgd2VlazogdHJ1ZSxcclxuICAgICAgICAgICAgdGV4dGFyZWE6IHRydWUsXHJcbiAgICAgICAgICAgIHNlbGVjdDogdHJ1ZSxcclxuICAgICAgICAgICAgcGFzc3dvcmQ6IHRydWUsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDogX21hc2tJbnB1dE9wdGlvbnMgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IF9tYXNrSW5wdXRPcHRpb25zXHJcbiAgICAgICAgICAgIDogeyBwYXNzd29yZDogdHJ1ZSB9O1xyXG4gICAgY29uc3Qgc2xpbURPTU9wdGlvbnMgPSBfc2xpbURPTU9wdGlvbnMgPT09IHRydWUgfHwgX3NsaW1ET01PcHRpb25zID09PSAnYWxsJ1xyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBzY3JpcHQ6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbW1lbnQ6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRGYXZpY29uOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkV2hpdGVzcGFjZTogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZE1ldGFTb2NpYWw6IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhUm9ib3RzOiB0cnVlLFxyXG4gICAgICAgICAgICBoZWFkTWV0YUh0dHBFcXVpdjogdHJ1ZSxcclxuICAgICAgICAgICAgaGVhZE1ldGFWZXJpZmljYXRpb246IHRydWUsXHJcbiAgICAgICAgICAgIGhlYWRNZXRhQXV0aG9yc2hpcDogX3NsaW1ET01PcHRpb25zID09PSAnYWxsJyxcclxuICAgICAgICAgICAgaGVhZE1ldGFEZXNjS2V5d29yZHM6IF9zbGltRE9NT3B0aW9ucyA9PT0gJ2FsbCcsXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDogX3NsaW1ET01PcHRpb25zXHJcbiAgICAgICAgICAgID8gX3NsaW1ET01PcHRpb25zXHJcbiAgICAgICAgICAgIDoge307XHJcbiAgICBwb2x5ZmlsbCgpO1xyXG4gICAgbGV0IGxhc3RGdWxsU25hcHNob3RFdmVudDtcclxuICAgIGxldCBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPSAwO1xyXG4gICAgY29uc3QgZXZlbnRQcm9jZXNzb3IgPSAoZSkgPT4ge1xyXG4gICAgICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMgfHwgW10pIHtcclxuICAgICAgICAgICAgaWYgKHBsdWdpbi5ldmVudFByb2Nlc3Nvcikge1xyXG4gICAgICAgICAgICAgICAgZSA9IHBsdWdpbi5ldmVudFByb2Nlc3NvcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGFja0ZuICYmXHJcbiAgICAgICAgICAgICFwYXNzRW1pdHNUb1BhcmVudCkge1xyXG4gICAgICAgICAgICBlID0gcGFja0ZuKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZTtcclxuICAgIH07XHJcbiAgICB3cmFwcGVkRW1pdCA9IChlLCBpc0NoZWNrb3V0KSA9PiB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoKF9hID0gbXV0YXRpb25CdWZmZXJzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNGcm96ZW4oKSkgJiZcclxuICAgICAgICAgICAgZS50eXBlICE9PSBFdmVudFR5cGUkMS5GdWxsU25hcHNob3QgJiZcclxuICAgICAgICAgICAgIShlLnR5cGUgPT09IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QgJiZcclxuICAgICAgICAgICAgICAgIGUuZGF0YS5zb3VyY2UgPT09IEluY3JlbWVudGFsU291cmNlJDEuTXV0YXRpb24pKSB7XHJcbiAgICAgICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi51bmZyZWV6ZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGluRW1pdHRpbmdGcmFtZSkge1xyXG4gICAgICAgICAgICBlbWl0ID09PSBudWxsIHx8IGVtaXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVtaXQoZXZlbnRQcm9jZXNzb3IoZSksIGlzQ2hlY2tvdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwYXNzRW1pdHNUb1BhcmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xyXG4gICAgICAgICAgICAgICAgdHlwZTogJ3Jyd2ViJyxcclxuICAgICAgICAgICAgICAgIGV2ZW50OiBldmVudFByb2Nlc3NvcihlKSxcclxuICAgICAgICAgICAgICAgIG9yaWdpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcclxuICAgICAgICAgICAgICAgIGlzQ2hlY2tvdXQsXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UobWVzc2FnZSwgJyonKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gRXZlbnRUeXBlJDEuRnVsbFNuYXBzaG90KSB7XHJcbiAgICAgICAgICAgIGxhc3RGdWxsU25hcHNob3RFdmVudCA9IGU7XHJcbiAgICAgICAgICAgIGluY3JlbWVudGFsU25hcHNob3RDb3VudCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGUudHlwZSA9PT0gRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCkge1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhLnNvdXJjZSA9PT0gSW5jcmVtZW50YWxTb3VyY2UkMS5NdXRhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgZS5kYXRhLmlzQXR0YWNoSWZyYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW5jcmVtZW50YWxTbmFwc2hvdENvdW50Kys7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4Y2VlZENvdW50ID0gY2hlY2tvdXRFdmVyeU50aCAmJiBpbmNyZW1lbnRhbFNuYXBzaG90Q291bnQgPj0gY2hlY2tvdXRFdmVyeU50aDtcclxuICAgICAgICAgICAgY29uc3QgZXhjZWVkVGltZSA9IGNoZWNrb3V0RXZlcnlObXMgJiZcclxuICAgICAgICAgICAgICAgIGUudGltZXN0YW1wIC0gbGFzdEZ1bGxTbmFwc2hvdEV2ZW50LnRpbWVzdGFtcCA+IGNoZWNrb3V0RXZlcnlObXM7XHJcbiAgICAgICAgICAgIGlmIChleGNlZWRDb3VudCB8fCBleGNlZWRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICB0YWtlRnVsbFNuYXBzaG90KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHdyYXBwZWRNdXRhdGlvbkVtaXQgPSAobSkgPT4ge1xyXG4gICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuTXV0YXRpb24gfSwgbSksXHJcbiAgICAgICAgfSkpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHdyYXBwZWRTY3JvbGxFbWl0ID0gKHApID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlNjcm9sbCB9LCBwKSxcclxuICAgIH0pKTtcclxuICAgIGNvbnN0IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQgPSAocCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuQ2FudmFzTXV0YXRpb24gfSwgcCksXHJcbiAgICB9KSk7XHJcbiAgICBjb25zdCB3cmFwcGVkQWRvcHRlZFN0eWxlU2hlZXRFbWl0ID0gKGEpID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLkFkb3B0ZWRTdHlsZVNoZWV0IH0sIGEpLFxyXG4gICAgfSkpO1xyXG4gICAgY29uc3Qgc3R5bGVzaGVldE1hbmFnZXIgPSBuZXcgU3R5bGVzaGVldE1hbmFnZXIoe1xyXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgYWRvcHRlZFN0eWxlU2hlZXRDYjogd3JhcHBlZEFkb3B0ZWRTdHlsZVNoZWV0RW1pdCxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgaWZyYW1lTWFuYWdlciA9IG5ldyBJZnJhbWVNYW5hZ2VyKHtcclxuICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgbXV0YXRpb25DYjogd3JhcHBlZE11dGF0aW9uRW1pdCxcclxuICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcjogc3R5bGVzaGVldE1hbmFnZXIsXHJcbiAgICAgICAgcmVjb3JkQ3Jvc3NPcmlnaW5JZnJhbWVzLFxyXG4gICAgICAgIHdyYXBwZWRFbWl0LFxyXG4gICAgfSk7XHJcbiAgICBmb3IgKGNvbnN0IHBsdWdpbiBvZiBwbHVnaW5zIHx8IFtdKSB7XHJcbiAgICAgICAgaWYgKHBsdWdpbi5nZXRNaXJyb3IpXHJcbiAgICAgICAgICAgIHBsdWdpbi5nZXRNaXJyb3Ioe1xyXG4gICAgICAgICAgICAgICAgbm9kZU1pcnJvcjogbWlycm9yLFxyXG4gICAgICAgICAgICAgICAgY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3I6IGlmcmFtZU1hbmFnZXIuY3Jvc3NPcmlnaW5JZnJhbWVNaXJyb3IsXHJcbiAgICAgICAgICAgICAgICBjcm9zc09yaWdpbklmcmFtZVN0eWxlTWlycm9yOiBpZnJhbWVNYW5hZ2VyLmNyb3NzT3JpZ2luSWZyYW1lU3R5bGVNaXJyb3IsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcHJvY2Vzc2VkTm9kZU1hbmFnZXIgPSBuZXcgUHJvY2Vzc2VkTm9kZU1hbmFnZXIoKTtcclxuICAgIGNhbnZhc01hbmFnZXIgPSBuZXcgQ2FudmFzTWFuYWdlcih7XHJcbiAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRDYW52YXNNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgd2luOiB3aW5kb3csXHJcbiAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICBibG9ja1NlbGVjdG9yLFxyXG4gICAgICAgIG1pcnJvcixcclxuICAgICAgICBzYW1wbGluZzogc2FtcGxpbmcuY2FudmFzLFxyXG4gICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBzaGFkb3dEb21NYW5hZ2VyID0gbmV3IFNoYWRvd0RvbU1hbmFnZXIoe1xyXG4gICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgc2Nyb2xsQ2I6IHdyYXBwZWRTY3JvbGxFbWl0LFxyXG4gICAgICAgIGJ5cGFzc09wdGlvbnM6IHtcclxuICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgYmxvY2tTZWxlY3RvcixcclxuICAgICAgICAgICAgbWFza1RleHRDbGFzcyxcclxuICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgaW5saW5lU3R5bGVzaGVldCxcclxuICAgICAgICAgICAgbWFza0lucHV0T3B0aW9ucyxcclxuICAgICAgICAgICAgZGF0YVVSTE9wdGlvbnMsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgIGlubGluZUltYWdlcyxcclxuICAgICAgICAgICAgc2FtcGxpbmcsXHJcbiAgICAgICAgICAgIHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICBpZnJhbWVNYW5hZ2VyLFxyXG4gICAgICAgICAgICBzdHlsZXNoZWV0TWFuYWdlcixcclxuICAgICAgICAgICAgY2FudmFzTWFuYWdlcixcclxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgICAgICBwcm9jZXNzZWROb2RlTWFuYWdlcixcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1pcnJvcixcclxuICAgIH0pO1xyXG4gICAgdGFrZUZ1bGxTbmFwc2hvdCA9IChpc0NoZWNrb3V0ID0gZmFsc2UpID0+IHtcclxuICAgICAgICBpZiAoIXJlY29yZERPTSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLk1ldGEsXHJcbiAgICAgICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgICAgIGhyZWY6IHdpbmRvdy5sb2NhdGlvbi5ocmVmLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IGdldFdpbmRvd1dpZHRoKCksXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGdldFdpbmRvd0hlaWdodCgpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pLCBpc0NoZWNrb3V0KTtcclxuICAgICAgICBzdHlsZXNoZWV0TWFuYWdlci5yZXNldCgpO1xyXG4gICAgICAgIHNoYWRvd0RvbU1hbmFnZXIuaW5pdCgpO1xyXG4gICAgICAgIG11dGF0aW9uQnVmZmVycy5mb3JFYWNoKChidWYpID0+IGJ1Zi5sb2NrKCkpO1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBzbmFwc2hvdChkb2N1bWVudCwge1xyXG4gICAgICAgICAgICBtaXJyb3IsXHJcbiAgICAgICAgICAgIGJsb2NrQ2xhc3MsXHJcbiAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Q2xhc3MsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0U2VsZWN0b3IsXHJcbiAgICAgICAgICAgIGlubGluZVN0eWxlc2hlZXQsXHJcbiAgICAgICAgICAgIG1hc2tBbGxJbnB1dHM6IG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgIG1hc2tUZXh0Rm4sXHJcbiAgICAgICAgICAgIHNsaW1ET006IHNsaW1ET01PcHRpb25zLFxyXG4gICAgICAgICAgICBkYXRhVVJMT3B0aW9ucyxcclxuICAgICAgICAgICAgcmVjb3JkQ2FudmFzLFxyXG4gICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgIG9uU2VyaWFsaXplOiAobikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZElmcmFtZShuLCBtaXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlci5hZGRJZnJhbWUobik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkU3R5bGVzaGVldChuLCBtaXJyb3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIudHJhY2tMaW5rRWxlbWVudChuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KG4pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlci5hZGRTaGFkb3dSb290KG4uc2hhZG93Um9vdCwgZG9jdW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBvbklmcmFtZUxvYWQ6IChpZnJhbWUsIGNoaWxkU24pID0+IHtcclxuICAgICAgICAgICAgICAgIGlmcmFtZU1hbmFnZXIuYXR0YWNoSWZyYW1lKGlmcmFtZSwgY2hpbGRTbik7XHJcbiAgICAgICAgICAgICAgICBzaGFkb3dEb21NYW5hZ2VyLm9ic2VydmVBdHRhY2hTaGFkb3coaWZyYW1lKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgb25TdHlsZXNoZWV0TG9hZDogKGxpbmtFbCwgY2hpbGRTbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVzaGVldE1hbmFnZXIuYXR0YWNoTGlua0VsZW1lbnQobGlua0VsLCBjaGlsZFNuKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAga2VlcElmcmFtZVNyY0ZuLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghbm9kZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCdGYWlsZWQgdG8gc25hcHNob3QgdGhlIGRvY3VtZW50Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkZ1bGxTbmFwc2hvdCxcclxuICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgbm9kZSxcclxuICAgICAgICAgICAgICAgIGluaXRpYWxPZmZzZXQ6IGdldFdpbmRvd1Njcm9sbCh3aW5kb3cpLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0pLCBpc0NoZWNrb3V0KTtcclxuICAgICAgICBtdXRhdGlvbkJ1ZmZlcnMuZm9yRWFjaCgoYnVmKSA9PiBidWYudW5sb2NrKCkpO1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5hZG9wdGVkU3R5bGVTaGVldHMgJiYgZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLmxlbmd0aCA+IDApXHJcbiAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLmFkb3B0U3R5bGVTaGVldHMoZG9jdW1lbnQuYWRvcHRlZFN0eWxlU2hlZXRzLCBtaXJyb3IuZ2V0SWQoZG9jdW1lbnQpKTtcclxuICAgIH07XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gW107XHJcbiAgICAgICAgY29uc3Qgb2JzZXJ2ZSA9IChkb2MpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tXcmFwcGVyKGluaXRPYnNlcnZlcnMpKHtcclxuICAgICAgICAgICAgICAgIG11dGF0aW9uQ2I6IHdyYXBwZWRNdXRhdGlvbkVtaXQsXHJcbiAgICAgICAgICAgICAgICBtb3VzZW1vdmVDYjogKHBvc2l0aW9ucywgc291cmNlKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9ucyxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgbW91c2VJbnRlcmFjdGlvbkNiOiAoZCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuTW91c2VJbnRlcmFjdGlvbiB9LCBkKSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIHNjcm9sbENiOiB3cmFwcGVkU2Nyb2xsRW1pdCxcclxuICAgICAgICAgICAgICAgIHZpZXdwb3J0UmVzaXplQ2I6IChkKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5WaWV3cG9ydFJlc2l6ZSB9LCBkKSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIGlucHV0Q2I6ICh2KSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5JbnB1dCB9LCB2KSxcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIG1lZGlhSW50ZXJhY3Rpb25DYjogKHApID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLk1lZGlhSW50ZXJhY3Rpb24gfSwgcCksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0UnVsZUNiOiAocikgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuU3R5bGVTaGVldFJ1bGUgfSwgciksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBzdHlsZURlY2xhcmF0aW9uQ2I6IChyKSA9PiB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7IHNvdXJjZTogSW5jcmVtZW50YWxTb3VyY2UkMS5TdHlsZURlY2xhcmF0aW9uIH0sIHIpLFxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgY2FudmFzTXV0YXRpb25DYjogd3JhcHBlZENhbnZhc011dGF0aW9uRW1pdCxcclxuICAgICAgICAgICAgICAgIGZvbnRDYjogKHApID0+IHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuSW5jcmVtZW50YWxTbmFwc2hvdCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLkZvbnQgfSwgcCksXHJcbiAgICAgICAgICAgICAgICB9KSksXHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25DYjogKHApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB3cmFwcGVkRW1pdCh3cmFwRXZlbnQoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5JbmNyZW1lbnRhbFNuYXBzaG90LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgc291cmNlOiBJbmNyZW1lbnRhbFNvdXJjZSQxLlNlbGVjdGlvbiB9LCBwKSxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgY3VzdG9tRWxlbWVudENiOiAoYykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IEV2ZW50VHlwZSQxLkluY3JlbWVudGFsU25hcHNob3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oeyBzb3VyY2U6IEluY3JlbWVudGFsU291cmNlJDEuQ3VzdG9tRWxlbWVudCB9LCBjKSxcclxuICAgICAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgYmxvY2tDbGFzcyxcclxuICAgICAgICAgICAgICAgIGlnbm9yZUNsYXNzLFxyXG4gICAgICAgICAgICAgICAgaWdub3JlU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBtYXNrVGV4dENsYXNzLFxyXG4gICAgICAgICAgICAgICAgbWFza1RleHRTZWxlY3RvcixcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dE9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgICBpbmxpbmVTdHlsZXNoZWV0LFxyXG4gICAgICAgICAgICAgICAgc2FtcGxpbmcsXHJcbiAgICAgICAgICAgICAgICByZWNvcmRET00sXHJcbiAgICAgICAgICAgICAgICByZWNvcmRDYW52YXMsXHJcbiAgICAgICAgICAgICAgICBpbmxpbmVJbWFnZXMsXHJcbiAgICAgICAgICAgICAgICB1c2VyVHJpZ2dlcmVkT25JbnB1dCxcclxuICAgICAgICAgICAgICAgIGNvbGxlY3RGb250cyxcclxuICAgICAgICAgICAgICAgIGRvYyxcclxuICAgICAgICAgICAgICAgIG1hc2tJbnB1dEZuLFxyXG4gICAgICAgICAgICAgICAgbWFza1RleHRGbixcclxuICAgICAgICAgICAgICAgIGtlZXBJZnJhbWVTcmNGbixcclxuICAgICAgICAgICAgICAgIGJsb2NrU2VsZWN0b3IsXHJcbiAgICAgICAgICAgICAgICBzbGltRE9NT3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIGRhdGFVUkxPcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgbWlycm9yLFxyXG4gICAgICAgICAgICAgICAgaWZyYW1lTWFuYWdlcixcclxuICAgICAgICAgICAgICAgIHN0eWxlc2hlZXRNYW5hZ2VyLFxyXG4gICAgICAgICAgICAgICAgc2hhZG93RG9tTWFuYWdlcixcclxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZE5vZGVNYW5hZ2VyLFxyXG4gICAgICAgICAgICAgICAgY2FudmFzTWFuYWdlcixcclxuICAgICAgICAgICAgICAgIGlnbm9yZUNTU0F0dHJpYnV0ZXMsXHJcbiAgICAgICAgICAgICAgICBwbHVnaW5zOiAoKF9hID0gcGx1Z2lucyA9PT0gbnVsbCB8fCBwbHVnaW5zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwbHVnaW5zLmZpbHRlcigocCkgPT4gcC5vYnNlcnZlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKHApID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXI6IHAub2JzZXJ2ZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogcC5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrOiAocGF5bG9hZCkgPT4gd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuUGx1Z2luLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW46IHAubmFtZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgfSkpKSB8fCBbXSxcclxuICAgICAgICAgICAgfSwgaG9va3MpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWZyYW1lTWFuYWdlci5hZGRMb2FkTGlzdGVuZXIoKGlmcmFtZUVsKSA9PiB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9ic2VydmUoaWZyYW1lRWwuY29udGVudERvY3VtZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgaW5pdCA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGFrZUZ1bGxTbmFwc2hvdCgpO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9ic2VydmUoZG9jdW1lbnQpKTtcclxuICAgICAgICAgICAgcmVjb3JkaW5nID0gdHJ1ZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcclxuICAgICAgICAgICAgaW5pdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChvbignRE9NQ29udGVudExvYWRlZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuRG9tQ29udGVudExvYWRlZCxcclxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmRBZnRlciA9PT0gJ0RPTUNvbnRlbnRMb2FkZWQnKVxyXG4gICAgICAgICAgICAgICAgICAgIGluaXQoKTtcclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKG9uKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgd3JhcHBlZEVtaXQod3JhcEV2ZW50KHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBFdmVudFR5cGUkMS5Mb2FkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxyXG4gICAgICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZEFmdGVyID09PSAnbG9hZCcpXHJcbiAgICAgICAgICAgICAgICAgICAgaW5pdCgpO1xyXG4gICAgICAgICAgICB9LCB3aW5kb3cpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaGFuZGxlcnMuZm9yRWFjaCgoaCkgPT4gaCgpKTtcclxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZU1hbmFnZXIuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICByZWNvcmRpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdW5yZWdpc3RlckVycm9ySGFuZGxlcigpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IpO1xyXG4gICAgfVxyXG59XHJcbnJlY29yZC5hZGRDdXN0b21FdmVudCA9ICh0YWcsIHBheWxvYWQpID0+IHtcclxuICAgIGlmICghcmVjb3JkaW5nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwbGVhc2UgYWRkIGN1c3RvbSBldmVudCBhZnRlciBzdGFydCByZWNvcmRpbmcnKTtcclxuICAgIH1cclxuICAgIHdyYXBwZWRFbWl0KHdyYXBFdmVudCh7XHJcbiAgICAgICAgdHlwZTogRXZlbnRUeXBlJDEuQ3VzdG9tLFxyXG4gICAgICAgIGRhdGE6IHtcclxuICAgICAgICAgICAgdGFnLFxyXG4gICAgICAgICAgICBwYXlsb2FkLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KSk7XHJcbn07XHJcbnJlY29yZC5mcmVlemVQYWdlID0gKCkgPT4ge1xyXG4gICAgbXV0YXRpb25CdWZmZXJzLmZvckVhY2goKGJ1ZikgPT4gYnVmLmZyZWV6ZSgpKTtcclxufTtcclxucmVjb3JkLnRha2VGdWxsU25hcHNob3QgPSAoaXNDaGVja291dCkgPT4ge1xyXG4gICAgaWYgKCFyZWNvcmRpbmcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsZWFzZSB0YWtlIGZ1bGwgc25hcHNob3QgYWZ0ZXIgc3RhcnQgcmVjb3JkaW5nJyk7XHJcbiAgICB9XHJcbiAgICB0YWtlRnVsbFNuYXBzaG90KGlzQ2hlY2tvdXQpO1xyXG59O1xyXG5yZWNvcmQubWlycm9yID0gbWlycm9yO1xuXG52YXIgRXZlbnRUeXBlID0gLyogQF9fUFVSRV9fICovICgoRXZlbnRUeXBlMikgPT4ge1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJEb21Db250ZW50TG9hZGVkXCJdID0gMF0gPSBcIkRvbUNvbnRlbnRMb2FkZWRcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiTG9hZFwiXSA9IDFdID0gXCJMb2FkXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIkZ1bGxTbmFwc2hvdFwiXSA9IDJdID0gXCJGdWxsU25hcHNob3RcIjtcbiAgRXZlbnRUeXBlMltFdmVudFR5cGUyW1wiSW5jcmVtZW50YWxTbmFwc2hvdFwiXSA9IDNdID0gXCJJbmNyZW1lbnRhbFNuYXBzaG90XCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIk1ldGFcIl0gPSA0XSA9IFwiTWV0YVwiO1xuICBFdmVudFR5cGUyW0V2ZW50VHlwZTJbXCJDdXN0b21cIl0gPSA1XSA9IFwiQ3VzdG9tXCI7XG4gIEV2ZW50VHlwZTJbRXZlbnRUeXBlMltcIlBsdWdpblwiXSA9IDZdID0gXCJQbHVnaW5cIjtcbiAgcmV0dXJuIEV2ZW50VHlwZTI7XG59KShFdmVudFR5cGUgfHwge30pO1xudmFyIEluY3JlbWVudGFsU291cmNlID0gLyogQF9fUFVSRV9fICovICgoSW5jcmVtZW50YWxTb3VyY2UyKSA9PiB7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJNdXRhdGlvblwiXSA9IDBdID0gXCJNdXRhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VNb3ZlXCJdID0gMV0gPSBcIk1vdXNlTW92ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiTW91c2VJbnRlcmFjdGlvblwiXSA9IDJdID0gXCJNb3VzZUludGVyYWN0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJTY3JvbGxcIl0gPSAzXSA9IFwiU2Nyb2xsXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJWaWV3cG9ydFJlc2l6ZVwiXSA9IDRdID0gXCJWaWV3cG9ydFJlc2l6ZVwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiSW5wdXRcIl0gPSA1XSA9IFwiSW5wdXRcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIlRvdWNoTW92ZVwiXSA9IDZdID0gXCJUb3VjaE1vdmVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIk1lZGlhSW50ZXJhY3Rpb25cIl0gPSA3XSA9IFwiTWVkaWFJbnRlcmFjdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVTaGVldFJ1bGVcIl0gPSA4XSA9IFwiU3R5bGVTaGVldFJ1bGVcIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkNhbnZhc011dGF0aW9uXCJdID0gOV0gPSBcIkNhbnZhc011dGF0aW9uXCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJGb250XCJdID0gMTBdID0gXCJGb250XCI7XG4gIEluY3JlbWVudGFsU291cmNlMltJbmNyZW1lbnRhbFNvdXJjZTJbXCJMb2dcIl0gPSAxMV0gPSBcIkxvZ1wiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiRHJhZ1wiXSA9IDEyXSA9IFwiRHJhZ1wiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU3R5bGVEZWNsYXJhdGlvblwiXSA9IDEzXSA9IFwiU3R5bGVEZWNsYXJhdGlvblwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiU2VsZWN0aW9uXCJdID0gMTRdID0gXCJTZWxlY3Rpb25cIjtcbiAgSW5jcmVtZW50YWxTb3VyY2UyW0luY3JlbWVudGFsU291cmNlMltcIkFkb3B0ZWRTdHlsZVNoZWV0XCJdID0gMTVdID0gXCJBZG9wdGVkU3R5bGVTaGVldFwiO1xuICBJbmNyZW1lbnRhbFNvdXJjZTJbSW5jcmVtZW50YWxTb3VyY2UyW1wiQ3VzdG9tRWxlbWVudFwiXSA9IDE2XSA9IFwiQ3VzdG9tRWxlbWVudFwiO1xuICByZXR1cm4gSW5jcmVtZW50YWxTb3VyY2UyO1xufSkoSW5jcmVtZW50YWxTb3VyY2UgfHwge30pO1xuXG52YXIgQ29uZmlnID0ge1xuICAgIERFQlVHOiBmYWxzZSxcbiAgICBMSUJfVkVSU0lPTjogJzIuNTguMCdcbn07XG5cbi8vIHNpbmNlIGVzNiBpbXBvcnRzIGFyZSBzdGF0aWMgYW5kIHdlIHJ1biB1bml0IHRlc3RzIGZyb20gdGhlIGNvbnNvbGUsIHdpbmRvdyB3b24ndCBiZSBkZWZpbmVkIHdoZW4gaW1wb3J0aW5nIHRoaXMgZmlsZVxudmFyIHdpbjtcbmlmICh0eXBlb2Yod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB2YXIgbG9jID0ge1xuICAgICAgICBob3N0bmFtZTogJydcbiAgICB9O1xuICAgIHdpbiA9IHtcbiAgICAgICAgbmF2aWdhdG9yOiB7IHVzZXJBZ2VudDogJycsIG9uTGluZTogdHJ1ZSB9LFxuICAgICAgICBkb2N1bWVudDoge1xuICAgICAgICAgICAgbG9jYXRpb246IGxvYyxcbiAgICAgICAgICAgIHJlZmVycmVyOiAnJ1xuICAgICAgICB9LFxuICAgICAgICBzY3JlZW46IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LFxuICAgICAgICBsb2NhdGlvbjogbG9jXG4gICAgfTtcbn0gZWxzZSB7XG4gICAgd2luID0gd2luZG93O1xufVxuXG52YXIgc2V0SW1tZWRpYXRlID0gd2luWydzZXRJbW1lZGlhdGUnXTtcbnZhciBidWlsdEluUHJvcCwgY3ljbGUsIHNjaGVkdWxpbmdRdWV1ZSxcbiAgICBUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgdGltZXIgPSAodHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcpID9cbiAgICAgICAgZnVuY3Rpb24gdGltZXIoZm4pIHsgcmV0dXJuIHNldEltbWVkaWF0ZShmbik7IH0gOlxuICAgICAgICBzZXRUaW1lb3V0O1xuXG4vLyBkYW1taXQsIElFOC5cbnRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCd4Jyx7fSk7XG4gICAgYnVpbHRJblByb3AgPSBmdW5jdGlvbiBidWlsdEluUHJvcChvYmosbmFtZSx2YWwsY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLG5hbWUse1xuICAgICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBjb25maWcgIT09IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH07XG59XG5jYXRjaCAoZXJyKSB7XG4gICAgYnVpbHRJblByb3AgPSBmdW5jdGlvbiBidWlsdEluUHJvcChvYmosbmFtZSx2YWwpIHtcbiAgICAgICAgb2JqW25hbWVdID0gdmFsO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG59XG5cbi8vIE5vdGU6IHVzaW5nIGEgcXVldWUgaW5zdGVhZCBvZiBhcnJheSBmb3IgZWZmaWNpZW5jeVxuc2NoZWR1bGluZ1F1ZXVlID0gKGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgIHZhciBmaXJzdCwgbGFzdCwgaXRlbTtcblxuICAgIGZ1bmN0aW9uIEl0ZW0oZm4sc2VsZikge1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMuc2VsZiA9IHNlbGY7XG4gICAgICAgIHRoaXMubmV4dCA9IHZvaWQgMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIGFkZChmbixzZWxmKSB7XG4gICAgICAgICAgICBpdGVtID0gbmV3IEl0ZW0oZm4sc2VsZik7XG4gICAgICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgICAgICAgIGxhc3QubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0ID0gaXRlbTtcbiAgICAgICAgICAgIGl0ZW0gPSB2b2lkIDA7XG4gICAgICAgIH0sXG4gICAgICAgIGRyYWluOiBmdW5jdGlvbiBkcmFpbigpIHtcbiAgICAgICAgICAgIHZhciBmID0gZmlyc3Q7XG4gICAgICAgICAgICBmaXJzdCA9IGxhc3QgPSBjeWNsZSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgd2hpbGUgKGYpIHtcbiAgICAgICAgICAgICAgICBmLmZuLmNhbGwoZi5zZWxmKTtcbiAgICAgICAgICAgICAgICBmID0gZi5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKGZuLHNlbGYpIHtcbiAgICBzY2hlZHVsaW5nUXVldWUuYWRkKGZuLHNlbGYpO1xuICAgIGlmICghY3ljbGUpIHtcbiAgICAgICAgY3ljbGUgPSB0aW1lcihzY2hlZHVsaW5nUXVldWUuZHJhaW4pO1xuICAgIH1cbn1cblxuLy8gcHJvbWlzZSBkdWNrIHR5cGluZ1xuZnVuY3Rpb24gaXNUaGVuYWJsZShvKSB7XG4gICAgdmFyIF90aGVuLCBvVHlwZSA9IHR5cGVvZiBvO1xuXG4gICAgaWYgKG8gIT09IG51bGwgJiYgKG9UeXBlID09PSAnb2JqZWN0JyB8fCBvVHlwZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgX3RoZW4gPSBvLnRoZW47XG4gICAgfVxuICAgIHJldHVybiB0eXBlb2YgX3RoZW4gPT09ICdmdW5jdGlvbicgPyBfdGhlbiA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgZm9yICh2YXIgaT0wOyBpPHRoaXMuY2hhaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm90aWZ5SXNvbGF0ZWQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IDEpID8gdGhpcy5jaGFpbltpXS5zdWNjZXNzIDogdGhpcy5jaGFpbltpXS5mYWlsdXJlLFxuICAgICAgICAgICAgdGhpcy5jaGFpbltpXVxuICAgICAgICApO1xuICAgIH1cbiAgICB0aGlzLmNoYWluLmxlbmd0aCA9IDA7XG59XG5cbi8vIE5PVEU6IFRoaXMgaXMgYSBzZXBhcmF0ZSBmdW5jdGlvbiB0byBpc29sYXRlXG4vLyB0aGUgYHRyeS4uY2F0Y2hgIHNvIHRoYXQgb3RoZXIgY29kZSBjYW4gYmVcbi8vIG9wdGltaXplZCBiZXR0ZXJcbmZ1bmN0aW9uIG5vdGlmeUlzb2xhdGVkKHNlbGYsY2IsY2hhaW4pIHtcbiAgICB2YXIgcmV0LCBfdGhlbjtcbiAgICB0cnkge1xuICAgICAgICBpZiAoY2IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjaGFpbi5yZWplY3Qoc2VsZi5tc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNiID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gc2VsZi5tc2c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXQgPSBjYi5jYWxsKHZvaWQgMCxzZWxmLm1zZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXQgPT09IGNoYWluLnByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBjaGFpbi5yZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gICAgICAgICAgICBlbHNlIGlmIChfdGhlbiA9IGlzVGhlbmFibGUocmV0KSkge1xuICAgICAgICAgICAgICAgIF90aGVuLmNhbGwocmV0LGNoYWluLnJlc29sdmUsY2hhaW4ucmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoYWluLnJlc29sdmUocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNoYWluLnJlamVjdChlcnIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgX3RoZW4sIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG4gICAgaWYgKHNlbGYudHJpZ2dlcmVkKSB7IHJldHVybjsgfVxuXG4gICAgc2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG4gICAgLy8gdW53cmFwXG4gICAgaWYgKHNlbGYuZGVmKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmLmRlZjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgICAgICAgaWYgKF90aGVuID0gaXNUaGVuYWJsZShtc2cpKSB7XG4gICAgICAgICAgICBzY2hlZHVsZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBkZWZXcmFwcGVyID0gbmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGVuLmNhbGwobXNnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlc29sdmUkKCl7IHJlc29sdmUuYXBwbHkoZGVmV3JhcHBlcixhcmd1bWVudHMpOyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gJHJlamVjdCQoKXsgcmVqZWN0LmFwcGx5KGRlZldyYXBwZXIsYXJndW1lbnRzKTsgfVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdC5jYWxsKGRlZldyYXBwZXIsZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYubXNnID0gbXNnO1xuICAgICAgICAgICAgc2VsZi5zdGF0ZSA9IDE7XG4gICAgICAgICAgICBpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGUobm90aWZ5LHNlbGYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0LmNhbGwobmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpLGVycik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWplY3QobXNnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gYWxyZWFkeSB0cmlnZ2VyZWQ/XG4gICAgaWYgKHNlbGYudHJpZ2dlcmVkKSB7IHJldHVybjsgfVxuXG4gICAgc2VsZi50cmlnZ2VyZWQgPSB0cnVlO1xuXG4gICAgLy8gdW53cmFwXG4gICAgaWYgKHNlbGYuZGVmKSB7XG4gICAgICAgIHNlbGYgPSBzZWxmLmRlZjtcbiAgICB9XG5cbiAgICBzZWxmLm1zZyA9IG1zZztcbiAgICBzZWxmLnN0YXRlID0gMjtcbiAgICBpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vdGlmeSxzZWxmKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIscmVzb2x2ZXIscmVqZWN0ZXIpIHtcbiAgICBmb3IgKHZhciBpZHg9MDsgaWR4PGFyci5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgIChmdW5jdGlvbiBJSUZFKGlkeCl7XG4gICAgICAgICAgICBDb25zdHJ1Y3Rvci5yZXNvbHZlKGFycltpZHhdKVxuICAgICAgICAgICAgICAgIC50aGVuKFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAkcmVzb2x2ZXIkKG1zZyl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlcihpZHgsbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0ZXJcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICB9KShpZHgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gTWFrZURlZldyYXBwZXIoc2VsZikge1xuICAgIHRoaXMuZGVmID0gc2VsZjtcbiAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBNYWtlRGVmKHNlbGYpIHtcbiAgICB0aGlzLnByb21pc2UgPSBzZWxmO1xuICAgIHRoaXMuc3RhdGUgPSAwO1xuICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgdGhpcy5jaGFpbiA9IFtdO1xuICAgIHRoaXMubXNnID0gdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBOcG9Qcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNbJ19fTlBPX18nXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIHByb21pc2UnKTtcbiAgICB9XG5cbiAgICAvLyBpbnN0YW5jZSBzaGFkb3dpbmcgdGhlIGluaGVyaXRlZCBcImJyYW5kXCJcbiAgICAvLyB0byBzaWduYWwgYW4gYWxyZWFkeSBcImluaXRpYWxpemVkXCIgcHJvbWlzZVxuICAgIHRoaXNbJ19fTlBPX18nXSA9IDE7XG5cbiAgICB2YXIgZGVmID0gbmV3IE1ha2VEZWYodGhpcyk7XG5cbiAgICB0aGlzWyd0aGVuJ10gPSBmdW5jdGlvbiB0aGVuKHN1Y2Nlc3MsZmFpbHVyZSkge1xuICAgICAgICB2YXIgbyA9IHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHR5cGVvZiBzdWNjZXNzID09PSAnZnVuY3Rpb24nID8gc3VjY2VzcyA6IHRydWUsXG4gICAgICAgICAgICBmYWlsdXJlOiB0eXBlb2YgZmFpbHVyZSA9PT0gJ2Z1bmN0aW9uJyA/IGZhaWx1cmUgOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICAgICAgLy8gTm90ZTogYHRoZW4oLi4pYCBpdHNlbGYgY2FuIGJlIGJvcnJvd2VkIHRvIGJlIHVzZWQgYWdhaW5zdFxuICAgICAgICAgICAgLy8gYSBkaWZmZXJlbnQgcHJvbWlzZSBjb25zdHJ1Y3RvciBmb3IgbWFraW5nIHRoZSBjaGFpbmVkIHByb21pc2UsXG4gICAgICAgICAgICAvLyBieSBzdWJzdGl0dXRpbmcgYSBkaWZmZXJlbnQgYHRoaXNgIGJpbmRpbmcuXG4gICAgICAgIG8ucHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4dHJhY3RDaGFpbihyZXNvbHZlLHJlamVjdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG8ucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgICAgICAgICBvLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIGRlZi5jaGFpbi5wdXNoKG8pO1xuXG4gICAgICAgIGlmIChkZWYuc3RhdGUgIT09IDApIHtcbiAgICAgICAgICAgIHNjaGVkdWxlKG5vdGlmeSxkZWYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG8ucHJvbWlzZTtcbiAgICB9O1xuICAgIHRoaXNbJ2NhdGNoJ10gPSBmdW5jdGlvbiAkY2F0Y2gkKGZhaWx1cmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsZmFpbHVyZSk7XG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICAgIGV4ZWN1dG9yLmNhbGwoXG4gICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICBmdW5jdGlvbiBwdWJsaWNSZXNvbHZlKG1zZyl7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZS5jYWxsKGRlZixtc2cpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHB1YmxpY1JlamVjdChtc2cpIHtcbiAgICAgICAgICAgICAgICByZWplY3QuY2FsbChkZWYsbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QuY2FsbChkZWYsZXJyKTtcbiAgICB9XG59XG5cbnZhciBQcm9taXNlUHJvdG90eXBlID0gYnVpbHRJblByb3Aoe30sJ2NvbnN0cnVjdG9yJyxOcG9Qcm9taXNlLFxuICAgIC8qY29uZmlndXJhYmxlPSovZmFsc2Vcbik7XG5cbiAgICAvLyBOb3RlOiBBbmRyb2lkIDQgY2Fubm90IHVzZSBgT2JqZWN0LmRlZmluZVByb3BlcnR5KC4uKWAgaGVyZVxuTnBvUHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlUHJvdG90eXBlO1xuXG4vLyBidWlsdC1pbiBcImJyYW5kXCIgdG8gc2lnbmFsIGFuIFwidW5pbml0aWFsaXplZFwiIHByb21pc2VcbmJ1aWx0SW5Qcm9wKFByb21pc2VQcm90b3R5cGUsJ19fTlBPX18nLDAsXG4gICAgLypjb25maWd1cmFibGU9Ki9mYWxzZVxuKTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwncmVzb2x2ZScsZnVuY3Rpb24gUHJvbWlzZSRyZXNvbHZlKG1zZykge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIC8vIG5vdGU6IGJlc3QgXCJpc1Byb21pc2VcIiBjaGVjayB0aGF0J3MgcHJhY3RpY2FsIGZvciBub3dcbiAgICBpZiAobXNnICYmIHR5cGVvZiBtc2cgPT09ICdvYmplY3QnICYmIG1zZ1snX19OUE9fXyddID09PSAxKSB7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLHJlamVjdCl7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgcmVqZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKG1zZyk7XG4gICAgfSk7XG59KTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwncmVqZWN0JyxmdW5jdGlvbiBQcm9taXNlJHJlamVjdChtc2cpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVqZWN0KG1zZyk7XG4gICAgfSk7XG59KTtcblxuYnVpbHRJblByb3AoTnBvUHJvbWlzZSwnYWxsJyxmdW5jdGlvbiBQcm9taXNlJGFsbChhcnIpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICBpZiAoVG9TdHJpbmcuY2FsbChhcnIpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKCdOb3QgYW4gYXJyYXknKSk7XG4gICAgfVxuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZXNvbHZlKFtdKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUscmVqZWN0KXtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiByZWplY3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignTm90IGEgZnVuY3Rpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoLCBtc2dzID0gQXJyYXkobGVuKSwgY291bnQgPSAwO1xuXG4gICAgICAgIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvcixhcnIsZnVuY3Rpb24gcmVzb2x2ZXIoaWR4LG1zZykge1xuICAgICAgICAgICAgbXNnc1tpZHhdID0gbXNnO1xuICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxlbikge1xuICAgICAgICAgICAgICAgIHJlc29sdmUobXNncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0scmVqZWN0KTtcbiAgICB9KTtcbn0pO1xuXG5idWlsdEluUHJvcChOcG9Qcm9taXNlLCdyYWNlJyxmdW5jdGlvbiBQcm9taXNlJHJhY2UoYXJyKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgaWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcignTm90IGFuIGFycmF5JykpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoZnVuY3Rpb24gZXhlY3V0b3IocmVzb2x2ZSxyZWplY3Qpe1xuICAgICAgICBpZiAodHlwZW9mIHJlc29sdmUgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHJlamVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdOb3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLGFycixmdW5jdGlvbiByZXNvbHZlcihpZHgsbXNnKXtcbiAgICAgICAgICAgIHJlc29sdmUobXNnKTtcbiAgICAgICAgfSxyZWplY3QpO1xuICAgIH0pO1xufSk7XG5cbnZhciBQcm9taXNlUG9seWZpbGw7XG5pZiAodHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnICYmIFByb21pc2UudG9TdHJpbmcoKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgIT09IC0xKSB7XG4gICAgUHJvbWlzZVBvbHlmaWxsID0gUHJvbWlzZTtcbn0gZWxzZSB7XG4gICAgUHJvbWlzZVBvbHlmaWxsID0gTnBvUHJvbWlzZTtcbn1cblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiwgZXFlcWVxOiBcIm9mZlwiICovXG5cbi8vIE1heGltdW0gYWxsb3dlZCBzZXNzaW9uIHJlY29yZGluZyBsZW5ndGhcbnZhciBNQVhfUkVDT1JESU5HX01TID0gMjQgKiA2MCAqIDYwICogMTAwMDsgLy8gMjQgaG91cnNcbi8vIE1heGltdW0gYWxsb3dlZCB2YWx1ZSBmb3IgbWluaW11bSBzZXNzaW9uIHJlY29yZGluZyBsZW5ndGhcbnZhciBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMgPSA4ICogMTAwMDsgLy8gOCBzZWNvbmRzXG5cbi8qXG4gKiBTYXZlZCByZWZlcmVuY2VzIHRvIGxvbmcgdmFyaWFibGUgbmFtZXMsIHNvIHRoYXQgY2xvc3VyZSBjb21waWxlciBjYW5cbiAqIG1pbmltaXplIGZpbGUgc2l6ZS5cbiAqL1xuXG52YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLFxuICAgIHNsaWNlID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ID0gT2JqUHJvdG8uaGFzT3duUHJvcGVydHksXG4gICAgd2luZG93Q29uc29sZSA9IHdpbi5jb25zb2xlLFxuICAgIG5hdmlnYXRvciA9IHdpbi5uYXZpZ2F0b3IsXG4gICAgZG9jdW1lbnQkMSA9IHdpbi5kb2N1bWVudCxcbiAgICB3aW5kb3dPcGVyYSA9IHdpbi5vcGVyYSxcbiAgICBzY3JlZW4gPSB3aW4uc2NyZWVuLFxuICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbnZhciBuYXRpdmVCaW5kID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlRm9yRWFjaCA9IEFycmF5UHJvdG8uZm9yRWFjaCxcbiAgICBuYXRpdmVJbmRleE9mID0gQXJyYXlQcm90by5pbmRleE9mLFxuICAgIG5hdGl2ZU1hcCA9IEFycmF5UHJvdG8ubWFwLFxuICAgIG5hdGl2ZUlzQXJyYXkgPSBBcnJheS5pc0FycmF5LFxuICAgIGJyZWFrZXIgPSB7fTtcblxudmFyIF8gPSB7XG4gICAgdHJpbTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9UcmltI1BvbHlmaWxsXG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcbiAgICB9XG59O1xuXG4vLyBDb25zb2xlIG92ZXJyaWRlXG52YXIgY29uc29sZSQxID0ge1xuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oLi4uKil9ICovXG4gICAgbG9nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUubG9nLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5sb2coYXJnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbiguLi4qKX0gKi9cbiAgICB3YXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgd2FybmluZzonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLndhcm4uYXBwbHkod2luZG93Q29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBfLmVhY2goYXJncywgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd0NvbnNvbGUud2FybihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKENvbmZpZy5ERUJVRyAmJiAhXy5pc1VuZGVmaW5lZCh3aW5kb3dDb25zb2xlKSAmJiB3aW5kb3dDb25zb2xlKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFsnTWl4cGFuZWwgZXJyb3I6J10uY29uY2F0KF8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvci5hcHBseSh3aW5kb3dDb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIF8uZWFjaChhcmdzLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Q29uc29sZS5lcnJvcihhcmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICAvKiogQHR5cGUge2Z1bmN0aW9uKC4uLiopfSAqL1xuICAgIGNyaXRpY2FsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKHdpbmRvd0NvbnNvbGUpICYmIHdpbmRvd0NvbnNvbGUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gWydNaXhwYW5lbCBlcnJvcjonXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yLmFwcGx5KHdpbmRvd0NvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGFyZ3MsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3dDb25zb2xlLmVycm9yKGFyZyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbG9nX2Z1bmNfd2l0aF9wcmVmaXggPSBmdW5jdGlvbihmdW5jLCBwcmVmaXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9ICdbJyArIHByZWZpeCArICddICcgKyBhcmd1bWVudHNbMF07XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnNvbGUkMSwgYXJndW1lbnRzKTtcbiAgICB9O1xufTtcbnZhciBjb25zb2xlX3dpdGhfcHJlZml4ID0gZnVuY3Rpb24ocHJlZml4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9nOiBsb2dfZnVuY193aXRoX3ByZWZpeChjb25zb2xlJDEubG9nLCBwcmVmaXgpLFxuICAgICAgICBlcnJvcjogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZSQxLmVycm9yLCBwcmVmaXgpLFxuICAgICAgICBjcml0aWNhbDogbG9nX2Z1bmNfd2l0aF9wcmVmaXgoY29uc29sZSQxLmNyaXRpY2FsLCBwcmVmaXgpXG4gICAgfTtcbn07XG5cblxuLy8gVU5ERVJTQ09SRVxuLy8gRW1iZWQgcGFydCBvZiB0aGUgVW5kZXJzY29yZSBMaWJyYXJ5XG5fLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgdmFyIGFyZ3MsIGJvdW5kO1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIH1cbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgfVxuICAgIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0b3IgPSB7fTtcbiAgICAgICAgY3Rvci5wcm90b3R5cGUgPSBmdW5jLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIHNlbGYgPSBuZXcgY3RvcigpO1xuICAgICAgICBjdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHNlbGYsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbn07XG5cbi8qKlxuICogQHBhcmFtIHsqPX0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopPX0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7T2JqZWN0PX0gY29udGV4dFxuICovXG5fLmVhY2ggPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKG9iaiA9PT0gbnVsbCB8fCBvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuYXRpdmVGb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgICAgIG9iai5mb3JFYWNoKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gb2JqICYmIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBicmVha2VyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLCBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VbcHJvcF0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG4vLyBmcm9tIGEgY29tbWVudCBvbiBodHRwOi8vZGJqLm9yZy9kYmovP3A9Mjg2XG4vLyBmYWlscyBvbiBvbmx5IG9uZSB2ZXJ5IHJhcmUgYW5kIGRlbGliZXJhdGUgY3VzdG9tIG9iamVjdDpcbi8vIHZhciBib21iID0geyB0b1N0cmluZyA6IHVuZGVmaW5lZCwgdmFsdWVPZjogZnVuY3Rpb24obykgeyByZXR1cm4gXCJmdW5jdGlvbiBCT01CQSFcIjsgfX07XG5fLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihmKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIC9eXFxzKlxcYmZ1bmN0aW9uXFxiLy50ZXN0KGYpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbl8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCAnY2FsbGVlJykpO1xufTtcblxuXy50b0FycmF5ID0gZnVuY3Rpb24oaXRlcmFibGUpIHtcbiAgICBpZiAoIWl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhYmxlLnRvQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlLnRvQXJyYXkoKTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcnJheShpdGVyYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICBpZiAoXy5pc0FyZ3VtZW50cyhpdGVyYWJsZSkpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoaXRlcmFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gXy52YWx1ZXMoaXRlcmFibGUpO1xufTtcblxuXy5tYXAgPSBmdW5jdGlvbihhcnIsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZU1hcCAmJiBhcnIubWFwID09PSBuYXRpdmVNYXApIHtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIF8uZWFjaChhcnIsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChjYWxsYmFjay5jYWxsKGNvbnRleHQsIGl0ZW0pKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbn07XG5cbl8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IGtleTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbl8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xufTtcblxuXy5pbmNsdWRlID0gZnVuY3Rpb24ob2JqLCB0YXJnZXQpIHtcbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHtcbiAgICAgICAgcmV0dXJuIG9iai5pbmRleE9mKHRhcmdldCkgIT0gLTE7XG4gICAgfVxuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChmb3VuZCB8fCAoZm91bmQgPSAodmFsdWUgPT09IHRhcmdldCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnJlYWtlcjtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn07XG5cbl8uaW5jbHVkZXMgPSBmdW5jdGlvbihzdHIsIG5lZWRsZSkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbn07XG5cbi8vIFVuZGVyc2NvcmUgQWRkb25zXG5fLmluaGVyaXQgPSBmdW5jdGlvbihzdWJjbGFzcywgc3VwZXJjbGFzcykge1xuICAgIHN1YmNsYXNzLnByb3RvdHlwZSA9IG5ldyBzdXBlcmNsYXNzKCk7XG4gICAgc3ViY2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViY2xhc3M7XG4gICAgc3ViY2xhc3Muc3VwZXJjbGFzcyA9IHN1cGVyY2xhc3MucHJvdG90eXBlO1xuICAgIHJldHVybiBzdWJjbGFzcztcbn07XG5cbl8uaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gKG9iaiA9PT0gT2JqZWN0KG9iaikgJiYgIV8uaXNBcnJheShvYmopKTtcbn07XG5cbl8uaXNFbXB0eU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5fLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xufTtcblxuXy5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG5fLmlzRGF0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgRGF0ZV0nO1xufTtcblxuXy5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgTnVtYmVyXSc7XG59O1xuXG5fLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbn07XG5cbl8uZW5jb2RlRGF0ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIGlmIChfLmlzRGF0ZSh2KSkge1xuICAgICAgICAgICAgb2JqW2tdID0gXy5mb3JtYXREYXRlKHYpO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QodikpIHtcbiAgICAgICAgICAgIG9ialtrXSA9IF8uZW5jb2RlRGF0ZXModik7IC8vIHJlY3Vyc2VcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG59O1xuXG5fLnRpbWVzdGFtcCA9IGZ1bmN0aW9uKCkge1xuICAgIERhdGUubm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiArbmV3IERhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbn07XG5cbl8uZm9ybWF0RGF0ZSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAvLyBZWVlZLU1NLUREVEhIOk1NOlNTIGluIFVUQ1xuICAgIGZ1bmN0aW9uIHBhZChuKSB7XG4gICAgICAgIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuIDogbjtcbiAgICB9XG4gICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ01vbnRoKCkgKyAxKSArICctJyArXG4gICAgICAgIHBhZChkLmdldFVUQ0RhdGUoKSkgKyAnVCcgK1xuICAgICAgICBwYWQoZC5nZXRVVENIb3VycygpKSArICc6JyArXG4gICAgICAgIHBhZChkLmdldFVUQ01pbnV0ZXMoKSkgKyAnOicgK1xuICAgICAgICBwYWQoZC5nZXRVVENTZWNvbmRzKCkpO1xufTtcblxuXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24ocCkge1xuICAgIHZhciByZXQgPSB7fTtcbiAgICBfLmVhY2gocCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoXy5pc1N0cmluZyh2KSAmJiB2Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmV0O1xufTtcblxuLypcbiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGNvcHkgb2Ygb2JqZWN0IGFmdGVyIHRydW5jYXRpbmcgaXQuICBJZlxuICogcGFzc2VkIGFuIEFycmF5IG9yIE9iamVjdCBpdCB3aWxsIGl0ZXJhdGUgdGhyb3VnaCBvYmogYW5kXG4gKiB0cnVuY2F0ZSBhbGwgdGhlIHZhbHVlcyByZWN1cnNpdmVseS5cbiAqL1xuXy50cnVuY2F0ZSA9IGZ1bmN0aW9uKG9iaiwgbGVuZ3RoKSB7XG4gICAgdmFyIHJldDtcblxuICAgIGlmICh0eXBlb2Yob2JqKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0ID0gb2JqLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChfLmlzQXJyYXkob2JqKSkge1xuICAgICAgICByZXQgPSBbXTtcbiAgICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICByZXQucHVzaChfLnRydW5jYXRlKHZhbCwgbGVuZ3RoKSk7XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChvYmopKSB7XG4gICAgICAgIHJldCA9IHt9O1xuICAgICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICAgICAgcmV0W2tleV0gPSBfLnRydW5jYXRlKHZhbCwgbGVuZ3RoKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gb2JqO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG59O1xuXG5fLkpTT05FbmNvZGUgPSAoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1peGVkX3ZhbCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBtaXhlZF92YWw7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgdmFyIGVzY2FwYWJsZSA9IC9bXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbiAgICAgICAgICAgIHZhciBtZXRhID0geyAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAgICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAgICAgICAgICdcXHQnOiAnXFxcXHQnLFxuICAgICAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAgICAgICAgICdcXHInOiAnXFxcXHInLFxuICAgICAgICAgICAgICAgICdcIic6ICdcXFxcXCInLFxuICAgICAgICAgICAgICAgICdcXFxcJzogJ1xcXFxcXFxcJ1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/XG4gICAgICAgICAgICAgICAgJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYyA9IG1ldGFbYV07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYyA9PT0gJ3N0cmluZycgPyBjIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgICAgIH0pICsgJ1wiJyA6XG4gICAgICAgICAgICAgICAgJ1wiJyArIHN0cmluZyArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHN0ciA9IGZ1bmN0aW9uKGtleSwgaG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgZ2FwID0gJyc7XG4gICAgICAgICAgICB2YXIgaW5kZW50ID0gJyAgICAnO1xuICAgICAgICAgICAgdmFyIGkgPSAwOyAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICAgICAgdmFyIGsgPSAnJzsgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgICAgICB2YXIgdiA9ICcnOyAvLyBUaGUgbWVtYmVyIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgICB2YXIgbWluZCA9IGdhcDtcbiAgICAgICAgICAgIHZhciBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBob2xkZXJba2V5XTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGhhcyBhIHRvSlNPTiBtZXRob2QsIGNhbGwgaXQgdG8gb2J0YWluIGEgcmVwbGFjZW1lbnQgdmFsdWUuXG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50b0pTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGF0IGhhcHBlbnMgbmV4dCBkZXBlbmRzIG9uIHRoZSB2YWx1ZSdzIHR5cGUuXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBxdW90ZSh2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudWxsJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgcmVtb3RlIGNoYW5jZSB0aGF0IHRoaXMgZ2V0cyBmaXhlZCBzb21lZGF5LlxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHR5cGUgaXMgJ29iamVjdCcsIHdlIG1pZ2h0IGJlIGRlYWxpbmcgd2l0aCBhbiBvYmplY3Qgb3IgYW4gYXJyYXkgb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbnVsbC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRHVlIHRvIGEgc3BlY2lmaWNhdGlvbiBibHVuZGVyIGluIEVDTUFTY3JpcHQsIHR5cGVvZiBudWxsIGlzICdvYmplY3QnLFxuICAgICAgICAgICAgICAgICAgICAvLyBzbyB3YXRjaCBvdXQgZm9yIHRoYXQgY2FzZS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2UgYW4gYXJyYXkgdG8gaG9sZCB0aGUgcGFydGlhbCByZXN1bHRzIG9mIHN0cmluZ2lmeWluZyB0aGlzIG9iamVjdCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIElzIHRoZSB2YWx1ZSBhbiBhcnJheT9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHZhbHVlIGlzIGFuIGFycmF5LiBTdHJpbmdpZnkgZXZlcnkgZWxlbWVudC4gVXNlIG51bGwgYXMgYSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG5vbi1KU09OIHZhbHVlcy5cblxuICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kIHdyYXAgdGhlbSBpblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAnW10nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYXAgPyAnW1xcbicgKyBnYXAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmQgKyAnXScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWycgKyBwYXJ0aWFsLmpvaW4oJywnKSArICddJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuICAgICAgICAgICAgICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhcCA/ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluZCArICd9JyA6ICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBNYWtlIGEgZmFrZSByb290IG9iamVjdCBjb250YWluaW5nIG91ciB2YWx1ZSB1bmRlciB0aGUga2V5IG9mICcnLlxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgICAgICByZXR1cm4gc3RyKCcnLCB7XG4gICAgICAgICAgICAnJzogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvbWFzdGVyL2pzb25fcGFyc2UuanNcbiAqIFNsaWdodGx5IG1vZGlmaWVkIHRvIHRocm93IGEgcmVhbCBFcnJvciByYXRoZXIgdGhhbiBhIFBPSk9cbiAqL1xuXy5KU09ORGVjb2RlID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgICAgICBjaCwgLy8gVGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICAgICAnXCInOiAnXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICAgICAnLyc6ICcvJyxcbiAgICAgICAgICAgICdiJzogJ1xcYicsXG4gICAgICAgICAgICAnZic6ICdcXGYnLFxuICAgICAgICAgICAgJ24nOiAnXFxuJyxcbiAgICAgICAgICAgICdyJzogJ1xccicsXG4gICAgICAgICAgICAndCc6ICdcXHQnXG4gICAgICAgIH0sXG4gICAgICAgIHRleHQsXG4gICAgICAgIGVycm9yID0gZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgdmFyIGUgPSBuZXcgU3ludGF4RXJyb3IobSk7XG4gICAgICAgICAgICBlLmF0ID0gYXQ7XG4gICAgICAgICAgICBlLnRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfSxcbiAgICAgICAgbmV4dCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgaWYgKGMgJiYgYyAhPT0gY2gpIHtcbiAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgXFwnJyArIGMgKyAnXFwnIGluc3RlYWQgb2YgXFwnJyArIGNoICsgJ1xcJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgICAgIGF0ICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gUGFyc2UgYSBudW1iZXIgdmFsdWUuXG4gICAgICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgICAgICBuZXh0KCctJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2ggPT09ICdlJyB8fCBjaCA9PT0gJ0UnKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICctJyB8fCBjaCA9PT0gJysnKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBudW1iZXIgPSArc3RyaW5nO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoJ0JhZCBudW1iZXInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBzdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKGNoID09PSAnXCInKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXFxcXCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNGaW5pdGUoaGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWZmZmYgPSB1ZmZmZiAqIDE2ICsgaGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlc2NhcGVlW2NoXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBzdHJpbmcnKTtcbiAgICAgICAgfSxcbiAgICAgICAgd2hpdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZS5cbiAgICAgICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdvcmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHRydWUsIGZhbHNlLCBvciBudWxsLlxuICAgICAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCd0Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdlJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCdmJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdzJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhc2UgJ24nOlxuICAgICAgICAgICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgXCInICsgY2ggKyAnXCInKTtcbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWUsIC8vIFBsYWNlaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG4gICAgICAgIGFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5OyAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnXScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoJ0JhZCBhcnJheScpO1xuICAgICAgICB9LFxuICAgICAgICBvYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlIGFuIG9iamVjdCB2YWx1ZS5cbiAgICAgICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICAgICAgb2JqZWN0ID0ge307XG5cbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0OyAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVycm9yKCdCYWQgb2JqZWN0Jyk7XG4gICAgICAgIH07XG5cbiAgICB2YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLFxuICAgICAgICAvLyBhIG51bWJlciwgb3IgYSB3b3JkLlxuICAgICAgICB3aGl0ZSgpO1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgICAgICAgICBjYXNlICdbJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nKCk7XG4gICAgICAgICAgICBjYXNlICctJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGVcbiAgICAvLyBhYm92ZSBmdW5jdGlvbnMgYW5kIHZhcmlhYmxlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgICAgdGV4dCA9IHNvdXJjZTtcbiAgICAgICAgYXQgPSAwO1xuICAgICAgICBjaCA9ICcgJztcbiAgICAgICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgaWYgKGNoKSB7XG4gICAgICAgICAgICBlcnJvcignU3ludGF4IGVycm9yJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59KSgpO1xuXG5fLmJhc2U2NEVuY29kZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgYjY0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbiAgICB2YXIgbzEsIG8yLCBvMywgaDEsIGgyLCBoMywgaDQsIGJpdHMsIGkgPSAwLFxuICAgICAgICBhYyA9IDAsXG4gICAgICAgIGVuYyA9ICcnLFxuICAgICAgICB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YSA9IF8udXRmOEVuY29kZShkYXRhKTtcblxuICAgIGRvIHsgLy8gcGFjayB0aHJlZSBvY3RldHMgaW50byBmb3VyIGhleGV0c1xuICAgICAgICBvMSA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMiA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuICAgICAgICBvMyA9IGRhdGEuY2hhckNvZGVBdChpKyspO1xuXG4gICAgICAgIGJpdHMgPSBvMSA8PCAxNiB8IG8yIDw8IDggfCBvMztcblxuICAgICAgICBoMSA9IGJpdHMgPj4gMTggJiAweDNmO1xuICAgICAgICBoMiA9IGJpdHMgPj4gMTIgJiAweDNmO1xuICAgICAgICBoMyA9IGJpdHMgPj4gNiAmIDB4M2Y7XG4gICAgICAgIGg0ID0gYml0cyAmIDB4M2Y7XG5cbiAgICAgICAgLy8gdXNlIGhleGV0cyB0byBpbmRleCBpbnRvIGI2NCwgYW5kIGFwcGVuZCByZXN1bHQgdG8gZW5jb2RlZCBzdHJpbmdcbiAgICAgICAgdG1wX2FyclthYysrXSA9IGI2NC5jaGFyQXQoaDEpICsgYjY0LmNoYXJBdChoMikgKyBiNjQuY2hhckF0KGgzKSArIGI2NC5jaGFyQXQoaDQpO1xuICAgIH0gd2hpbGUgKGkgPCBkYXRhLmxlbmd0aCk7XG5cbiAgICBlbmMgPSB0bXBfYXJyLmpvaW4oJycpO1xuXG4gICAgc3dpdGNoIChkYXRhLmxlbmd0aCAlIDMpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0yKSArICc9PSc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgZW5jID0gZW5jLnNsaWNlKDAsIC0xKSArICc9JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBlbmM7XG59O1xuXG5fLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICBzdHJpbmcgPSAoc3RyaW5nICsgJycpLnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcblxuICAgIHZhciB1dGZ0ZXh0ID0gJycsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQ7XG4gICAgdmFyIHN0cmluZ2wgPSAwLFxuICAgICAgICBuO1xuXG4gICAgc3RhcnQgPSBlbmQgPSAwO1xuICAgIHN0cmluZ2wgPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgZm9yIChuID0gMDsgbiA8IHN0cmluZ2w7IG4rKykge1xuICAgICAgICB2YXIgYzEgPSBzdHJpbmcuY2hhckNvZGVBdChuKTtcbiAgICAgICAgdmFyIGVuYyA9IG51bGw7XG5cbiAgICAgICAgaWYgKGMxIDwgMTI4KSB7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfSBlbHNlIGlmICgoYzEgPiAxMjcpICYmIChjMSA8IDIwNDgpKSB7XG4gICAgICAgICAgICBlbmMgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjMSA+PiA2KSB8IDE5MiwgKGMxICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVuYyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGMxID4+IDEyKSB8IDIyNCwgKChjMSA+PiA2KSAmIDYzKSB8IDEyOCwgKGMxICYgNjMpIHwgMTI4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5jICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB1dGZ0ZXh0ICs9IHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGZ0ZXh0ICs9IGVuYztcbiAgICAgICAgICAgIHN0YXJ0ID0gZW5kID0gbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW5kID4gc3RhcnQpIHtcbiAgICAgICAgdXRmdGV4dCArPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBzdHJpbmcubGVuZ3RoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmdGV4dDtcbn07XG5cbl8uVVVJRCA9IChmdW5jdGlvbigpIHtcblxuICAgIC8vIFRpbWUtYmFzZWQgZW50cm9weVxuICAgIHZhciBUID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0aW1lID0gMSAqIG5ldyBEYXRlKCk7IC8vIGNyb3NzLWJyb3dzZXIgdmVyc2lvbiBvZiBEYXRlLm5vdygpXG4gICAgICAgIHZhciB0aWNrcztcbiAgICAgICAgaWYgKHdpbi5wZXJmb3JtYW5jZSAmJiB3aW4ucGVyZm9ybWFuY2Uubm93KSB7XG4gICAgICAgICAgICB0aWNrcyA9IHdpbi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBidXN5IGxvb3BcbiAgICAgICAgICAgIHRpY2tzID0gMDtcblxuICAgICAgICAgICAgLy8gdGhpcyB3aGlsZSBsb29wIGZpZ3VyZXMgaG93IG1hbnkgYnJvd3NlciB0aWNrcyBnbyBieVxuICAgICAgICAgICAgLy8gYmVmb3JlIDEqbmV3IERhdGUoKSByZXR1cm5zIGEgbmV3IG51bWJlciwgaWUgdGhlIGFtb3VudFxuICAgICAgICAgICAgLy8gb2YgdGlja3MgdGhhdCBnbyBieSBwZXIgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgIHdoaWxlICh0aW1lID09IDEgKiBuZXcgRGF0ZSgpKSB7XG4gICAgICAgICAgICAgICAgdGlja3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGltZS50b1N0cmluZygxNikgKyBNYXRoLmZsb29yKHRpY2tzKS50b1N0cmluZygxNik7XG4gICAgfTtcblxuICAgIC8vIE1hdGguUmFuZG9tIGVudHJvcHlcbiAgICB2YXIgUiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygxNikucmVwbGFjZSgnLicsICcnKTtcbiAgICB9O1xuXG4gICAgLy8gVXNlciBhZ2VudCBlbnRyb3B5XG4gICAgLy8gVGhpcyBmdW5jdGlvbiB0YWtlcyB0aGUgdXNlciBhZ2VudCBzdHJpbmcsIGFuZCB0aGVuIHhvcnNcbiAgICAvLyB0b2dldGhlciBlYWNoIHNlcXVlbmNlIG9mIDggYnl0ZXMuICBUaGlzIHByb2R1Y2VzIGEgZmluYWxcbiAgICAvLyBzZXF1ZW5jZSBvZiA4IGJ5dGVzIHdoaWNoIGl0IHJldHVybnMgYXMgaGV4LlxuICAgIHZhciBVQSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdWEgPSB1c2VyQWdlbnQsXG4gICAgICAgICAgICBpLCBjaCwgYnVmZmVyID0gW10sXG4gICAgICAgICAgICByZXQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHhvcihyZXN1bHQsIGJ5dGVfYXJyYXkpIHtcbiAgICAgICAgICAgIHZhciBqLCB0bXAgPSAwO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGJ5dGVfYXJyYXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0bXAgfD0gKGJ1ZmZlcltqXSA8PCBqICogOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0IF4gdG1wO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHVhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjaCA9IHVhLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBidWZmZXIudW5zaGlmdChjaCAmIDB4RkYpO1xuICAgICAgICAgICAgaWYgKGJ1ZmZlci5sZW5ndGggPj0gNCkge1xuICAgICAgICAgICAgICAgIHJldCA9IHhvcihyZXQsIGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldCA9IHhvcihyZXQsIGJ1ZmZlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0LnRvU3RyaW5nKDE2KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2UgPSAoc2NyZWVuLmhlaWdodCAqIHNjcmVlbi53aWR0aCkudG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gKFQoKSArICctJyArIFIoKSArICctJyArIFVBKCkgKyAnLScgKyBzZSArICctJyArIFQoKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8vIF8uaXNCbG9ja2VkVUEoKVxuLy8gVGhpcyBpcyB0byBibG9jayB2YXJpb3VzIHdlYiBzcGlkZXJzIGZyb20gZXhlY3V0aW5nIG91ciBKUyBhbmRcbi8vIHNlbmRpbmcgZmFsc2UgdHJhY2tpbmcgZGF0YVxudmFyIEJMT0NLRURfVUFfU1RSUyA9IFtcbiAgICAnYWhyZWZzYm90JyxcbiAgICAnYWhyZWZzc2l0ZWF1ZGl0JyxcbiAgICAnYmFpZHVzcGlkZXInLFxuICAgICdiaW5nYm90JyxcbiAgICAnYmluZ3ByZXZpZXcnLFxuICAgICdjaHJvbWUtbGlnaHRob3VzZScsXG4gICAgJ2ZhY2Vib29rZXh0ZXJuYWwnLFxuICAgICdwZXRhbGJvdCcsXG4gICAgJ3BpbnRlcmVzdCcsXG4gICAgJ3NjcmVhbWluZyBmcm9nJyxcbiAgICAneWFob28hIHNsdXJwJyxcbiAgICAneWFuZGV4Ym90JyxcblxuICAgIC8vIGEgd2hvbGUgYnVuY2ggb2YgZ29vZy1zcGVjaWZpYyBjcmF3bGVyc1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3NlYXJjaC9kb2NzL2FkdmFuY2VkL2NyYXdsaW5nL292ZXJ2aWV3LWdvb2dsZS1jcmF3bGVyc1xuICAgICdhZHNib3QtZ29vZ2xlJyxcbiAgICAnYXBpcy1nb29nbGUnLFxuICAgICdkdXBsZXh3ZWItZ29vZ2xlJyxcbiAgICAnZmVlZGZldGNoZXItZ29vZ2xlJyxcbiAgICAnZ29vZ2xlIGZhdmljb24nLFxuICAgICdnb29nbGUgd2ViIHByZXZpZXcnLFxuICAgICdnb29nbGUtcmVhZC1hbG91ZCcsXG4gICAgJ2dvb2dsZWJvdCcsXG4gICAgJ2dvb2dsZXdlYmxpZ2h0JyxcbiAgICAnbWVkaWFwYXJ0bmVycy1nb29nbGUnLFxuICAgICdzdG9yZWJvdC1nb29nbGUnXG5dO1xuXy5pc0Jsb2NrZWRVQSA9IGZ1bmN0aW9uKHVhKSB7XG4gICAgdmFyIGk7XG4gICAgdWEgPSB1YS50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBCTE9DS0VEX1VBX1NUUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoQkxPQ0tFRF9VQV9TVFJTW2ldKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q9fSBmb3JtZGF0YVxuICogQHBhcmFtIHtzdHJpbmc9fSBhcmdfc2VwYXJhdG9yXG4gKi9cbl8uSFRUUEJ1aWxkUXVlcnkgPSBmdW5jdGlvbihmb3JtZGF0YSwgYXJnX3NlcGFyYXRvcikge1xuICAgIHZhciB1c2VfdmFsLCB1c2Vfa2V5LCB0bXBfYXJyID0gW107XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZChhcmdfc2VwYXJhdG9yKSkge1xuICAgICAgICBhcmdfc2VwYXJhdG9yID0gJyYnO1xuICAgIH1cblxuICAgIF8uZWFjaChmb3JtZGF0YSwgZnVuY3Rpb24odmFsLCBrZXkpIHtcbiAgICAgICAgdXNlX3ZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwudG9TdHJpbmcoKSk7XG4gICAgICAgIHVzZV9rZXkgPSBlbmNvZGVVUklDb21wb25lbnQoa2V5KTtcbiAgICAgICAgdG1wX2Fyclt0bXBfYXJyLmxlbmd0aF0gPSB1c2Vfa2V5ICsgJz0nICsgdXNlX3ZhbDtcbiAgICB9KTtcblxuICAgIHJldHVybiB0bXBfYXJyLmpvaW4oYXJnX3NlcGFyYXRvcik7XG59O1xuXG5fLmdldFF1ZXJ5UGFyYW0gPSBmdW5jdGlvbih1cmwsIHBhcmFtKSB7XG4gICAgLy8gRXhwZWN0cyBhIHJhdyBVUkxcblxuICAgIHBhcmFtID0gcGFyYW0ucmVwbGFjZSgvW1tdL2csICdcXFxcWycpLnJlcGxhY2UoL1tcXF1dL2csICdcXFxcXScpO1xuICAgIHZhciByZWdleFMgPSAnW1xcXFw/Jl0nICsgcGFyYW0gKyAnPShbXiYjXSopJyxcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4UyksXG4gICAgICAgIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gICAgaWYgKHJlc3VsdHMgPT09IG51bGwgfHwgKHJlc3VsdHMgJiYgdHlwZW9mKHJlc3VsdHNbMV0pICE9PSAnc3RyaW5nJyAmJiByZXN1bHRzWzFdLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZXN1bHRzWzFdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ1NraXBwaW5nIGRlY29kaW5nIGZvciBtYWxmb3JtZWQgcXVlcnkgcGFyYW06ICcgKyByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgfVxufTtcblxuXG4vLyBfLmNvb2tpZVxuLy8gTWV0aG9kcyBwYXJ0aWFsbHkgYm9ycm93ZWQgZnJvbSBxdWlya3Ntb2RlLm9yZy9qcy9jb29raWVzLmh0bWxcbl8uY29va2llID0ge1xuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgdmFyIGNhID0gZG9jdW1lbnQkMS5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGMgPSBjYVtpXTtcbiAgICAgICAgICAgIHdoaWxlIChjLmNoYXJBdCgwKSA9PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChjLnN1YnN0cmluZyhuYW1lRVEubGVuZ3RoLCBjLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICBwYXJzZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgY29va2llO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29va2llID0gXy5KU09ORGVjb2RlKF8uY29va2llLmdldChuYW1lKSkgfHwge307XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb29raWU7XG4gICAgfSxcblxuICAgIHNldF9zZWNvbmRzOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgc2Vjb25kcywgaXNfY3Jvc3Nfc3ViZG9tYWluLCBpc19zZWN1cmUsIGlzX2Nyb3NzX3NpdGUsIGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICB2YXIgY2RvbWFpbiA9ICcnLFxuICAgICAgICAgICAgZXhwaXJlcyA9ICcnLFxuICAgICAgICAgICAgc2VjdXJlID0gJyc7XG5cbiAgICAgICAgaWYgKGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICAgICAgY2RvbWFpbiA9ICc7IGRvbWFpbj0nICsgZG9tYWluX292ZXJyaWRlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2Nyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGV4dHJhY3RfZG9tYWluKGRvY3VtZW50JDEubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgY2RvbWFpbiA9IGRvbWFpbiA/ICc7IGRvbWFpbj0uJyArIGRvbWFpbiA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlY29uZHMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChzZWNvbmRzICogMTAwMCkpO1xuICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19jcm9zc19zaXRlKSB7XG4gICAgICAgICAgICBpc19zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdXJlID0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3NlY3VyZSkge1xuICAgICAgICAgICAgc2VjdXJlICs9ICc7IHNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudCQxLmNvb2tpZSA9IG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpICsgZXhwaXJlcyArICc7IHBhdGg9LycgKyBjZG9tYWluICsgc2VjdXJlO1xuICAgIH0sXG5cbiAgICBzZXQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCBkYXlzLCBpc19jcm9zc19zdWJkb21haW4sIGlzX3NlY3VyZSwgaXNfY3Jvc3Nfc2l0ZSwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIHZhciBjZG9tYWluID0gJycsIGV4cGlyZXMgPSAnJywgc2VjdXJlID0gJyc7XG5cbiAgICAgICAgaWYgKGRvbWFpbl9vdmVycmlkZSkge1xuICAgICAgICAgICAgY2RvbWFpbiA9ICc7IGRvbWFpbj0nICsgZG9tYWluX292ZXJyaWRlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzX2Nyb3NzX3N1YmRvbWFpbikge1xuICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGV4dHJhY3RfZG9tYWluKGRvY3VtZW50JDEubG9jYXRpb24uaG9zdG5hbWUpO1xuICAgICAgICAgICAgY2RvbWFpbiA9IGRvbWFpbiA/ICc7IGRvbWFpbj0uJyArIGRvbWFpbiA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRheXMpIHtcbiAgICAgICAgICAgIHZhciBkYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGRhdGUuc2V0VGltZShkYXRlLmdldFRpbWUoKSArIChkYXlzICogMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgICAgICAgZXhwaXJlcyA9ICc7IGV4cGlyZXM9JyArIGRhdGUudG9HTVRTdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19jcm9zc19zaXRlKSB7XG4gICAgICAgICAgICBpc19zZWN1cmUgPSB0cnVlO1xuICAgICAgICAgICAgc2VjdXJlID0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3NlY3VyZSkge1xuICAgICAgICAgICAgc2VjdXJlICs9ICc7IHNlY3VyZSc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3X2Nvb2tpZV92YWwgPSBuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSArIGV4cGlyZXMgKyAnOyBwYXRoPS8nICsgY2RvbWFpbiArIHNlY3VyZTtcbiAgICAgICAgZG9jdW1lbnQkMS5jb29raWUgPSBuZXdfY29va2llX3ZhbDtcbiAgICAgICAgcmV0dXJuIG5ld19jb29raWVfdmFsO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgZG9tYWluX292ZXJyaWRlKSB7XG4gICAgICAgIF8uY29va2llLnNldChuYW1lLCAnJywgLTEsIGlzX2Nyb3NzX3N1YmRvbWFpbiwgZmFsc2UsIGZhbHNlLCBkb21haW5fb3ZlcnJpZGUpO1xuICAgIH1cbn07XG5cbnZhciBfbG9jYWxTdG9yYWdlU3VwcG9ydGVkID0gbnVsbDtcbnZhciBsb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgPSBmdW5jdGlvbihzdG9yYWdlLCBmb3JjZUNoZWNrKSB7XG4gICAgaWYgKF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQgIT09IG51bGwgJiYgIWZvcmNlQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIF9sb2NhbFN0b3JhZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgdmFyIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHN0b3JhZ2UgfHwgd2luLmxvY2FsU3RvcmFnZTtcbiAgICAgICAgdmFyIGtleSA9ICdfX21wbHNzXycgKyBjaGVhcF9ndWlkKDgpLFxuICAgICAgICAgICAgdmFsID0gJ3h5eic7XG4gICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCk7XG4gICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5KSAhPT0gdmFsKSB7XG4gICAgICAgICAgICBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgX2xvY2FsU3RvcmFnZVN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbiAgICByZXR1cm4gc3VwcG9ydGVkO1xufTtcblxuLy8gXy5sb2NhbFN0b3JhZ2Vcbl8ubG9jYWxTdG9yYWdlID0ge1xuICAgIGlzX3N1cHBvcnRlZDogZnVuY3Rpb24oZm9yY2VfY2hlY2spIHtcbiAgICAgICAgdmFyIHN1cHBvcnRlZCA9IGxvY2FsU3RvcmFnZVN1cHBvcnRlZChudWxsLCBmb3JjZV9jaGVjayk7XG4gICAgICAgIGlmICghc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ2xvY2FsU3RvcmFnZSB1bnN1cHBvcnRlZDsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZSBzdG9yZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfSxcblxuICAgIGVycm9yOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdsb2NhbFN0b3JhZ2UgZXJyb3I6ICcgKyBtc2cpO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3aW4ubG9jYWxTdG9yYWdlLmdldEl0ZW0obmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgcGFyc2U6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBfLkpTT05EZWNvZGUoXy5sb2NhbFN0b3JhZ2UuZ2V0KG5hbWUpKSB8fCB7fTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBub29wXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbi5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHdpbi5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfLmxvY2FsU3RvcmFnZS5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXy5yZWdpc3Rlcl9ldmVudCA9IChmdW5jdGlvbigpIHtcbiAgICAvLyB3cml0dGVuIGJ5IERlYW4gRWR3YXJkcywgMjAwNVxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBUaW5vIFppamRlbCAtIGNyaXNwQHhzNGFsbC5ubFxuICAgIC8vIHdpdGggaW5wdXQgZnJvbSBDYXJsIFN2ZXJyZSAtIG1haWxAY2FybHN2ZXJyZS5jb21cbiAgICAvLyB3aXRoIGlucHV0IGZyb20gTWl4cGFuZWxcbiAgICAvLyBodHRwOi8vZGVhbi5lZHdhcmRzLm5hbWUvd2VibG9nLzIwMDUvMTAvYWRkLWV2ZW50L1xuICAgIC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzE5MzA0NDBcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKC4uLiopfSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gb2xkU2Nob29sXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gdXNlQ2FwdHVyZVxuICAgICAqL1xuICAgIHZhciByZWdpc3Rlcl9ldmVudCA9IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIsIG9sZFNjaG9vbCwgdXNlQ2FwdHVyZSkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5lcnJvcignTm8gdmFsaWQgZWxlbWVudCBwcm92aWRlZCB0byByZWdpc3Rlcl9ldmVudCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciAmJiAhb2xkU2Nob29sKSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgISF1c2VDYXB0dXJlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvbnR5cGUgPSAnb24nICsgdHlwZTtcbiAgICAgICAgICAgIHZhciBvbGRfaGFuZGxlciA9IGVsZW1lbnRbb250eXBlXTsgLy8gY2FuIGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgZWxlbWVudFtvbnR5cGVdID0gbWFrZUhhbmRsZXIoZWxlbWVudCwgaGFuZGxlciwgb2xkX2hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIG1ha2VIYW5kbGVyKGVsZW1lbnQsIG5ld19oYW5kbGVyLCBvbGRfaGFuZGxlcnMpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBldmVudCB8fCBmaXhFdmVudCh3aW4uZXZlbnQpO1xuXG4gICAgICAgICAgICAvLyB0aGlzIGJhc2ljYWxseSBoYXBwZW5zIGluIGZpcmVmb3ggd2hlbmV2ZXIgYW5vdGhlciBzY3JpcHRcbiAgICAgICAgICAgIC8vIG92ZXJ3cml0ZXMgdGhlIG9ubG9hZCBjYWxsYmFjayBhbmQgZG9lc24ndCBwYXNzIHRoZSBldmVudFxuICAgICAgICAgICAgLy8gb2JqZWN0IHRvIHByZXZpb3VzbHkgZGVmaW5lZCBjYWxsYmFja3MuICBBbGwgdGhlIGJyb3dzZXJzXG4gICAgICAgICAgICAvLyB0aGF0IGRvbid0IGRlZmluZSB3aW5kb3cuZXZlbnQgaW1wbGVtZW50IGFkZEV2ZW50TGlzdGVuZXJcbiAgICAgICAgICAgIC8vIHNvIHRoZSBkb21fbG9hZGVkIGhhbmRsZXIgd2lsbCBzdGlsbCBiZSBmaXJlZCBhcyB1c3VhbC5cbiAgICAgICAgICAgIGlmICghZXZlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRfcmVzdWx0LCBuZXdfcmVzdWx0O1xuXG4gICAgICAgICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9sZF9oYW5kbGVycykpIHtcbiAgICAgICAgICAgICAgICBvbGRfcmVzdWx0ID0gb2xkX2hhbmRsZXJzKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld19yZXN1bHQgPSBuZXdfaGFuZGxlci5jYWxsKGVsZW1lbnQsIGV2ZW50KTtcblxuICAgICAgICAgICAgaWYgKChmYWxzZSA9PT0gb2xkX3Jlc3VsdCkgfHwgKGZhbHNlID09PSBuZXdfcmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpeEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQgPSBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdDtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuICAgIGZpeEV2ZW50LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9O1xuICAgIGZpeEV2ZW50LnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfTtcblxuICAgIHJldHVybiByZWdpc3Rlcl9ldmVudDtcbn0pKCk7XG5cblxudmFyIFRPS0VOX01BVENIX1JFR0VYID0gbmV3IFJlZ0V4cCgnXihcXFxcdyopXFxcXFsoXFxcXHcrKShbPX5cXFxcfFxcXFxeXFxcXCRcXFxcKl0/KT0/XCI/KFteXFxcXF1cIl0qKVwiP1xcXFxdJCcpO1xuXG5fLmRvbV9xdWVyeSA9IChmdW5jdGlvbigpIHtcbiAgICAvKiBkb2N1bWVudC5nZXRFbGVtZW50c0J5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgLSByZXR1cm5zIGFuIGFycmF5IG9mIGVsZW1lbnQgb2JqZWN0cyBmcm9tIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gICAgbWF0Y2hpbmcgdGhlIENTUyBzZWxlY3Rvci4gU2VsZWN0b3JzIGNhbiBjb250YWluIGVsZW1lbnQgbmFtZXMsXG4gICAgY2xhc3MgbmFtZXMgYW5kIGlkcyBhbmQgY2FuIGJlIG5lc3RlZC4gRm9yIGV4YW1wbGU6XG5cbiAgICBlbGVtZW50cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlTZWxlY3RvcignZGl2I21haW4gcCBhLmV4dGVybmFsJylcblxuICAgIFdpbGwgcmV0dXJuIGFuIGFycmF5IG9mIGFsbCAnYScgZWxlbWVudHMgd2l0aCAnZXh0ZXJuYWwnIGluIHRoZWlyXG4gICAgY2xhc3MgYXR0cmlidXRlIHRoYXQgYXJlIGNvbnRhaW5lZCBpbnNpZGUgJ3AnIGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgY29udGFpbmVkIGluc2lkZSB0aGUgJ2RpdicgZWxlbWVudCB3aGljaCBoYXMgaWQ9XCJtYWluXCJcblxuICAgIE5ldyBpbiB2ZXJzaW9uIDAuNDogU3VwcG9ydCBmb3IgQ1NTMiBhbmQgQ1NTMyBhdHRyaWJ1dGUgc2VsZWN0b3JzOlxuICAgIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXG4gICAgVmVyc2lvbiAwLjQgLSBTaW1vbiBXaWxsaXNvbiwgTWFyY2ggMjV0aCAyMDAzXG4gICAgLS0gV29ya3MgaW4gUGhvZW5peCAwLjUsIE1vemlsbGEgMS4zLCBPcGVyYSA3LCBJbnRlcm5ldCBFeHBsb3JlciA2LCBJbnRlcm5ldCBFeHBsb3JlciA1IG9uIFdpbmRvd3NcbiAgICAtLSBPcGVyYSA3IGZhaWxzXG5cbiAgICBWZXJzaW9uIDAuNSAtIENhcmwgU3ZlcnJlLCBKYW4gN3RoIDIwMTNcbiAgICAtLSBOb3cgdXNlcyBqUXVlcnktZXNxdWUgYGhhc0NsYXNzYCBmb3IgdGVzdGluZyBjbGFzcyBuYW1lXG4gICAgZXF1YWxpdHkuICBUaGlzIGZpeGVzIGEgYnVnIHJlbGF0ZWQgdG8gJy0nIGNoYXJhY3RlcnMgYmVpbmdcbiAgICBjb25zaWRlcmVkIG5vdCBwYXJ0IG9mIGEgJ3dvcmQnIGluIHJlZ2V4LlxuICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRBbGxDaGlsZHJlbihlKSB7XG4gICAgICAgIC8vIFJldHVybnMgYWxsIGNoaWxkcmVuIG9mIGVsZW1lbnQuIFdvcmthcm91bmQgcmVxdWlyZWQgZm9yIElFNS9XaW5kb3dzLiBVZ2guXG4gICAgICAgIHJldHVybiBlLmFsbCA/IGUuYWxsIDogZS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpO1xuICAgIH1cblxuICAgIHZhciBiYWRfd2hpdGVzcGFjZSA9IC9bXFx0XFxyXFxuXS9nO1xuXG4gICAgZnVuY3Rpb24gaGFzQ2xhc3MoZWxlbSwgc2VsZWN0b3IpIHtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9ICcgJyArIHNlbGVjdG9yICsgJyAnO1xuICAgICAgICByZXR1cm4gKCgnICcgKyBlbGVtLmNsYXNzTmFtZSArICcgJykucmVwbGFjZShiYWRfd2hpdGVzcGFjZSwgJyAnKS5pbmRleE9mKGNsYXNzTmFtZSkgPj0gMCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RWxlbWVudHNCeVNlbGVjdG9yKHNlbGVjdG9yKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZmFpbCBncmFjZWZ1bGx5IGluIGxlc3NlciBicm93c2Vyc1xuICAgICAgICBpZiAoIWRvY3VtZW50JDEuZ2V0RWxlbWVudHNCeVRhZ05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTcGxpdCBzZWxlY3RvciBpbiB0byB0b2tlbnNcbiAgICAgICAgdmFyIHRva2VucyA9IHNlbGVjdG9yLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciB0b2tlbiwgYml0cywgdGFnTmFtZSwgZm91bmQsIGZvdW5kQ291bnQsIGksIGosIGssIGVsZW1lbnRzLCBjdXJyZW50Q29udGV4dEluZGV4O1xuICAgICAgICB2YXIgY3VycmVudENvbnRleHQgPSBbZG9jdW1lbnQkMV07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldLnJlcGxhY2UoL15cXHMrLywgJycpLnJlcGxhY2UoL1xccyskLywgJycpO1xuICAgICAgICAgICAgaWYgKHRva2VuLmluZGV4T2YoJyMnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9rZW4gaXMgYW4gSUQgc2VsZWN0b3JcbiAgICAgICAgICAgICAgICBiaXRzID0gdG9rZW4uc3BsaXQoJyMnKTtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gYml0c1swXTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBiaXRzWzFdO1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQkMS5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFlbGVtZW50IHx8ICh0YWdOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPSB0YWdOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IG5vdCBmb3VuZCBvciB0YWcgd2l0aCB0aGF0IElEIG5vdCBmb3VuZCwgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnJlbnRDb250ZXh0IHRvIGNvbnRhaW4ganVzdCB0aGlzIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtlbGVtZW50XTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4uaW5kZXhPZignLicpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBUb2tlbiBjb250YWlucyBhIGNsYXNzIHNlbGVjdG9yXG4gICAgICAgICAgICAgICAgYml0cyA9IHRva2VuLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgdGFnTmFtZSA9IGJpdHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGJpdHNbMV07XG4gICAgICAgICAgICAgICAgaWYgKCF0YWdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ05hbWUgPSAnKic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEdldCBlbGVtZW50cyBtYXRjaGluZyB0YWcsIGZpbHRlciB0aGVtIGZvciBjbGFzcyBzZWxlY3RvclxuICAgICAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBnZXRBbGxDaGlsZHJlbihjdXJyZW50Q29udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZvdW5kLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFtqXS5jbGFzc05hbWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIF8uaXNTdHJpbmcoZm91bmRbal0uY2xhc3NOYW1lKSAmJiAvLyBzb21lIFNWRyBlbGVtZW50cyBoYXZlIGNsYXNzTmFtZXMgd2hpY2ggYXJlIG5vdCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDbGFzcyhmb3VuZFtqXSwgY2xhc3NOYW1lKVxuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2N1cnJlbnRDb250ZXh0SW5kZXgrK10gPSBmb3VuZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gU2tpcCB0byBuZXh0IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb2RlIHRvIGRlYWwgd2l0aCBhdHRyaWJ1dGUgc2VsZWN0b3JzXG4gICAgICAgICAgICB2YXIgdG9rZW5fbWF0Y2ggPSB0b2tlbi5tYXRjaChUT0tFTl9NQVRDSF9SRUdFWCk7XG4gICAgICAgICAgICBpZiAodG9rZW5fbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB0YWdOYW1lID0gdG9rZW5fbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gdG9rZW5fbWF0Y2hbMl07XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJPcGVyYXRvciA9IHRva2VuX21hdGNoWzNdO1xuICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB0b2tlbl9tYXRjaFs0XTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFnTmFtZSA9ICcqJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gR3JhYiBhbGwgb2YgdGhlIHRhZ05hbWUgZWxlbWVudHMgd2l0aGluIGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgICAgIGZvdW5kID0gW107XG4gICAgICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJlbnRDb250ZXh0Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWdOYW1lID09ICcqJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMgPSBnZXRBbGxDaGlsZHJlbihjdXJyZW50Q29udGV4dFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRbZm91bmRDb3VudCsrXSA9IGVsZW1lbnRzW2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gW107XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRleHRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGNoZWNrRnVuY3Rpb247IC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIGZpbHRlciB0aGUgZWxlbWVudHNcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0dHJPcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICc9JzogLy8gRXF1YWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkgPT0gYXR0clZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfic6IC8vIE1hdGNoIG9uZSBvZiBzcGFjZSBzZXBlcmF0ZWQgd29yZHNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubWF0Y2gobmV3IFJlZ0V4cCgnXFxcXGInICsgYXR0clZhbHVlICsgJ1xcXFxiJykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnfCc6IC8vIE1hdGNoIHN0YXJ0IHdpdGggdmFsdWUgZm9sbG93ZWQgYnkgb3B0aW9uYWwgaHlwaGVuXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLm1hdGNoKG5ldyBSZWdFeHAoJ14nICsgYXR0clZhbHVlICsgJy0/JykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnXic6IC8vIE1hdGNoIHN0YXJ0cyB3aXRoIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZS5nZXRBdHRyaWJ1dGUoYXR0ck5hbWUpLmluZGV4T2YoYXR0clZhbHVlKSA9PT0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyQnOiAvLyBNYXRjaCBlbmRzIHdpdGggdmFsdWUgLSBmYWlscyB3aXRoIFwiV2FybmluZ1wiIGluIE9wZXJhIDdcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubGFzdEluZGV4T2YoYXR0clZhbHVlKSA9PSBlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkubGVuZ3RoIC0gYXR0clZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJyonOiAvLyBNYXRjaCBlbmRzIHdpdGggdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrRnVuY3Rpb24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSkuaW5kZXhPZihhdHRyVmFsdWUpID4gLTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSnVzdCB0ZXN0IGZvciBleGlzdGVuY2Ugb2YgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0Z1bmN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGV4dCA9IFtdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmb3VuZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2tGdW5jdGlvbihmb3VuZFtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0W2N1cnJlbnRDb250ZXh0SW5kZXgrK10gPSBmb3VuZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhbGVydCgnQXR0cmlidXRlIFNlbGVjdG9yOiAnK3RhZ05hbWUrJyAnK2F0dHJOYW1lKycgJythdHRyT3BlcmF0b3IrJyAnK2F0dHJWYWx1ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIFNraXAgdG8gbmV4dCB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IGhlcmUsIHRva2VuIGlzIEpVU1QgYW4gZWxlbWVudCAobm90IGEgY2xhc3Mgb3IgSUQgc2VsZWN0b3IpXG4gICAgICAgICAgICB0YWdOYW1lID0gdG9rZW47XG4gICAgICAgICAgICBmb3VuZCA9IFtdO1xuICAgICAgICAgICAgZm91bmRDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY3VycmVudENvbnRleHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50cyA9IGN1cnJlbnRDb250ZXh0W2pdLmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBlbGVtZW50cy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZFtmb3VuZENvdW50KytdID0gZWxlbWVudHNba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudENvbnRleHQgPSBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3VycmVudENvbnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKHF1ZXJ5KSB7XG4gICAgICAgIGlmIChfLmlzRWxlbWVudChxdWVyeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBbcXVlcnldO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QocXVlcnkpICYmICFfLmlzVW5kZWZpbmVkKHF1ZXJ5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFbGVtZW50c0J5U2VsZWN0b3IuY2FsbCh0aGlzLCBxdWVyeSk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxudmFyIENBTVBBSUdOX0tFWVdPUkRTID0gWyd1dG1fc291cmNlJywgJ3V0bV9tZWRpdW0nLCAndXRtX2NhbXBhaWduJywgJ3V0bV9jb250ZW50JywgJ3V0bV90ZXJtJywgJ3V0bV9pZCcsICd1dG1fc291cmNlX3BsYXRmb3JtJywndXRtX2NhbXBhaWduX2lkJywgJ3V0bV9jcmVhdGl2ZV9mb3JtYXQnLCAndXRtX21hcmtldGluZ190YWN0aWMnXTtcbnZhciBDTElDS19JRFMgPSBbJ2RjbGlkJywgJ2ZiY2xpZCcsICdnY2xpZCcsICdrb19jbGlja19pZCcsICdsaV9mYXRfaWQnLCAnbXNjbGtpZCcsICdzY2NpZCcsICd0dGNsaWQnLCAndHdjbGlkJywgJ3dicmFpZCddO1xuXG5fLmluZm8gPSB7XG4gICAgY2FtcGFpZ25QYXJhbXM6IGZ1bmN0aW9uKGRlZmF1bHRfdmFsdWUpIHtcbiAgICAgICAgdmFyIGt3ID0gJycsXG4gICAgICAgICAgICBwYXJhbXMgPSB7fTtcbiAgICAgICAgXy5lYWNoKENBTVBBSUdOX0tFWVdPUkRTLCBmdW5jdGlvbihrd2tleSkge1xuICAgICAgICAgICAga3cgPSBfLmdldFF1ZXJ5UGFyYW0oZG9jdW1lbnQkMS5VUkwsIGt3a2V5KTtcbiAgICAgICAgICAgIGlmIChrdy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNba3drZXldID0ga3c7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRfdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1trd2tleV0gPSBkZWZhdWx0X3ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICBjbGlja1BhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBpZCA9ICcnLFxuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIF8uZWFjaChDTElDS19JRFMsIGZ1bmN0aW9uKGlka2V5KSB7XG4gICAgICAgICAgICBpZCA9IF8uZ2V0UXVlcnlQYXJhbShkb2N1bWVudCQxLlVSTCwgaWRrZXkpO1xuICAgICAgICAgICAgaWYgKGlkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tpZGtleV0gPSBpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9LFxuXG4gICAgbWFya2V0aW5nUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uaW5mby5jYW1wYWlnblBhcmFtcygpLCBfLmluZm8uY2xpY2tQYXJhbXMoKSk7XG4gICAgfSxcblxuICAgIHNlYXJjaEVuZ2luZTogZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAgICAgaWYgKHJlZmVycmVyLnNlYXJjaCgnaHR0cHM/Oi8vKC4qKWdvb2dsZS4oW14vP10qKScpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2dvb2dsZSc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopYmluZy5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdiaW5nJztcbiAgICAgICAgfSBlbHNlIGlmIChyZWZlcnJlci5zZWFyY2goJ2h0dHBzPzovLyguKil5YWhvby5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICd5YWhvbyc7XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJyZXIuc2VhcmNoKCdodHRwcz86Ly8oLiopZHVja2R1Y2tnby5jb20nKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICdkdWNrZHVja2dvJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNlYXJjaEluZm86IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciBzZWFyY2ggPSBfLmluZm8uc2VhcmNoRW5naW5lKHJlZmVycmVyKSxcbiAgICAgICAgICAgIHBhcmFtID0gKHNlYXJjaCAhPSAneWFob28nKSA/ICdxJyA6ICdwJyxcbiAgICAgICAgICAgIHJldCA9IHt9O1xuXG4gICAgICAgIGlmIChzZWFyY2ggIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldFsnJHNlYXJjaF9lbmdpbmUnXSA9IHNlYXJjaDtcblxuICAgICAgICAgICAgdmFyIGtleXdvcmQgPSBfLmdldFF1ZXJ5UGFyYW0ocmVmZXJyZXIsIHBhcmFtKTtcbiAgICAgICAgICAgIGlmIChrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldFsnbXBfa2V5d29yZCddID0ga2V5d29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gZGV0ZWN0cyB3aGljaCBicm93c2VyIGlzIHJ1bm5pbmcgdGhpcyBzY3JpcHQuXG4gICAgICogVGhlIG9yZGVyIG9mIHRoZSBjaGVja3MgYXJlIGltcG9ydGFudCBzaW5jZSBtYW55IHVzZXIgYWdlbnRzXG4gICAgICogaW5jbHVkZSBrZXkgd29yZHMgdXNlZCBpbiBsYXRlciBjaGVja3MuXG4gICAgICovXG4gICAgYnJvd3NlcjogZnVuY3Rpb24odXNlcl9hZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgICAgICB2ZW5kb3IgPSB2ZW5kb3IgfHwgJyc7IC8vIHZlbmRvciBpcyB1bmRlZmluZWQgZm9yIGF0IGxlYXN0IElFOVxuICAgICAgICBpZiAob3BlcmEgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnIE9QUi8nKSkge1xuICAgICAgICAgICAgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ01pbmknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnT3BlcmEgTWluaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ09wZXJhJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0lFTW9iaWxlJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnV1BEZXNrdG9wJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnSW50ZXJuZXQgRXhwbG9yZXIgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdTYW1zdW5nQnJvd3Nlci8nKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuc2Ftc3VuZy5jb20vaW50ZXJuZXQvdXNlci1hZ2VudC1zdHJpbmctZm9ybWF0XG4gICAgICAgICAgICByZXR1cm4gJ1NhbXN1bmcgSW50ZXJuZXQnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0VkZ2UnKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdFZGcvJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnTWljcm9zb2Z0IEVkZ2UnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0ZCSU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnRmFjZWJvb2sgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdDaHJvbWUnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdDaHJvbWUnO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0NyaU9TJykpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lIGlPUyc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVUNXRUInKSB8fCBfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdVQ0Jyb3dzZXInKSkge1xuICAgICAgICAgICAgcmV0dXJuICdVQyBCcm93c2VyJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdGeGlPUycpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3ggaU9TJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHZlbmRvciwgJ0FwcGxlJykpIHtcbiAgICAgICAgICAgIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNb2JpbGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnTW9iaWxlIFNhZmFyaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1NhZmFyaSc7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnQW5kcm9pZCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0FuZHJvaWQgTW9iaWxlJztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdLb25xdWVyb3InKSkge1xuICAgICAgICAgICAgcmV0dXJuICdLb25xdWVyb3InO1xuICAgICAgICB9IGVsc2UgaWYgKF8uaW5jbHVkZXModXNlcl9hZ2VudCwgJ0ZpcmVmb3gnKSkge1xuICAgICAgICAgICAgcmV0dXJuICdGaXJlZm94JztcbiAgICAgICAgfSBlbHNlIGlmIChfLmluY2x1ZGVzKHVzZXJfYWdlbnQsICdNU0lFJykgfHwgXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnVHJpZGVudC8nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdJbnRlcm5ldCBFeHBsb3Jlcic7XG4gICAgICAgIH0gZWxzZSBpZiAoXy5pbmNsdWRlcyh1c2VyX2FnZW50LCAnR2Vja28nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdNb3ppbGxhJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hpY2ggYnJvd3NlciB2ZXJzaW9uIGlzIHJ1bm5pbmcgdGhpcyBzY3JpcHQsXG4gICAgICogcGFyc2luZyBtYWpvciBhbmQgbWlub3IgdmVyc2lvbiAoZS5nLiwgNDIuMSkuIFVzZXIgYWdlbnQgc3RyaW5ncyBmcm9tOlxuICAgICAqIGh0dHA6Ly93d3cudXNlcmFnZW50c3RyaW5nLmNvbS9wYWdlcy91c2VyYWdlbnRzdHJpbmcucGhwXG4gICAgICovXG4gICAgYnJvd3NlclZlcnNpb246IGZ1bmN0aW9uKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSkge1xuICAgICAgICB2YXIgYnJvd3NlciA9IF8uaW5mby5icm93c2VyKHVzZXJBZ2VudCwgdmVuZG9yLCBvcGVyYSk7XG4gICAgICAgIHZhciB2ZXJzaW9uUmVnZXhzID0ge1xuICAgICAgICAgICAgJ0ludGVybmV0IEV4cGxvcmVyIE1vYmlsZSc6IC9ydjooXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdNaWNyb3NvZnQgRWRnZSc6IC9FZGdlP1xcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0Nocm9tZSc6IC9DaHJvbWVcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdDaHJvbWUgaU9TJzogL0NyaU9TXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnVUMgQnJvd3NlcicgOiAvKFVDQnJvd3NlcnxVQ1dFQilcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdTYWZhcmknOiAvVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ01vYmlsZSBTYWZhcmknOiAvVmVyc2lvblxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ09wZXJhJzogLyhPcGVyYXxPUFIpXFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnRmlyZWZveCc6IC9GaXJlZm94XFwvKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnRmlyZWZveCBpT1MnOiAvRnhpT1NcXC8oXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdLb25xdWVyb3InOiAvS29ucXVlcm9yOihcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0JsYWNrQmVycnknOiAvQmxhY2tCZXJyeSAoXFxkKyhcXC5cXGQrKT8pLyxcbiAgICAgICAgICAgICdBbmRyb2lkIE1vYmlsZSc6IC9hbmRyb2lkXFxzKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnU2Ftc3VuZyBJbnRlcm5ldCc6IC9TYW1zdW5nQnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvLFxuICAgICAgICAgICAgJ0ludGVybmV0IEV4cGxvcmVyJzogLyhydjp8TVNJRSApKFxcZCsoXFwuXFxkKyk/KS8sXG4gICAgICAgICAgICAnTW96aWxsYSc6IC9ydjooXFxkKyhcXC5cXGQrKT8pL1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVnZXggPSB2ZXJzaW9uUmVnZXhzW2Jyb3dzZXJdO1xuICAgICAgICBpZiAocmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hdGNoZXMgPSB1c2VyQWdlbnQubWF0Y2gocmVnZXgpO1xuICAgICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAyXSk7XG4gICAgfSxcblxuICAgIG9zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGEgPSB1c2VyQWdlbnQ7XG4gICAgICAgIGlmICgvV2luZG93cy9pLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIGlmICgvUGhvbmUvLnRlc3QoYSkgfHwgL1dQRGVza3RvcC8udGVzdChhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnV2luZG93cyBQaG9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ1dpbmRvd3MnO1xuICAgICAgICB9IGVsc2UgaWYgKC8oaVBob25lfGlQYWR8aVBvZCkvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaU9TJztcbiAgICAgICAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdChhKSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkJztcbiAgICAgICAgfSBlbHNlIGlmICgvKEJsYWNrQmVycnl8UGxheUJvb2t8QkIxMCkvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0JsYWNrQmVycnknO1xuICAgICAgICB9IGVsc2UgaWYgKC9NYWMvaS50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ01hYyBPUyBYJztcbiAgICAgICAgfSBlbHNlIGlmICgvTGludXgvLnRlc3QoYSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnTGludXgnO1xuICAgICAgICB9IGVsc2UgaWYgKC9Dck9TLy50ZXN0KGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0Nocm9tZSBPUyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGV2aWNlOiBmdW5jdGlvbih1c2VyX2FnZW50KSB7XG4gICAgICAgIGlmICgvV2luZG93cyBQaG9uZS9pLnRlc3QodXNlcl9hZ2VudCkgfHwgL1dQRGVza3RvcC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdXaW5kb3dzIFBob25lJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBhZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUGFkJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBvZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdpUG9kIFRvdWNoJztcbiAgICAgICAgfSBlbHNlIGlmICgvaVBob25lLy50ZXN0KHVzZXJfYWdlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2lQaG9uZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoLyhCbGFja0JlcnJ5fFBsYXlCb29rfEJCMTApL2kudGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdCbGFja0JlcnJ5JztcbiAgICAgICAgfSBlbHNlIGlmICgvQW5kcm9pZC8udGVzdCh1c2VyX2FnZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuICdBbmRyb2lkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZWZlcnJpbmdEb21haW46IGZ1bmN0aW9uKHJlZmVycmVyKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IHJlZmVycmVyLnNwbGl0KCcvJyk7XG4gICAgICAgIGlmIChzcGxpdC5sZW5ndGggPj0gMykge1xuICAgICAgICAgICAgcmV0dXJuIHNwbGl0WzJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9LFxuXG4gICAgY3VycmVudFVybDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB3aW4ubG9jYXRpb24uaHJlZjtcbiAgICB9LFxuXG4gICAgcHJvcGVydGllczogZnVuY3Rpb24oZXh0cmFfcHJvcHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBleHRyYV9wcm9wcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGV4dHJhX3Byb3BzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKSxcbiAgICAgICAgICAgICckcmVmZXJyZXInOiBkb2N1bWVudCQxLnJlZmVycmVyLFxuICAgICAgICAgICAgJyRyZWZlcnJpbmdfZG9tYWluJzogXy5pbmZvLnJlZmVycmluZ0RvbWFpbihkb2N1bWVudCQxLnJlZmVycmVyKSxcbiAgICAgICAgICAgICckZGV2aWNlJzogXy5pbmZvLmRldmljZSh1c2VyQWdlbnQpXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogXy5pbmZvLmN1cnJlbnRVcmwoKSxcbiAgICAgICAgICAgICckYnJvd3Nlcl92ZXJzaW9uJzogXy5pbmZvLmJyb3dzZXJWZXJzaW9uKHVzZXJBZ2VudCwgbmF2aWdhdG9yLnZlbmRvciwgd2luZG93T3BlcmEpLFxuICAgICAgICAgICAgJyRzY3JlZW5faGVpZ2h0Jzogc2NyZWVuLmhlaWdodCxcbiAgICAgICAgICAgICckc2NyZWVuX3dpZHRoJzogc2NyZWVuLndpZHRoLFxuICAgICAgICAgICAgJ21wX2xpYic6ICd3ZWInLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICckaW5zZXJ0X2lkJzogY2hlYXBfZ3VpZCgpLFxuICAgICAgICAgICAgJ3RpbWUnOiBfLnRpbWVzdGFtcCgpIC8gMTAwMCAvLyBlcG9jaCB0aW1lIGluIHNlY29uZHNcbiAgICAgICAgfSwgXy5zdHJpcF9lbXB0eV9wcm9wZXJ0aWVzKGV4dHJhX3Byb3BzKSk7XG4gICAgfSxcblxuICAgIHBlb3BsZV9wcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uZXh0ZW5kKF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnJG9zJzogXy5pbmZvLm9zKCksXG4gICAgICAgICAgICAnJGJyb3dzZXInOiBfLmluZm8uYnJvd3Nlcih1c2VyQWdlbnQsIG5hdmlnYXRvci52ZW5kb3IsIHdpbmRvd09wZXJhKVxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgJyRicm93c2VyX3ZlcnNpb24nOiBfLmluZm8uYnJvd3NlclZlcnNpb24odXNlckFnZW50LCBuYXZpZ2F0b3IudmVuZG9yLCB3aW5kb3dPcGVyYSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIG1wUGFnZVZpZXdQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF8uc3RyaXBfZW1wdHlfcHJvcGVydGllcyh7XG4gICAgICAgICAgICAnY3VycmVudF9wYWdlX3RpdGxlJzogZG9jdW1lbnQkMS50aXRsZSxcbiAgICAgICAgICAgICdjdXJyZW50X2RvbWFpbic6IHdpbi5sb2NhdGlvbi5ob3N0bmFtZSxcbiAgICAgICAgICAgICdjdXJyZW50X3VybF9wYXRoJzogd2luLmxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3Byb3RvY29sJzogd2luLmxvY2F0aW9uLnByb3RvY29sLFxuICAgICAgICAgICAgJ2N1cnJlbnRfdXJsX3NlYXJjaCc6IHdpbi5sb2NhdGlvbi5zZWFyY2hcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxudmFyIGNoZWFwX2d1aWQgPSBmdW5jdGlvbihtYXhsZW4pIHtcbiAgICB2YXIgZ3VpZCA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygyLCAxMCkgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTApO1xuICAgIHJldHVybiBtYXhsZW4gPyBndWlkLnN1YnN0cmluZygwLCBtYXhsZW4pIDogZ3VpZDtcbn07XG5cbi8vIG5haXZlIHdheSB0byBleHRyYWN0IGRvbWFpbiBuYW1lIChleGFtcGxlLmNvbSkgZnJvbSBmdWxsIGhvc3RuYW1lIChteS5zdWIuZXhhbXBsZS5jb20pXG52YXIgU0lNUExFX0RPTUFJTl9NQVRDSF9SRUdFWCA9IC9bYS16MC05XVthLXowLTktXSpcXC5bYS16XSskL2k7XG4vLyB0aGlzIG5leHQgb25lIGF0dGVtcHRzIHRvIGFjY291bnQgZm9yIHNvbWUgY2NTTERzLCBlLmcuIGV4dHJhY3Rpbmcgb3hmb3JkLmFjLnVrIGZyb20gd3d3Lm94Zm9yZC5hYy51a1xudmFyIERPTUFJTl9NQVRDSF9SRUdFWCA9IC9bYS16MC05XVthLXowLTktXStcXC5bYS16Ll17Miw2fSQvaTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gZXh0cmFjdCBtYWluIGRvbWFpbiBuYW1lIGZyb20gZnVsbCBob3N0bmFtZSwgdXNpbmcgYSBmZXcgYmx1bnQgaGV1cmlzdGljcy4gRm9yXG4gKiBjb21tb24gVExEcyBsaWtlIC5jb20vLm9yZyB0aGF0IGFsd2F5cyBoYXZlIGEgc2ltcGxlIFNMRC5UTEQgc3RydWN0dXJlIChleGFtcGxlLmNvbSksIHdlXG4gKiBzaW1wbHkgZXh0cmFjdCB0aGUgbGFzdCB0d28gLi1zZXBhcmF0ZWQgcGFydHMgb2YgdGhlIGhvc3RuYW1lIChTSU1QTEVfRE9NQUlOX01BVENIX1JFR0VYKS5cbiAqIEZvciBvdGhlcnMsIHdlIGF0dGVtcHQgdG8gYWNjb3VudCBmb3Igc2hvcnQgY2NTTEQrVExEIGNvbWJvcyAoLmFjLnVrKSB3aXRoIHRoZSBsZWdhY3lcbiAqIERPTUFJTl9NQVRDSF9SRUdFWCAoa2VwdCB0byBtYWludGFpbiBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGV4aXN0aW5nIE1peHBhbmVsXG4gKiBpbnRlZ3JhdGlvbnMpLiBUaGUgb25seSBfcmVsaWFibGVfIHdheSB0byBleHRyYWN0IGRvbWFpbiBmcm9tIGhvc3RuYW1lIGlzIHdpdGggYW4gdXAtdG8tZGF0ZVxuICogbGlzdCBsaWtlIGF0IGh0dHBzOi8vcHVibGljc3VmZml4Lm9yZy8gc28gZm9yIGNhc2VzIHRoYXQgdGhpcyBoZWxwZXIgZmFpbHMgYXQsIHRoZSBTREtcbiAqIG9mZmVycyB0aGUgJ2Nvb2tpZV9kb21haW4nIGNvbmZpZyBvcHRpb24gdG8gc2V0IGl0IGV4cGxpY2l0bHkuXG4gKiBAZXhhbXBsZVxuICogZXh0cmFjdF9kb21haW4oJ215LnN1Yi5leGFtcGxlLmNvbScpXG4gKiAvLyAnZXhhbXBsZS5jb20nXG4gKi9cbnZhciBleHRyYWN0X2RvbWFpbiA9IGZ1bmN0aW9uKGhvc3RuYW1lKSB7XG4gICAgdmFyIGRvbWFpbl9yZWdleCA9IERPTUFJTl9NQVRDSF9SRUdFWDtcbiAgICB2YXIgcGFydHMgPSBob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgIHZhciB0bGQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAodGxkLmxlbmd0aCA+IDQgfHwgdGxkID09PSAnY29tJyB8fCB0bGQgPT09ICdvcmcnKSB7XG4gICAgICAgIGRvbWFpbl9yZWdleCA9IFNJTVBMRV9ET01BSU5fTUFUQ0hfUkVHRVg7XG4gICAgfVxuICAgIHZhciBtYXRjaGVzID0gaG9zdG5hbWUubWF0Y2goZG9tYWluX3JlZ2V4KTtcbiAgICByZXR1cm4gbWF0Y2hlcyA/IG1hdGNoZXNbMF0gOiAnJztcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB3ZSBoYXZlIG5ldHdvcmsgY29ubmVjdGlvbi4gZGVmYXVsdCB0byB0cnVlIGZvciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgbmF2aWdhdG9yLm9uTGluZSAoSUUpXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xudmFyIGlzT25saW5lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9uTGluZSA9IHdpbi5uYXZpZ2F0b3JbJ29uTGluZSddO1xuICAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9uTGluZSkgfHwgb25MaW5lO1xufTtcblxudmFyIEpTT05TdHJpbmdpZnkgPSBudWxsLCBKU09OUGFyc2UgPSBudWxsO1xuaWYgKHR5cGVvZiBKU09OICE9PSAndW5kZWZpbmVkJykge1xuICAgIEpTT05TdHJpbmdpZnkgPSBKU09OLnN0cmluZ2lmeTtcbiAgICBKU09OUGFyc2UgPSBKU09OLnBhcnNlO1xufVxuSlNPTlN0cmluZ2lmeSA9IEpTT05TdHJpbmdpZnkgfHwgXy5KU09ORW5jb2RlO1xuSlNPTlBhcnNlID0gSlNPTlBhcnNlIHx8IF8uSlNPTkRlY29kZTtcblxuLy8gRVhQT1JUUyAoZm9yIGNsb3N1cmUgY29tcGlsZXIpXG5fWyd0b0FycmF5J10gICAgICAgICAgICAgICAgPSBfLnRvQXJyYXk7XG5fWydpc09iamVjdCddICAgICAgICAgICAgICAgPSBfLmlzT2JqZWN0O1xuX1snSlNPTkVuY29kZSddICAgICAgICAgICAgID0gXy5KU09ORW5jb2RlO1xuX1snSlNPTkRlY29kZSddICAgICAgICAgICAgID0gXy5KU09ORGVjb2RlO1xuX1snaXNCbG9ja2VkVUEnXSAgICAgICAgICAgID0gXy5pc0Jsb2NrZWRVQTtcbl9bJ2lzRW1wdHlPYmplY3QnXSAgICAgICAgICA9IF8uaXNFbXB0eU9iamVjdDtcbl9bJ2luZm8nXSAgICAgICAgICAgICAgICAgICA9IF8uaW5mbztcbl9bJ2luZm8nXVsnZGV2aWNlJ10gICAgICAgICA9IF8uaW5mby5kZXZpY2U7XG5fWydpbmZvJ11bJ2Jyb3dzZXInXSAgICAgICAgPSBfLmluZm8uYnJvd3Nlcjtcbl9bJ2luZm8nXVsnYnJvd3NlclZlcnNpb24nXSA9IF8uaW5mby5icm93c2VyVmVyc2lvbjtcbl9bJ2luZm8nXVsncHJvcGVydGllcyddICAgICA9IF8uaW5mby5wcm9wZXJ0aWVzO1xuX1snTlBPJ10gICAgICAgICAgICAgICAgICAgID0gTnBvUHJvbWlzZTtcblxuLyoqXG4gKiBHRFBSIHV0aWxzXG4gKlxuICogVGhlIEdlbmVyYWwgRGF0YSBQcm90ZWN0aW9uIFJlZ3VsYXRpb24gKEdEUFIpIGlzIGEgcmVndWxhdGlvbiBpbiBFVSBsYXcgb24gZGF0YSBwcm90ZWN0aW9uXG4gKiBhbmQgcHJpdmFjeSBmb3IgYWxsIGluZGl2aWR1YWxzIHdpdGhpbiB0aGUgRXVyb3BlYW4gVW5pb24uIEl0IGFkZHJlc3NlcyB0aGUgZXhwb3J0IG9mIHBlcnNvbmFsXG4gKiBkYXRhIG91dHNpZGUgdGhlIEVVLiBUaGUgR0RQUiBhaW1zIHByaW1hcmlseSB0byBnaXZlIGNvbnRyb2wgYmFjayB0byBjaXRpemVucyBhbmQgcmVzaWRlbnRzXG4gKiBvdmVyIHRoZWlyIHBlcnNvbmFsIGRhdGEgYW5kIHRvIHNpbXBsaWZ5IHRoZSByZWd1bGF0b3J5IGVudmlyb25tZW50IGZvciBpbnRlcm5hdGlvbmFsIGJ1c2luZXNzXG4gKiBieSB1bmlmeWluZyB0aGUgcmVndWxhdGlvbiB3aXRoaW4gdGhlIEVVLlxuICpcbiAqIFRoaXMgc2V0IG9mIHV0aWxpdGllcyBpcyBpbnRlbmRlZCB0byBlbmFibGUgb3B0IGluL291dCBmdW5jdGlvbmFsaXR5IGluIHRoZSBNaXhwYW5lbCBKUyBTREsuXG4gKiBUaGVzZSBmdW5jdGlvbnMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgU0RLIGFuZCBhcmUgbm90IGludGVuZGVkIHRvIGJlIHB1YmxpY2x5IGV4cG9zZWQuXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHVzZWQgdG8gdHJhY2sgYSBNaXhwYW5lbCBldmVudCAoZS5nLiBNaXhwYW5lbExpYi50cmFjaylcbiAqIEBjYWxsYmFjayB0cmFja0Z1bmN0aW9uXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQuIFRoaXMgY2FuIGJlIGFueXRoaW5nIHRoZSB1c2VyIGRvZXMgLSAnQnV0dG9uIENsaWNrJywgJ1NpZ24gVXAnLCAnSXRlbSBQdXJjaGFzZWQnLCBldGMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEEgc2V0IG9mIHByb3BlcnRpZXMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudCB5b3UncmUgc2VuZGluZy4gVGhlc2UgZGVzY3JpYmUgdGhlIHVzZXIgd2hvIGRpZCB0aGUgZXZlbnQgb3IgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQgaXRzZWxmLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuXG4vKiogUHVibGljICoqL1xuXG52YXIgR0RQUl9ERUZBVUxUX1BFUlNJU1RFTkNFX1BSRUZJWCA9ICdfX21wX29wdF9pbl9vdXRfJztcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHt0cmFja0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gLSBmdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrRXZlbnROYW1lXSAtIGV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja1Byb3BlcnRpZXNdIC0gc2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIG9wdEluKHRva2VuLCBvcHRpb25zKSB7XG4gICAgX29wdEluT3V0KHRydWUsIHRva2VuLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlbiAtIE1peHBhbmVsIHByb2plY3QgdHJhY2tpbmcgdG9rZW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZUV4cGlyYXRpb25dIC0gbnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1vdXQgY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtb3V0IGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LW91dCBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gb3B0T3V0KHRva2VuLCBvcHRpb25zKSB7XG4gICAgX29wdEluT3V0KGZhbHNlLCB0b2tlbiwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgaW4gdG8gdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGhhc09wdGVkSW4odG9rZW4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX2dldFN0b3JhZ2VWYWx1ZSh0b2tlbiwgb3B0aW9ucykgPT09ICcxJztcbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlVHlwZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZURudF0gLSBmbGFnIHRvIGlnbm9yZSBicm93c2VyIEROVCBzZXR0aW5ncyBhbmQgYWx3YXlzIHJldHVybiBmYWxzZVxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCBvZiB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqL1xuZnVuY3Rpb24gaGFzT3B0ZWRPdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBpZiAoX2hhc0RvTm90VHJhY2tGbGFnT24ob3B0aW9ucykpIHtcbiAgICAgICAgY29uc29sZSQxLndhcm4oJ1RoaXMgYnJvd3NlciBoYXMgXCJEbyBOb3QgVHJhY2tcIiBlbmFibGVkLiBUaGlzIHdpbGwgcHJldmVudCB0aGUgTWl4cGFuZWwgU0RLIGZyb20gc2VuZGluZyBhbnkgZGF0YS4gVG8gaWdub3JlIHRoZSBcIkRvIE5vdCBUcmFja1wiIGJyb3dzZXIgc2V0dGluZywgaW5pdGlhbGl6ZSB0aGUgTWl4cGFuZWwgaW5zdGFuY2Ugd2l0aCB0aGUgY29uZmlnIFwiaWdub3JlX2RudDogdHJ1ZVwiJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB2YXIgb3B0ZWRPdXQgPSBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSA9PT0gJzAnO1xuICAgIGlmIChvcHRlZE91dCkge1xuICAgICAgICBjb25zb2xlJDEud2FybignWW91IGFyZSBvcHRlZCBvdXQgb2YgTWl4cGFuZWwgdHJhY2tpbmcuIFRoaXMgd2lsbCBwcmV2ZW50IHRoZSBNaXhwYW5lbCBTREsgZnJvbSBzZW5kaW5nIGFueSBkYXRhLicpO1xuICAgIH1cbiAgICByZXR1cm4gb3B0ZWRPdXQ7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsTGliIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIGV4ZWN1dGluZyBtZXRob2QgT1IgdW5kZWZpbmVkIGlmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihtZXRob2QpIHtcbiAgICByZXR1cm4gX2FkZE9wdE91dENoZWNrKG1ldGhvZCwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRfY29uZmlnKG5hbWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFdyYXAgYSBNaXhwYW5lbFBlb3BsZSBtZXRob2Qgd2l0aCBhIGNoZWNrIGZvciB3aGV0aGVyIHRoZSB1c2VyIGlzIG9wdGVkIG91dCBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBJZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0LCByZXR1cm4gZWFybHkgaW5zdGVhZCBvZiBleGVjdXRpbmcgdGhlIG1ldGhvZC5cbiAqIElmIGEgY2FsbGJhY2sgYXJndW1lbnQgd2FzIHByb3ZpZGVkLCBleGVjdXRlIGl0IHBhc3NpbmcgdGhlIDAgZXJyb3IgY29kZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG1ldGhvZCAtIHdyYXBwZWQgbWV0aG9kIHRvIGJlIGV4ZWN1dGVkIGlmIHRoZSB1c2VyIGhhcyBub3Qgb3B0ZWQgb3V0XG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogV3JhcCBhIE1peHBhbmVsR3JvdXAgbWV0aG9kIHdpdGggYSBjaGVjayBmb3Igd2hldGhlciB0aGUgdXNlciBpcyBvcHRlZCBvdXQgb2YgZGF0YSB0cmFja2luZyBhbmQgY29va2llcy9sb2NhbHN0b3JhZ2UgZm9yIHRoZSBnaXZlbiB0b2tlblxuICogSWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dCwgcmV0dXJuIGVhcmx5IGluc3RlYWQgb2YgZXhlY3V0aW5nIHRoZSBtZXRob2QuXG4gKiBJZiBhIGNhbGxiYWNrIGFyZ3VtZW50IHdhcyBwcm92aWRlZCwgZXhlY3V0ZSBpdCBwYXNzaW5nIHRoZSAwIGVycm9yIGNvZGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZXRob2QgLSB3cmFwcGVkIG1ldGhvZCB0byBiZSBleGVjdXRlZCBpZiB0aGUgdXNlciBoYXMgbm90IG9wdGVkIG91dFxuICogQHJldHVybnMgeyp9IHRoZSByZXN1bHQgb2YgZXhlY3V0aW5nIG1ldGhvZCBPUiB1bmRlZmluZWQgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dFxuICovXG5mdW5jdGlvbiBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAobWV0aG9kKSB7XG4gICAgcmV0dXJuIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldF9jb25maWcobmFtZSk7XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhlIGdpdmVuIHRva2VuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW4gLSBNaXhwYW5lbCBwcm9qZWN0IHRyYWNraW5nIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VUeXBlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVByZWZpeD1fX21wX29wdF9pbl9vdXRdIC0gY3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uXSAtIG51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVEb21haW5dIC0gY3VzdG9tIGNvb2tpZSBkb21haW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTaXRlQ29va2llXSAtIHdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc1N1YmRvbWFpbkNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90XG4gKi9cbmZ1bmN0aW9uIGNsZWFyT3B0SW5PdXQodG9rZW4sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5yZW1vdmUoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSwgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLCBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG59XG5cbi8qKiBQcml2YXRlICoqL1xuXG4vKipcbiAqIEdldCBzdG9yYWdlIHV0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZVR5cGVdXG4gKiBAcmV0dXJucyB7b2JqZWN0fSBlaXRoZXIgXy5jb29raWUgb3IgXy5sb2NhbHN0b3JhZ2VcbiAqL1xuZnVuY3Rpb24gX2dldFN0b3JhZ2Uob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBvcHRpb25zLnBlcnNpc3RlbmNlVHlwZSA9PT0gJ2xvY2FsU3RvcmFnZScgPyBfLmxvY2FsU3RvcmFnZSA6IF8uY29va2llO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmFtZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIGNvb2tpZSBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlXG4gKi9cbmZ1bmN0aW9uIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIChvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4IHx8IEdEUFJfREVGQVVMVF9QRVJTSVNURU5DRV9QUkVGSVgpICsgdG9rZW47XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBvZiB0aGUgY29va2llIHRoYXQgaXMgdXNlZCBmb3IgdGhlIGdpdmVuIG9wdCB0eXBlICh0cmFja2luZywgY29va2llLCBldGMuKVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlUHJlZml4PV9fbXBfb3B0X2luX291dF0gLSBjdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge3N0cmluZ30gdGhlIHZhbHVlIG9mIHRoZSBjb29raWUgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICovXG5mdW5jdGlvbiBfZ2V0U3RvcmFnZVZhbHVlKHRva2VuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9nZXRTdG9yYWdlKG9wdGlvbnMpLmdldChfZ2V0U3RvcmFnZUtleSh0b2tlbiwgb3B0aW9ucykpO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIHNldCB0aGUgRE5UL2RvTm90VHJhY2sgc2V0dGluZyB0byB0cnVlIGluIHRoZWlyIGJyb3dzZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53aW5kb3ddIC0gYWx0ZXJuYXRlIHdpbmRvdyBvYmplY3QgdG8gY2hlY2s7IHVzZWQgdG8gZm9yY2UgdmFyaW91cyBETlQgc2V0dGluZ3MgaW4gYnJvd3NlciB0ZXN0c1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pZ25vcmVEbnRdIC0gZmxhZyB0byBpZ25vcmUgYnJvd3NlciBETlQgc2V0dGluZ3MgYW5kIGFsd2F5cyByZXR1cm4gZmFsc2VcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBETlQgc2V0dGluZyBpcyB0cnVlXG4gKi9cbmZ1bmN0aW9uIF9oYXNEb05vdFRyYWNrRmxhZ09uKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmlnbm9yZURudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciB3aW4kMSA9IChvcHRpb25zICYmIG9wdGlvbnMud2luZG93KSB8fCB3aW47XG4gICAgdmFyIG5hdiA9IHdpbiQxWyduYXZpZ2F0b3InXSB8fCB7fTtcbiAgICB2YXIgaGFzRG50T24gPSBmYWxzZTtcblxuICAgIF8uZWFjaChbXG4gICAgICAgIG5hdlsnZG9Ob3RUcmFjayddLCAvLyBzdGFuZGFyZFxuICAgICAgICBuYXZbJ21zRG9Ob3RUcmFjayddLFxuICAgICAgICB3aW4kMVsnZG9Ob3RUcmFjayddXG4gICAgXSwgZnVuY3Rpb24oZG50VmFsdWUpIHtcbiAgICAgICAgaWYgKF8uaW5jbHVkZXMoW3RydWUsIDEsICcxJywgJ3llcyddLCBkbnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGhhc0RudE9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGhhc0RudE9uO1xufVxuXG4vKipcbiAqIFNldCBjb29raWUvbG9jYWxzdG9yYWdlIGZvciB0aGUgdXNlciBpbmRpY2F0aW5nIHRoYXQgdGhleSBhcmUgb3B0ZWQgaW4gb3Igb3V0IGZvciB0aGUgZ2l2ZW4gb3B0IHR5cGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0VmFsdWUgLSB3aGV0aGVyIHRvIG9wdCB0aGUgdXNlciBpbiBvciBvdXQgZm9yIHRoZSBnaXZlbiBvcHQgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuIC0gTWl4cGFuZWwgcHJvamVjdCB0cmFja2luZyB0b2tlblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHt0cmFja0Z1bmN0aW9ufSBbb3B0aW9ucy50cmFja10gLSBmdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrRXZlbnROYW1lXSAtIGV2ZW50IG5hbWUgdG8gYmUgdXNlZCBmb3IgdHJhY2tpbmcgdGhlIG9wdC1pbiBhY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy50cmFja1Byb3BlcnRpZXNdIC0gc2V0IG9mIHByb3BlcnRpZXMgdG8gYmUgdHJhY2tlZCBhbG9uZyB3aXRoIHRoZSBvcHQtaW4gYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VQcmVmaXg9X19tcF9vcHRfaW5fb3V0XSAtIGN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llRXhwaXJhdGlvbl0gLSBudW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llRG9tYWluXSAtIGN1c3RvbSBjb29raWUgZG9tYWluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzU2l0ZUNvb2tpZV0gLSB3aGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3NTdWJkb21haW5Db29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVDb29raWVdIC0gd2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdFxuICovXG5mdW5jdGlvbiBfb3B0SW5PdXQob3B0VmFsdWUsIHRva2VuLCBvcHRpb25zKSB7XG4gICAgaWYgKCFfLmlzU3RyaW5nKHRva2VuKSB8fCAhdG9rZW4ubGVuZ3RoKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignZ2Rwci4nICsgKG9wdFZhbHVlID8gJ29wdEluJyA6ICdvcHRPdXQnKSArICcgY2FsbGVkIHdpdGggYW4gaW52YWxpZCB0b2tlbicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBfZ2V0U3RvcmFnZShvcHRpb25zKS5zZXQoXG4gICAgICAgIF9nZXRTdG9yYWdlS2V5KHRva2VuLCBvcHRpb25zKSxcbiAgICAgICAgb3B0VmFsdWUgPyAxIDogMCxcbiAgICAgICAgXy5pc051bWJlcihvcHRpb25zLmNvb2tpZUV4cGlyYXRpb24pID8gb3B0aW9ucy5jb29raWVFeHBpcmF0aW9uIDogbnVsbCxcbiAgICAgICAgISFvcHRpb25zLmNyb3NzU3ViZG9tYWluQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuc2VjdXJlQ29va2llLFxuICAgICAgICAhIW9wdGlvbnMuY3Jvc3NTaXRlQ29va2llLFxuICAgICAgICBvcHRpb25zLmNvb2tpZURvbWFpblxuICAgICk7XG5cbiAgICBpZiAob3B0aW9ucy50cmFjayAmJiBvcHRWYWx1ZSkgeyAvLyBvbmx5IHRyYWNrIGV2ZW50IGlmIG9wdGluZyBpbiAob3B0VmFsdWU9dHJ1ZSlcbiAgICAgICAgb3B0aW9ucy50cmFjayhvcHRpb25zLnRyYWNrRXZlbnROYW1lIHx8ICckb3B0X2luJywgb3B0aW9ucy50cmFja1Byb3BlcnRpZXMsIHtcbiAgICAgICAgICAgICdzZW5kX2ltbWVkaWF0ZWx5JzogdHJ1ZVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogV3JhcCBhIG1ldGhvZCB3aXRoIGEgY2hlY2sgZm9yIHdoZXRoZXIgdGhlIHVzZXIgaXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGUgZ2l2ZW4gdG9rZW5cbiAqIElmIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQsIHJldHVybiBlYXJseSBpbnN0ZWFkIG9mIGV4ZWN1dGluZyB0aGUgbWV0aG9kLlxuICogSWYgYSBjYWxsYmFjayBhcmd1bWVudCB3YXMgcHJvdmlkZWQsIGV4ZWN1dGUgaXQgcGFzc2luZyB0aGUgMCBlcnJvciBjb2RlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIC0gd3JhcHBlZCBtZXRob2QgdG8gYmUgZXhlY3V0ZWQgaWYgdGhlIHVzZXIgaGFzIG5vdCBvcHRlZCBvdXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGdldENvbmZpZ1ZhbHVlIC0gZ2V0dGVyIGZ1bmN0aW9uIGZvciB0aGUgTWl4cGFuZWwgQVBJIHRva2VuIGFuZCBvdGhlciBvcHRpb25zIHRvIGJlIHVzZWQgd2l0aCBvcHQtb3V0IGNoZWNrXG4gKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiBleGVjdXRpbmcgbWV0aG9kIE9SIHVuZGVmaW5lZCBpZiB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0XG4gKi9cbmZ1bmN0aW9uIF9hZGRPcHRPdXRDaGVjayhtZXRob2QsIGdldENvbmZpZ1ZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb3B0ZWRPdXQgPSBmYWxzZTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRva2VuID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAndG9rZW4nKTtcbiAgICAgICAgICAgIHZhciBpZ25vcmVEbnQgPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdpZ25vcmVfZG50Jyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VUeXBlID0gZ2V0Q29uZmlnVmFsdWUuY2FsbCh0aGlzLCAnb3B0X291dF90cmFja2luZ19wZXJzaXN0ZW5jZV90eXBlJyk7XG4gICAgICAgICAgICB2YXIgcGVyc2lzdGVuY2VQcmVmaXggPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICdvcHRfb3V0X3RyYWNraW5nX2Nvb2tpZV9wcmVmaXgnKTtcbiAgICAgICAgICAgIHZhciB3aW4gPSBnZXRDb25maWdWYWx1ZS5jYWxsKHRoaXMsICd3aW5kb3cnKTsgLy8gdXNlZCB0byBvdmVycmlkZSB3aW5kb3cgZHVyaW5nIGJyb3dzZXIgdGVzdHNcblxuICAgICAgICAgICAgaWYgKHRva2VuKSB7IC8vIGlmIHRoZXJlIHdhcyBhbiBpc3N1ZSBnZXR0aW5nIHRoZSB0b2tlbiwgY29udGludWUgbWV0aG9kIGV4ZWN1dGlvbiBhcyBub3JtYWxcbiAgICAgICAgICAgICAgICBvcHRlZE91dCA9IGhhc09wdGVkT3V0KHRva2VuLCB7XG4gICAgICAgICAgICAgICAgICAgIGlnbm9yZURudDogaWdub3JlRG50LFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0ZW5jZVR5cGU6IHBlcnNpc3RlbmNlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcGVyc2lzdGVuY2VQcmVmaXg6IHBlcnNpc3RlbmNlUHJlZml4LFxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c6IHdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdVbmV4cGVjdGVkIGVycm9yIHdoZW4gY2hlY2tpbmcgdHJhY2tpbmcgb3B0LW91dCBzdGF0dXM6ICcgKyBlcnIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcHRlZE91dCkge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZihjYWxsYmFjaykgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG59XG5cbnZhciBsb2dnZXIkNCA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2xvY2snKTtcblxuLyoqXG4gKiBTaGFyZWRMb2NrOiBhIG11dGV4IGJ1aWx0IG9uIEhUTUw1IGxvY2FsU3RvcmFnZSwgdG8gZW5zdXJlIHRoYXQgb25seSBvbmUgYnJvd3NlclxuICogd2luZG93L3RhYiBhdCBhIHRpbWUgd2lsbCBiZSBhYmxlIHRvIGFjY2VzcyBzaGFyZWQgcmVzb3VyY2VzLlxuICpcbiAqIEJhc2VkIG9uIHRoZSBBbHVyIGFuZCBUYXViZW5mZWxkIGZhc3QgbG9ja1xuICogKGh0dHA6Ly93d3cuY3Mucm9jaGVzdGVyLmVkdS9yZXNlYXJjaC9zeW5jaHJvbml6YXRpb24vcHNldWRvY29kZS9mYXN0bG9jay5odG1sKVxuICogd2l0aCBhbiBhZGRlZCB0aW1lb3V0IHRvIGVuc3VyZSB0aGVyZSB3aWxsIGJlIGV2ZW50dWFsIHByb2dyZXNzIGluIHRoZSBldmVudFxuICogdGhhdCBhIHdpbmRvdyBpcyBjbG9zZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgY2FsbGJhY2suXG4gKlxuICogSW1wbGVtZW50YXRpb24gYmFzZWQgb24gdGhlIG9yaWdpbmFsIHZlcnNpb24gYnkgRGF2aWQgV29sZXZlciAoaHR0cHM6Ly9naXRodWIuY29tL3dvbGV2ZXIpXG4gKiBhdCBodHRwczovL2dpc3QuZ2l0aHViLmNvbS93b2xldmVyLzVmZDc1NzNkMWVmNjE2NmU4ZjhjNGFmMjg2YTY5NDMyLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBteUxvY2sgPSBuZXcgU2hhcmVkTG9jaygnc29tZS1rZXknKTtcbiAqIG15TG9jay53aXRoTG9jayhmdW5jdGlvbigpIHtcbiAqICAgY29uc29sZS5sb2coJ0kgaG9sZCB0aGUgbXV0ZXghJyk7XG4gKiB9KTtcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNoYXJlZExvY2sgPSBmdW5jdGlvbihrZXksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIHRoaXMuc3RvcmFnZUtleSA9IGtleTtcbiAgICB0aGlzLnN0b3JhZ2UgPSBvcHRpb25zLnN0b3JhZ2UgfHwgd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICB0aGlzLnBvbGxJbnRlcnZhbE1TID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWxNUyB8fCAxMDA7XG4gICAgdGhpcy50aW1lb3V0TVMgPSBvcHRpb25zLnRpbWVvdXRNUyB8fCAyMDAwO1xuXG4gICAgLy8gZGVwZW5kZW5jeS1pbmplY3QgcHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBmb3IgdGVzdGluZyBwdXJwb3Nlc1xuICAgIHRoaXMucHJvbWlzZUltcGwgPSBvcHRpb25zLnByb21pc2VJbXBsIHx8IFByb21pc2VQb2x5ZmlsbDtcbn07XG5cbi8vIHBhc3MgaW4gYSBzcGVjaWZpYyBwaWQgdG8gdGVzdCBjb250ZW50aW9uIHNjZW5hcmlvczsgb3RoZXJ3aXNlXG4vLyBpdCBpcyBjaG9zZW4gcmFuZG9tbHkgZm9yIGVhY2ggYWNxdWlzaXRpb24gYXR0ZW1wdFxuU2hhcmVkTG9jay5wcm90b3R5cGUud2l0aExvY2sgPSBmdW5jdGlvbihsb2NrZWRDQiwgcGlkKSB7XG4gICAgdmFyIFByb21pc2UgPSB0aGlzLnByb21pc2VJbXBsO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaSA9IHBpZCB8fCAobmV3IERhdGUoKS5nZXRUaW1lKCkgKyAnfCcgKyBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnN0b3JhZ2VLZXk7XG4gICAgICAgIHZhciBwb2xsSW50ZXJ2YWxNUyA9IHRoaXMucG9sbEludGVydmFsTVM7XG4gICAgICAgIHZhciB0aW1lb3V0TVMgPSB0aGlzLnRpbWVvdXRNUztcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLnN0b3JhZ2U7XG5cbiAgICAgICAgdmFyIGtleVggPSBrZXkgKyAnOlgnO1xuICAgICAgICB2YXIga2V5WSA9IGtleSArICc6WSc7XG4gICAgICAgIHZhciBrZXlaID0ga2V5ICsgJzpaJztcblxuICAgICAgICB2YXIgZGVsYXkgPSBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgaWYgKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID4gdGltZW91dE1TKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyJDQuZXJyb3IoJ1RpbWVvdXQgd2FpdGluZyBmb3IgbXV0ZXggb24gJyArIGtleSArICc7IGNsZWFyaW5nIGxvY2suIFsnICsgaSArICddJyk7XG4gICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShrZXlZKTtcbiAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHBvbGxJbnRlcnZhbE1TICogKE1hdGgucmFuZG9tKCkgKyAwLjEpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgd2FpdEZvciA9IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUoKSkge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yKHByZWRpY2F0ZSwgY2IpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBnZXRTZXRZID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdmFsWSA9IHN0b3JhZ2UuZ2V0SXRlbShrZXlZKTtcbiAgICAgICAgICAgIGlmICh2YWxZICYmIHZhbFkgIT09IGkpIHsgLy8gaWYgWSA9PSBpIHRoZW4gdGhpcyBwcm9jZXNzIGFscmVhZHkgaGFzIHRoZSBsb2NrICh1c2VmdWwgZm9yIHRlc3QgY2FzZXMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WSwgaSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignbG9jYWxTdG9yYWdlIHN1cHBvcnQgZHJvcHBlZCB3aGlsZSBhY3F1aXJpbmcgbG9jaycpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBsb29wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5WCwgaSk7XG5cbiAgICAgICAgICAgIHdhaXRGb3IoZ2V0U2V0WSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlYKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBjcml0aWNhbFNlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RvcmFnZS5nZXRJdGVtKGtleVkpICE9PSBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb29wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgd2FpdEZvcihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhc3RvcmFnZS5nZXRJdGVtKGtleVopO1xuICAgICAgICAgICAgICAgICAgICB9LCBjcml0aWNhbFNlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNyaXRpY2FsU2VjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKGtleVosICcxJyk7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlTG9jayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5Wik7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2UuZ2V0SXRlbShrZXlZKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oa2V5WSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9yYWdlLmdldEl0ZW0oa2V5WCkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGxvY2tlZENCKClcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUxvY2soKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXQpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTG9jaygpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGxvY2FsU3RvcmFnZVN1cHBvcnRlZChzdG9yYWdlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIGxvb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsb2NhbFN0b3JhZ2Ugc3VwcG9ydCBjaGVjayBmYWlsZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSwgdGhpcykpO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3dyYXBwZXInKS5TdG9yYWdlV3JhcHBlcn1cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtTdG9yYWdlV3JhcHBlcn1cbiAqL1xudmFyIExvY2FsU3RvcmFnZVdyYXBwZXIgPSBmdW5jdGlvbiAoc3RvcmFnZU92ZXJyaWRlKSB7XG4gICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZU92ZXJyaWRlIHx8IGxvY2FsU3RvcmFnZTtcbn07XG5cbkxvY2FsU3RvcmFnZVdyYXBwZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgfSwgdGhpcykpO1xufTtcblxuTG9jYWxTdG9yYWdlV3JhcHBlci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShpdGVtKTtcbiAgICB9LCB0aGlzKSk7XG59O1xuXG5Mb2NhbFN0b3JhZ2VXcmFwcGVyLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZVBvbHlmaWxsKF8uYmluZChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cbnZhciBsb2dnZXIkMyA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ2JhdGNoJyk7XG5cbi8qKlxuICogUmVxdWVzdFF1ZXVlOiBxdWV1ZSBmb3IgYmF0Y2hpbmcgQVBJIHJlcXVlc3RzIHdpdGggbG9jYWxTdG9yYWdlIGJhY2t1cCBmb3IgcmV0cmllcy5cbiAqIE1haW50YWlucyBhbiBpbi1tZW1vcnkgcXVldWUgd2hpY2ggcmVwcmVzZW50cyB0aGUgc291cmNlIG9mIHRydXRoIGZvciB0aGUgY3VycmVudFxuICogcGFnZSwgYnV0IGFsc28gd3JpdGVzIGFsbCBpdGVtcyBvdXQgdG8gYSBjb3B5IGluIHRoZSBicm93c2VyJ3MgbG9jYWxTdG9yYWdlLCB3aGljaFxuICogY2FuIGJlIHJlYWQgb24gc3Vic2VxdWVudCBwYWdlbG9hZHMgYW5kIHJldHJpZWQuIEZvciBiYXRjaGFiaWxpdHksIGFsbCB0aGUgcmVxdWVzdFxuICogaXRlbXMgaW4gdGhlIHF1ZXVlIHNob3VsZCBiZSBvZiB0aGUgc2FtZSB0eXBlIChldmVudHMsIHBlb3BsZSB1cGRhdGVzLCBncm91cCB1cGRhdGVzKVxuICogc28gdGhleSBjYW4gYmUgc2VudCBpbiBhIHNpbmdsZSByZXF1ZXN0IHRvIHRoZSBzYW1lIEFQSSBlbmRwb2ludC5cbiAqXG4gKiBMb2NhbFN0b3JhZ2Uga2V5aW5nIGFuZCBsb2NraW5nOiBJbiBvcmRlciBmb3IgcmVsb2FkcyBhbmQgc3Vic2VxdWVudCBwYWdlbG9hZHMgb2ZcbiAqIHRoZSBzYW1lIHNpdGUgdG8gYWNjZXNzIHRoZSBzYW1lIHBlcnNpc3RlZCBkYXRhLCB0aGV5IG11c3Qgc2hhcmUgdGhlIHNhbWUgbG9jYWxTdG9yYWdlXG4gKiBrZXkgKGZvciBpbnN0YW5jZSBiYXNlZCBvbiBwcm9qZWN0IHRva2VuIGFuZCBxdWV1ZSB0eXBlKS4gVGhlcmVmb3JlIGFjY2VzcyB0byB0aGVcbiAqIGxvY2FsU3RvcmFnZSBlbnRyeSBpcyBndWFyZGVkIGJ5IGFuIGFzeW5jaHJvbm91cyBtdXRleCAoU2hhcmVkTG9jaykgdG8gcHJldmVudFxuICogc2ltdWx0YW5lb3VzbHkgb3BlbiB3aW5kb3dzL3RhYnMgZnJvbSBvdmVyd3JpdGluZyBlYWNoIG90aGVyJ3MgZGF0YSAod2hpY2ggd291bGQgbGVhZFxuICogdG8gZGF0YSBsb3NzIGluIHNvbWUgc2l0dWF0aW9ucykuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJlcXVlc3RRdWV1ZSA9IGZ1bmN0aW9uIChzdG9yYWdlS2V5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5zdG9yYWdlS2V5ID0gc3RvcmFnZUtleTtcbiAgICB0aGlzLnVzZVBlcnNpc3RlbmNlID0gb3B0aW9ucy51c2VQZXJzaXN0ZW5jZTtcbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLnF1ZXVlU3RvcmFnZSA9IG9wdGlvbnMucXVldWVTdG9yYWdlIHx8IG5ldyBMb2NhbFN0b3JhZ2VXcmFwcGVyKCk7XG4gICAgICAgIHRoaXMubG9jayA9IG5ldyBTaGFyZWRMb2NrKHN0b3JhZ2VLZXksIHsgc3RvcmFnZTogb3B0aW9ucy5zaGFyZWRMb2NrU3RvcmFnZSB8fCB3aW5kb3cubG9jYWxTdG9yYWdlIH0pO1xuICAgICAgICB0aGlzLnF1ZXVlU3RvcmFnZS5pbml0KCk7XG4gICAgfVxuICAgIHRoaXMucmVwb3J0RXJyb3IgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXIgfHwgXy5iaW5kKGxvZ2dlciQzLmVycm9yLCBsb2dnZXIkMyk7XG5cbiAgICB0aGlzLnBpZCA9IG9wdGlvbnMucGlkIHx8IG51bGw7IC8vIHBhc3MgcGlkIHRvIHRlc3Qgb3V0IHN0b3JhZ2UgbG9jayBjb250ZW50aW9uIHNjZW5hcmlvc1xuXG4gICAgdGhpcy5tZW1RdWV1ZSA9IFtdO1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn07XG5cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuZW5zdXJlSW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2VcbiAgICAgICAgLmluaXQoKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBxdWV1ZSBwZXJzaXN0ZW5jZS4gRGlzYWJsaW5nIHBlcnNpc3RlbmNlJywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51c2VQZXJzaXN0ZW5jZSA9IGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIEFkZCBvbmUgaXRlbSB0byBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS4gVGhlIHF1ZXVlZCBlbnRyeSBpbmNsdWRlc1xuICogdGhlIGdpdmVuIGl0ZW0gYWxvbmcgd2l0aCBhbiBhdXRvLWdlbmVyYXRlZCBJRCBhbmQgYSBcImZsdXNoLWFmdGVyXCIgdGltZXN0YW1wLlxuICogSXQgaXMgZXhwZWN0ZWQgdGhhdCB0aGUgaXRlbSB3aWxsIGJlIHNlbnQgb3ZlciB0aGUgbmV0d29yayBhbmQgZGVxdWV1ZWRcbiAqIGJlZm9yZSB0aGUgZmx1c2gtYWZ0ZXIgdGltZTsgaWYgdGhpcyBkb2Vzbid0IGhhcHBlbiBpdCBpcyBjb25zaWRlcmVkIG9ycGhhbmVkXG4gKiAoZS5nLiwgdGhlIG9yaWdpbmFsIHRhYiB3aGVyZSBpdCB3YXMgZW5xdWV1ZWQgZ290IGNsb3NlZCBiZWZvcmUgaXQgY291bGQgYmVcbiAqIHNlbnQpIGFuZCB0aGUgaXRlbSBjYW4gYmUgc2VudCBieSBhbnkgdGFiIHRoYXQgZmluZHMgaXQgaW4gbG9jYWxTdG9yYWdlLlxuICpcbiAqIFRoZSBmaW5hbCBjYWxsYmFjayBwYXJhbSBpcyBjYWxsZWQgd2l0aCBhIHBhcmFtIGluZGljYXRpbmcgc3VjY2VzcyBvclxuICogZmFpbHVyZSBvZiB0aGUgZW5xdWV1ZSBvcGVyYXRpb247IGl0IGlzIGFzeW5jaHJvbm91cyBiZWNhdXNlIHRoZSBsb2NhbFN0b3JhZ2VcbiAqIGxvY2sgaXMgYXN5bmNocm9ub3VzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSwgZmx1c2hJbnRlcnZhbCkge1xuICAgIHZhciBxdWV1ZUVudHJ5ID0ge1xuICAgICAgICAnaWQnOiBjaGVhcF9ndWlkKCksXG4gICAgICAgICdmbHVzaEFmdGVyJzogbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBmbHVzaEludGVydmFsICogMixcbiAgICAgICAgJ3BheWxvYWQnOiBpdGVtXG4gICAgfTtcblxuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICB0aGlzLm1lbVF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIHZhciBlbnF1ZXVlSXRlbSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JlZFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JlZFF1ZXVlLnB1c2gocXVldWVFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgYWRkIHRvIGluLW1lbW9yeSBxdWV1ZSB3aGVuIHN0b3JhZ2Ugc3VjY2VlZHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW1RdWV1ZS5wdXNoKHF1ZXVlRW50cnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZWVkZWQ7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGVucXVldWVpbmcgaXRlbScsIGVyciwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2tcbiAgICAgICAgICAgIC53aXRoTG9jayhlbnF1ZXVlSXRlbSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIG91dCB0aGUgZ2l2ZW4gbnVtYmVyIG9mIHF1ZXVlIGVudHJpZXMuIElmIHRoaXMubWVtUXVldWVcbiAqIGhhcyBmZXdlciB0aGFuIGJhdGNoU2l6ZSBpdGVtcywgdGhlbiBsb29rIGZvciBcIm9ycGhhbmVkXCIgaXRlbXNcbiAqIGluIHRoZSBwZXJzaXN0ZWQgcXVldWUgKGl0ZW1zIHdoZXJlIHRoZSAnZmx1c2hBZnRlcicgdGltZSBoYXNcbiAqIGFscmVhZHkgcGFzc2VkKS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5maWxsQmF0Y2ggPSBmdW5jdGlvbiAoYmF0Y2hTaXplKSB7XG4gICAgdmFyIGJhdGNoID0gdGhpcy5tZW1RdWV1ZS5zbGljZSgwLCBiYXRjaFNpemUpO1xuICAgIGlmICh0aGlzLnVzZVBlcnNpc3RlbmNlICYmIGJhdGNoLmxlbmd0aCA8IGJhdGNoU2l6ZSkge1xuICAgICAgICAvLyBkb24ndCBuZWVkIGxvY2sganVzdCB0byByZWFkIGV2ZW50czsgbG9jYWxTdG9yYWdlIGlzIHRocmVhZC1zYWZlXG4gICAgICAgIC8vIGFuZCB0aGUgd29yc3QgdGhhdCBjb3VsZCBoYXBwZW4gaXMgYSBkdXBsaWNhdGUgc2VuZCBvZiBzb21lXG4gICAgICAgIC8vIG9ycGhhbmVkIGV2ZW50cywgd2hpY2ggd2lsbCBiZSBkZWR1cGxpY2F0ZWQgb24gdGhlIHNlcnZlciBzaWRlXG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZWFkRnJvbVN0b3JhZ2UoKTtcbiAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBpdGVtIElEcyBhbHJlYWR5IGluIGJhdGNoOyBkb24ndCBkdXBsaWNhdGUgb3V0IG9mIHN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkc0luQmF0Y2ggPSB7fTsgLy8gcG9vciBtYW4ncyBTZXRcbiAgICAgICAgICAgICAgICAgICAgXy5lYWNoKGJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWRzSW5CYXRjaFtpdGVtWydpZCddXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3IERhdGUoKS5nZXRUaW1lKCkgPiBpdGVtWydmbHVzaEFmdGVyJ10gJiYgIWlkc0luQmF0Y2hbaXRlbVsnaWQnXV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLm9ycGhhbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaC5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPj0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBiYXRjaDtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoYmF0Y2gpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIGl0ZW1zIHdpdGggbWF0Y2hpbmcgJ2lkJyBmcm9tIGFycmF5IChpbW11dGFibHkpXG4gKiBhbHNvIHJlbW92ZSBhbnkgaXRlbSB3aXRob3V0IGEgdmFsaWQgaWQgKGUuZy4sIG1hbGZvcm1lZFxuICogc3RvcmFnZSBlbnRyaWVzKS5cbiAqL1xudmFyIGZpbHRlck91dElEc0FuZEludmFsaWQgPSBmdW5jdGlvbiAoaXRlbXMsIGlkU2V0KSB7XG4gICAgdmFyIGZpbHRlcmVkSXRlbXMgPSBbXTtcbiAgICBfLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtWydpZCddICYmICFpZFNldFtpdGVtWydpZCddXSkge1xuICAgICAgICAgICAgZmlsdGVyZWRJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkSXRlbXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBpdGVtcyB3aXRoIG1hdGNoaW5nIElEcyBmcm9tIGJvdGggaW4tbWVtb3J5IHF1ZXVlXG4gKiBhbmQgcGVyc2lzdGVkIHF1ZXVlXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUucmVtb3ZlSXRlbXNCeUlEID0gZnVuY3Rpb24gKGlkcykge1xuICAgIHZhciBpZFNldCA9IHt9OyAvLyBwb29yIG1hbidzIFNldFxuICAgIF8uZWFjaChpZHMsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZFNldFtpZF0gPSB0cnVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5tZW1RdWV1ZSA9IGZpbHRlck91dElEc0FuZEludmFsaWQodGhpcy5tZW1RdWV1ZSwgaWRTZXQpO1xuICAgIGlmICghdGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlbW92ZUZyb21TdG9yYWdlID0gXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUluaXQoKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSBmaWx0ZXJPdXRJRHNBbmRJbnZhbGlkKHN0b3JlZFF1ZXVlLCBpZFNldCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVUb1N0b3JhZ2Uoc3RvcmVkUXVldWUpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoc3RvcmVkUXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gZXh0cmEgY2hlY2s6IGRpZCBzdG9yYWdlIHJlcG9ydCBzdWNjZXNzIGJ1dCBzb21laG93XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBpdGVtcyBhcmUgc3RpbGwgdGhlcmU/XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RvcmVkUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gc3RvcmVkUXVldWVbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVsnaWQnXSAmJiAhIWlkU2V0W2l0ZW1bJ2lkJ11dKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJdGVtIG5vdCByZW1vdmVkIGZyb20gc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciByZW1vdmluZyBpdGVtcycsIGVyciwgaWRzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubG9ja1xuICAgICAgICAgICAgLndpdGhMb2NrKHJlbW92ZUZyb21TdG9yYWdlLCB0aGlzLnBpZClcbiAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGFjcXVpcmluZyBzdG9yYWdlIGxvY2snLCBlcnIpO1xuICAgICAgICAgICAgICAgIGlmICghbG9jYWxTdG9yYWdlU3VwcG9ydGVkKHRoaXMucXVldWVTdG9yYWdlLnN0b3JhZ2UsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExvb2tzIGxpa2UgbG9jYWxTdG9yYWdlIHdyaXRlcyBoYXZlIHN0b3BwZWQgd29ya2luZyBzb21ldGltZSBhZnRlclxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWFsaXphdGlvbiAocHJvYmFibHkgZnVsbCksIGFuZCBzbyBub2JvZHkgY2FuIGFjcXVpcmUgbG9ja3NcbiAgICAgICAgICAgICAgICAgICAgLy8gYW55bW9yZS4gQ29uc2lkZXIgaXQgdGVtcG9yYXJpbHkgc2FmZSB0byByZW1vdmUgaXRlbXMgd2l0aG91dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gbG9jaywgc2luY2Ugbm9ib2R5J3Mgd3JpdGluZyBzdWNjZXNzZnVsbHkgYW55d2F5LlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlRnJvbVN0b3JhZ2UoKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE9LLCB3ZSBjb3VsZG4ndCBldmVuIHdyaXRlIG91dCB0aGUgc21hbGxlciBxdWV1ZS4gVHJ5IGNsZWFyaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZVN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3VjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgY2xlYXJpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgIH1cbn07XG5cbi8vIGludGVybmFsIGhlbHBlciBmb3IgUmVxdWVzdFF1ZXVlLnVwZGF0ZVBheWxvYWRzXG52YXIgdXBkYXRlUGF5bG9hZHMgPSBmdW5jdGlvbiAoZXhpc3RpbmdJdGVtcywgaXRlbXNUb1VwZGF0ZSkge1xuICAgIHZhciBuZXdJdGVtcyA9IFtdO1xuICAgIF8uZWFjaChleGlzdGluZ0l0ZW1zLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICB2YXIgaWQgPSBpdGVtWydpZCddO1xuICAgICAgICBpZiAoaWQgaW4gaXRlbXNUb1VwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIG5ld1BheWxvYWQgPSBpdGVtc1RvVXBkYXRlW2lkXTtcbiAgICAgICAgICAgIGlmIChuZXdQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaXRlbVsncGF5bG9hZCddID0gbmV3UGF5bG9hZDtcbiAgICAgICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gbm8gdXBkYXRlXG4gICAgICAgICAgICBuZXdJdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0l0ZW1zO1xufTtcblxuLyoqXG4gKiBVcGRhdGUgcGF5bG9hZHMgb2YgZ2l2ZW4gaXRlbXMgaW4gYm90aCBpbi1tZW1vcnkgcXVldWUgYW5kXG4gKiBwZXJzaXN0ZWQgcXVldWUuIEl0ZW1zIHNldCB0byBudWxsIGFyZSByZW1vdmVkIGZyb20gcXVldWVzLlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnVwZGF0ZVBheWxvYWRzID0gZnVuY3Rpb24gKGl0ZW1zVG9VcGRhdGUpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gdXBkYXRlUGF5bG9hZHModGhpcy5tZW1RdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgaWYgKCF0aGlzLnVzZVBlcnNpc3RlbmNlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NrXG4gICAgICAgICAgICAud2l0aExvY2soXy5iaW5kKGZ1bmN0aW9uIGxvY2tBY3F1aXJlZCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlYWRGcm9tU3RvcmFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uIChzdG9yZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVkUXVldWUgPSB1cGRhdGVQYXlsb2FkcyhzdG9yZWRRdWV1ZSwgaXRlbXNUb1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlVG9TdG9yYWdlKHN0b3JlZFF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgdXBkYXRpbmcgaXRlbXMnLCBpdGVtc1RvVXBkYXRlLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgICAgICAgICB9LCB0aGlzKSwgdGhpcy5waWQpXG4gICAgICAgICAgICAuY2F0Y2goXy5iaW5kKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBhY3F1aXJpbmcgc3RvcmFnZSBsb2NrJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LCB0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWFkIGFuZCBwYXJzZSBpdGVtcyBhcnJheSBmcm9tIGxvY2FsU3RvcmFnZSBlbnRyeSwgaGFuZGxpbmdcbiAqIG1hbGZvcm1lZC9taXNzaW5nIGRhdGEgaWYgbmVjZXNzYXJ5LlxuICovXG5SZXF1ZXN0UXVldWUucHJvdG90eXBlLnJlYWRGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5nZXRJdGVtKHRoaXMuc3RvcmFnZUtleSk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgaWYgKHN0b3JhZ2VFbnRyeSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IEpTT05QYXJzZShzdG9yYWdlRW50cnkpO1xuICAgICAgICAgICAgICAgIGlmICghXy5pc0FycmF5KHN0b3JhZ2VFbnRyeSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignSW52YWxpZCBzdG9yYWdlIGVudHJ5OicsIHN0b3JhZ2VFbnRyeSk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VFbnRyeSB8fCBbXTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3IgcmV0cmlldmluZyBxdWV1ZScsIGVycik7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0sIHRoaXMpKTtcbn07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBpdGVtcyBhcnJheSB0byBsb2NhbFN0b3JhZ2UuXG4gKi9cblJlcXVlc3RRdWV1ZS5wcm90b3R5cGUuc2F2ZVRvU3RvcmFnZSA9IGZ1bmN0aW9uIChxdWV1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBzZXJpYWxpemVkID0gSlNPTlN0cmluZ2lmeShxdWV1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHNlcmlhbGl6aW5nIHF1ZXVlJywgZXJyKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnF1ZXVlU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgc2VyaWFsaXplZCk7XG4gICAgICAgIH0sIHRoaXMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSlcbiAgICAgICAgLmNhdGNoKF8uYmluZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBzYXZpbmcgcXVldWUnLCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIENsZWFyIG91dCBxdWV1ZXMgKG1lbW9yeSBhbmQgbG9jYWxTdG9yYWdlKS5cbiAqL1xuUmVxdWVzdFF1ZXVlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLm1lbVF1ZXVlID0gW107XG5cbiAgICBpZiAodGhpcy51c2VQZXJzaXN0ZW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVJbml0KClcbiAgICAgICAgICAgIC50aGVuKF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVTdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yYWdlS2V5KTtcbiAgICAgICAgICAgIH0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICB9XG59O1xuXG4vLyBtYXhpbXVtIGludGVydmFsIGJldHdlZW4gcmVxdWVzdCByZXRyaWVzIGFmdGVyIGV4cG9uZW50aWFsIGJhY2tvZmZcbnZhciBNQVhfUkVUUllfSU5URVJWQUxfTVMgPSAxMCAqIDYwICogMTAwMDsgLy8gMTAgbWludXRlc1xuXG52YXIgbG9nZ2VyJDIgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdiYXRjaCcpO1xuXG4vKipcbiAqIFJlcXVlc3RCYXRjaGVyOiBtYW5hZ2VzIHRoZSBxdWV1ZWluZywgZmx1c2hpbmcsIHJldHJ5IGV0YyBvZiByZXF1ZXN0cyBvZiBvbmVcbiAqIHR5cGUgKGV2ZW50cywgcGVvcGxlLCBncm91cHMpLlxuICogVXNlcyBSZXF1ZXN0UXVldWUgdG8gbWFuYWdlIHRoZSBiYWNraW5nIHN0b3JlLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0QmF0Y2hlciA9IGZ1bmN0aW9uKHN0b3JhZ2VLZXksIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVycm9yUmVwb3J0ZXIgPSBvcHRpb25zLmVycm9yUmVwb3J0ZXI7XG4gICAgdGhpcy5xdWV1ZSA9IG5ldyBSZXF1ZXN0UXVldWUoc3RvcmFnZUtleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiBfLmJpbmQodGhpcy5yZXBvcnRFcnJvciwgdGhpcyksXG4gICAgICAgIHF1ZXVlU3RvcmFnZTogb3B0aW9ucy5xdWV1ZVN0b3JhZ2UsXG4gICAgICAgIHNoYXJlZExvY2tTdG9yYWdlOiBvcHRpb25zLnNoYXJlZExvY2tTdG9yYWdlLFxuICAgICAgICB1c2VQZXJzaXN0ZW5jZTogb3B0aW9ucy51c2VQZXJzaXN0ZW5jZVxuICAgIH0pO1xuXG4gICAgdGhpcy5saWJDb25maWcgPSBvcHRpb25zLmxpYkNvbmZpZztcbiAgICB0aGlzLnNlbmRSZXF1ZXN0ID0gb3B0aW9ucy5zZW5kUmVxdWVzdEZ1bmM7XG4gICAgdGhpcy5iZWZvcmVTZW5kSG9vayA9IG9wdGlvbnMuYmVmb3JlU2VuZEhvb2s7XG4gICAgdGhpcy5zdG9wQWxsQmF0Y2hpbmcgPSBvcHRpb25zLnN0b3BBbGxCYXRjaGluZ0Z1bmM7XG5cbiAgICAvLyBzZWVkIHZhcmlhYmxlIGJhdGNoIHNpemUgKyBmbHVzaCBpbnRlcnZhbCB3aXRoIGNvbmZpZ3VyZWQgdmFsdWVzXG4gICAgdGhpcy5iYXRjaFNpemUgPSB0aGlzLmxpYkNvbmZpZ1snYmF0Y2hfc2l6ZSddO1xuICAgIHRoaXMuZmx1c2hJbnRlcnZhbCA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyddO1xuXG4gICAgdGhpcy5zdG9wcGVkID0gIXRoaXMubGliQ29uZmlnWydiYXRjaF9hdXRvc3RhcnQnXTtcbiAgICB0aGlzLmNvbnNlY3V0aXZlUmVtb3ZhbEZhaWx1cmVzID0gMDtcblxuICAgIC8vIGV4dHJhIGNsaWVudC1zaWRlIGRlZHVwZVxuICAgIHRoaXMuaXRlbUlkc1NlbnRTdWNjZXNzZnVsbHkgPSB7fTtcblxuICAgIC8vIE1ha2UgdGhlIGZsdXNoIG9jY3VyIGF0IHRoZSBpbnRlcnZhbCBzcGVjaWZpZWQgYnkgZmx1c2hJbnRlcnZhbE1zLCBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYXR0ZW1wdCBjb25zZWN1dGl2ZSBmbHVzaGVzXG4gICAgLy8gYXMgbG9uZyBhcyB0aGUgcXVldWUgaXMgbm90IGVtcHR5LiBUaGlzIGlzIHVzZWZ1bCBmb3IgaGlnaC1mcmVxdWVuY3kgZXZlbnRzIGxpa2UgU2Vzc2lvbiBSZXBsYXkgd2hlcmUgd2UgbWlnaHQgZW5kIHVwXG4gICAgLy8gaW4gYSByZXF1ZXN0IGxvb3AgYW5kIGdldCByYXRlbGltaXRlZCBieSB0aGUgc2VydmVyLlxuICAgIHRoaXMuZmx1c2hPbmx5T25JbnRlcnZhbCA9IG9wdGlvbnMuZmx1c2hPbmx5T25JbnRlcnZhbCB8fCBmYWxzZTtcbn07XG5cbi8qKlxuICogQWRkIG9uZSBpdGVtIHRvIHF1ZXVlLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuZW5xdWV1ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZS5lbnF1ZXVlKGl0ZW0sIHRoaXMuZmx1c2hJbnRlcnZhbCk7XG59O1xuXG4vKipcbiAqIFN0YXJ0IGZsdXNoaW5nIGJhdGNoZXMgYXQgdGhlIGNvbmZpZ3VyZWQgdGltZSBpbnRlcnZhbC4gTXVzdCBjYWxsXG4gKiB0aGlzIG1ldGhvZCB1cG9uIFNESyBpbml0IGluIG9yZGVyIHRvIHNlbmQgYW55dGhpbmcgb3ZlciB0aGUgbmV0d29yay5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG4gICAgcmV0dXJuIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogU3RvcCBmbHVzaGluZyBiYXRjaGVzLiBDYW4gYmUgcmVzdGFydGVkIGJ5IGNhbGxpbmcgc3RhcnQoKS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLnRpbWVvdXRJRCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SUQpO1xuICAgICAgICB0aGlzLnRpbWVvdXRJRCA9IG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDbGVhciBvdXQgcXVldWUuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnF1ZXVlLmNsZWFyKCk7XG59O1xuXG4vKipcbiAqIFJlc3RvcmUgYmF0Y2ggc2l6ZSBjb25maWd1cmF0aW9uIHRvIHdoYXRldmVyIGlzIHNldCBpbiB0aGUgbWFpbiBTREsuXG4gKi9cblJlcXVlc3RCYXRjaGVyLnByb3RvdHlwZS5yZXNldEJhdGNoU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYmF0Y2hTaXplID0gdGhpcy5saWJDb25maWdbJ2JhdGNoX3NpemUnXTtcbn07XG5cbi8qKlxuICogUmVzdG9yZSBmbHVzaCBpbnRlcnZhbCB0aW1lIGNvbmZpZ3VyYXRpb24gdG8gd2hhdGV2ZXIgaXMgc2V0IGluIHRoZSBtYWluIFNESy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnJlc2V0Rmx1c2ggPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjaGVkdWxlRmx1c2godGhpcy5saWJDb25maWdbJ2JhdGNoX2ZsdXNoX2ludGVydmFsX21zJ10pO1xufTtcblxuLyoqXG4gKiBTY2hlZHVsZSB0aGUgbmV4dCBmbHVzaCBpbiB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcy5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnNjaGVkdWxlRmx1c2ggPSBmdW5jdGlvbihmbHVzaE1TKSB7XG4gICAgdGhpcy5mbHVzaEludGVydmFsID0gZmx1c2hNUztcbiAgICBpZiAoIXRoaXMuc3RvcHBlZCkgeyAvLyBkb24ndCBzY2hlZHVsZSBhbnltb3JlIGlmIGJhdGNoaW5nIGhhcyBiZWVuIHN0b3BwZWRcbiAgICAgICAgdGhpcy50aW1lb3V0SUQgPSBzZXRUaW1lb3V0KF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSwgdGhpcy5mbHVzaEludGVydmFsKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNlbmQgYSByZXF1ZXN0IHVzaW5nIHRoZSBzZW5kUmVxdWVzdCBjYWxsYmFjaywgYnV0IHByb21pc2lmaWVkLlxuICogVE9ETzogc2VuZFJlcXVlc3Qgc2hvdWxkIGJlIHByb21pc2lmaWVkIGluIHRoZSBmaXJzdCBwbGFjZS5cbiAqL1xuUmVxdWVzdEJhdGNoZXIucHJvdG90eXBlLnNlbmRSZXF1ZXN0UHJvbWlzZSA9IGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2VQb2x5ZmlsbChfLmJpbmQoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgICB0aGlzLnNlbmRSZXF1ZXN0KGRhdGEsIG9wdGlvbnMsIHJlc29sdmUpO1xuICAgIH0sIHRoaXMpKTtcbn07XG5cblxuLyoqXG4gKiBGbHVzaCBvbmUgYmF0Y2ggdG8gbmV0d29yay4gRGVwZW5kaW5nIG9uIHN1Y2Nlc3MvZmFpbHVyZSBtb2RlcywgaXQgd2lsbCBlaXRoZXJcbiAqIHJlbW92ZSB0aGUgYmF0Y2ggZnJvbSB0aGUgcXVldWUgb3IgbGVhdmUgaXQgaW4gZm9yIHJldHJ5LCBhbmQgc2NoZWR1bGUgdGhlIG5leHRcbiAqIGZsdXNoLiBJbiBjYXNlcyBvZiBtb3N0IG5ldHdvcmsgb3IgQVBJIGZhaWx1cmVzLCBpdCB3aWxsIGJhY2sgb2ZmIGV4cG9uZW50aWFsbHlcbiAqIHdoZW4gcmV0cnlpbmcuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRCZWFjb25dIC0gd2hldGhlciB0byBzZW5kIGJhdGNoIHdpdGhcbiAqIG5hdmlnYXRvci5zZW5kQmVhY29uIChvbmx5IHVzZWZ1bCBmb3Igc2VuZGluZyBiYXRjaGVzIGJlZm9yZSBwYWdlIHVubG9hZHMsIGFzXG4gKiBzZW5kQmVhY29uIG9mZmVycyBubyBjYWxsYmFja3Mgb3Igc3RhdHVzIGluZGljYXRpb25zKVxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MpIHtcbiAgICAgICAgbG9nZ2VyJDIubG9nKCdGbHVzaDogUmVxdWVzdCBhbHJlYWR5IGluIHByb2dyZXNzJyk7XG4gICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHRoaXMucmVxdWVzdEluUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHRpbWVvdXRNUyA9IHRoaXMubGliQ29uZmlnWydiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXMnXTtcbiAgICB2YXIgc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdmFyIGN1cnJlbnRCYXRjaFNpemUgPSB0aGlzLmJhdGNoU2l6ZTtcblxuICAgIHJldHVybiB0aGlzLnF1ZXVlLmZpbGxCYXRjaChjdXJyZW50QmF0Y2hTaXplKVxuICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24oYmF0Y2gpIHtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUncyBtb3JlIGl0ZW1zIGluIHRoZSBxdWV1ZSB0aGFuIHRoZSBiYXRjaCBzaXplLCBhdHRlbXB0XG4gICAgICAgICAgICAvLyB0byBmbHVzaCBhZ2FpbiBhZnRlciB0aGUgY3VycmVudCBiYXRjaCBpcyBkb25lLlxuICAgICAgICAgICAgdmFyIGF0dGVtcHRTZWNvbmRhcnlGbHVzaCA9IGJhdGNoLmxlbmd0aCA9PT0gY3VycmVudEJhdGNoU2l6ZTtcbiAgICAgICAgICAgIHZhciBkYXRhRm9yUmVxdWVzdCA9IFtdO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybWVkSXRlbXMgPSB7fTtcbiAgICAgICAgICAgIF8uZWFjaChiYXRjaCwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gaXRlbVsncGF5bG9hZCddO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJlZm9yZVNlbmRIb29rICYmICFpdGVtLm9ycGhhbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQgPSB0aGlzLmJlZm9yZVNlbmRIb29rKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF5bG9hZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtcF9zZW50X2J5X2xpYl92ZXJzaW9uIHByb3AgY2FwdHVyZXMgd2hpY2ggbGliIHZlcnNpb24gYWN0dWFsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gc2VuZHMgZWFjaCBldmVudCAocmVnYXJkbGVzcyBvZiB3aGljaCB2ZXJzaW9uIG9yaWdpbmFsbHkgcXVldWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGZvciBzZW5kaW5nKVxuICAgICAgICAgICAgICAgICAgICBpZiAocGF5bG9hZFsnZXZlbnQnXSAmJiBwYXlsb2FkWydwcm9wZXJ0aWVzJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSA9IF8uZXh0ZW5kKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRbJ3Byb3BlcnRpZXMnXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J21wX3NlbnRfYnlfbGliX3ZlcnNpb24nOiBDb25maWcuTElCX1ZFUlNJT059XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRQYXlsb2FkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdIHx8IDApID4gNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1tkdXBlXSBpdGVtIElEIHNlbnQgdG9vIG1hbnkgdGltZXMsIG5vdCBzZW5kaW5nJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXRjaFNpemU6IGJhdGNoLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXNTZW50OiB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXlsb2FkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gZm91bmQgaXRlbSB3aXRoIG5vIElEJywge2l0ZW06IGl0ZW19KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGRQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhRm9yUmVxdWVzdC5wdXNoKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkSXRlbXNbaXRlbVsnaWQnXV0gPSBwYXlsb2FkO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChkYXRhRm9yUmVxdWVzdC5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0SW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpOyAvLyBub3RoaW5nIHRvIGRvXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVJdGVtc0Zyb21RdWV1ZSA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWVcbiAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUl0ZW1zQnlJRChcbiAgICAgICAgICAgICAgICAgICAgICAgIF8ubWFwKGJhdGNoLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtWydpZCddO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihfLmJpbmQoZnVuY3Rpb24gKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LXNpZGUgZGVkdXBlXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmVhY2goYmF0Y2gsIF8uYmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW1JZCA9IGl0ZW1bJ2lkJ107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gPSB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pdGVtSWRzU2VudFN1Y2Nlc3NmdWxseVtpdGVtSWRdKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF0gPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdbZHVwZV0gaXRlbSBJRCBzZW50IHRvbyBtYW55IHRpbWVzJywge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmF0Y2hTaXplOiBiYXRjaC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXNTZW50OiB0aGlzLml0ZW1JZHNTZW50U3VjY2Vzc2Z1bGx5W2l0ZW1JZF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignW2R1cGVdIGZvdW5kIGl0ZW0gd2l0aCBubyBJRCB3aGlsZSByZW1vdmluZycsIHtpdGVtOiBpdGVtfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2VlZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zZWN1dGl2ZVJlbW92YWxGYWlsdXJlcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmx1c2hPbmx5T25JbnRlcnZhbCAmJiAhYXR0ZW1wdFNlY29uZGFyeUZsdXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpOyAvLyBzY2hlZHVsZSBuZXh0IGJhdGNoIHdpdGggYSBkZWxheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mbHVzaCgpOyAvLyBoYW5kbGUgbmV4dCBiYXRjaCBpZiB0aGUgcXVldWUgaXNuJ3QgZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK3RoaXMuY29uc2VjdXRpdmVSZW1vdmFsRmFpbHVyZXMgPiA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1RvbyBtYW55IHF1ZXVlIGZhaWx1cmVzOyBkaXNhYmxpbmcgYmF0Y2hpbmcgc3lzdGVtLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BBbGxCYXRjaGluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZVBvbHlmaWxsLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHZhciBiYXRjaFNlbmRDYWxsYmFjayA9IF8uYmluZChmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBBUEkgcmVzcG9uc2UgaW4gYSB0cnktY2F0Y2ggdG8gbWFrZSBzdXJlIHdlIGNhbiByZXNldCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZmx1c2ggb3BlcmF0aW9uIGlmIHNvbWV0aGluZyBnb2VzIHdyb25nXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudW5sb2FkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGUgcGVyc2lzdGVkIGRhdGEgdG8gaW5jbHVkZSBob29rIHRyYW5zZm9ybWF0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVldWUudXBkYXRlUGF5bG9hZHModHJhbnNmb3JtZWRJdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzT2JqZWN0KHJlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMuZXJyb3IgPT09ICd0aW1lb3V0JyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRUaW1lID49IHRpbWVvdXRNU1xuICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ05ldHdvcmsgdGltZW91dDsgcmV0cnlpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICAgICAgICBfLmlzT2JqZWN0KHJlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5odHRwU3RhdHVzQ29kZSA+PSA1MDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgcmVzLmh0dHBTdGF0dXNDb2RlID09PSA0MjlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHJlcy5odHRwU3RhdHVzQ29kZSA8PSAwICYmICFpc09ubGluZSgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCByZXMuZXJyb3IgPT09ICd0aW1lb3V0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXR3b3JrIG9yIEFQSSBlcnJvciwgb3IgNDI5IFRvbyBNYW55IFJlcXVlc3RzLCByZXRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHJ5TVMgPSB0aGlzLmZsdXNoSW50ZXJ2YWwgKiAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5yZXRyeUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlNUyA9IChwYXJzZUludChyZXMucmV0cnlBZnRlciwgMTApICogMTAwMCkgfHwgcmV0cnlNUztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJ5TVMgPSBNYXRoLm1pbihNQVhfUkVUUllfSU5URVJWQUxfTVMsIHJldHJ5TVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBvcnRFcnJvcignRXJyb3I7IHJldHJ5IGluICcgKyByZXRyeU1TICsgJyBtcycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUZsdXNoKHJldHJ5TVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2VQb2x5ZmlsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChyZXMpICYmIHJlcy5odHRwU3RhdHVzQ29kZSA9PT0gNDEzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyA0MTMgUGF5bG9hZCBUb28gTGFyZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhbHZlZEJhdGNoU2l6ZSA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoY3VycmVudEJhdGNoU2l6ZSAvIDIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJhdGNoU2l6ZSA9IE1hdGgubWluKHRoaXMuYmF0Y2hTaXplLCBoYWx2ZWRCYXRjaFNpemUsIGJhdGNoLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJzQxMyByZXNwb25zZTsgcmVkdWNpbmcgYmF0Y2ggc2l6ZSB0byAnICsgdGhpcy5iYXRjaFNpemUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlUG9seWZpbGwucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdTaW5nbGUtZXZlbnQgcmVxdWVzdCB0b28gbGFyZ2U7IGRyb3BwaW5nJywgYmF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRCYXRjaFNpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbXNGcm9tUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3NmdWwgbmV0d29yayByZXF1ZXN0K3Jlc3BvbnNlOyByZW1vdmUgZWFjaCBpdGVtIGluIGJhdGNoIGZyb20gcXVldWVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIChldmVuIGlmIGl0IHdhcyBlLmcuIGEgNDAwLCBpbiB3aGljaCBjYXNlIHJldHJ5aW5nIHdvbid0IGhlbHApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVtb3ZlSXRlbXNGcm9tUXVldWUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIGhhbmRsaW5nIEFQSSByZXNwb25zZScsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIHZlcmJvc2U6IHRydWUsXG4gICAgICAgICAgICAgICAgaWdub3JlX2pzb25fZXJyb3JzOiB0cnVlLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgICAgIHRpbWVvdXRfbXM6IHRpbWVvdXRNUyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVubG9hZGluZykge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnRyYW5zcG9ydCA9ICdzZW5kQmVhY29uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlciQyLmxvZygnTUlYUEFORUwgUkVRVUVTVDonLCBkYXRhRm9yUmVxdWVzdCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdFByb21pc2UoZGF0YUZvclJlcXVlc3QsIHJlcXVlc3RPcHRpb25zKS50aGVuKGJhdGNoU2VuZENhbGxiYWNrKTtcbiAgICAgICAgfSwgdGhpcykpXG4gICAgICAgIC5jYXRjaChfLmJpbmQoZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9ydEVycm9yKCdFcnJvciBmbHVzaGluZyByZXF1ZXN0IHF1ZXVlJywgZXJyKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRGbHVzaCgpO1xuICAgICAgICB9LCB0aGlzKSk7XG59O1xuXG4vKipcbiAqIExvZyBlcnJvciB0byBnbG9iYWwgbG9nZ2VyIGFuZCBvcHRpb25hbCB1c2VyLWRlZmluZWQgbG9nZ2VyLlxuICovXG5SZXF1ZXN0QmF0Y2hlci5wcm90b3R5cGUucmVwb3J0RXJyb3IgPSBmdW5jdGlvbihtc2csIGVycikge1xuICAgIGxvZ2dlciQyLmVycm9yLmFwcGx5KGxvZ2dlciQyLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIGlmICh0aGlzLmVycm9yUmVwb3J0ZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lcnJvclJlcG9ydGVyKG1zZywgZXJyKTtcbiAgICAgICAgfSBjYXRjaChlcnIpIHtcbiAgICAgICAgICAgIGxvZ2dlciQyLmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgbG9nZ2VyJDEgPSBjb25zb2xlX3dpdGhfcHJlZml4KCdyZWNvcmRlcicpO1xudmFyIENvbXByZXNzaW9uU3RyZWFtID0gd2luWydDb21wcmVzc2lvblN0cmVhbSddO1xuXG52YXIgUkVDT1JERVJfQkFUQ0hFUl9MSUJfQ09ORklHID0ge1xuICAgICdiYXRjaF9zaXplJzogMTAwMCxcbiAgICAnYmF0Y2hfZmx1c2hfaW50ZXJ2YWxfbXMnOiAxMCAqIDEwMDAsXG4gICAgJ2JhdGNoX3JlcXVlc3RfdGltZW91dF9tcyc6IDkwICogMTAwMCxcbiAgICAnYmF0Y2hfYXV0b3N0YXJ0JzogdHJ1ZVxufTtcblxudmFyIEFDVElWRV9TT1VSQ0VTID0gbmV3IFNldChbXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuTW91c2VNb3ZlLFxuICAgIEluY3JlbWVudGFsU291cmNlLk1vdXNlSW50ZXJhY3Rpb24sXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuU2Nyb2xsLFxuICAgIEluY3JlbWVudGFsU291cmNlLlZpZXdwb3J0UmVzaXplLFxuICAgIEluY3JlbWVudGFsU291cmNlLklucHV0LFxuICAgIEluY3JlbWVudGFsU291cmNlLlRvdWNoTW92ZSxcbiAgICBJbmNyZW1lbnRhbFNvdXJjZS5NZWRpYUludGVyYWN0aW9uLFxuICAgIEluY3JlbWVudGFsU291cmNlLkRyYWcsXG4gICAgSW5jcmVtZW50YWxTb3VyY2UuU2VsZWN0aW9uLFxuXSk7XG5cbmZ1bmN0aW9uIGlzVXNlckV2ZW50KGV2KSB7XG4gICAgcmV0dXJuIGV2LnR5cGUgPT09IEV2ZW50VHlwZS5JbmNyZW1lbnRhbFNuYXBzaG90ICYmIEFDVElWRV9TT1VSQ0VTLmhhcyhldi5kYXRhLnNvdXJjZSk7XG59XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgYSBzaW5nbGUgc2Vzc2lvbiByZWNvcmRpbmcgYW5kIGl0cyBsaWZlY3ljbGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMubWl4cGFuZWxJbnN0YW5jZV0gLSByZWZlcmVuY2UgdG8gdGhlIGNvcmUgTWl4cGFuZWxMaWJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZXBsYXlJZF0gLSB1bmlxdWUgdXVpZCBmb3IgYSBzaW5nbGUgcmVwbGF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5vbklkbGVUaW1lb3V0XSAtIGNhbGxiYWNrIHdoZW4gYSByZWNvcmRpbmcgcmVhY2hlcyBpZGxlIHRpbWVvdXRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uTWF4TGVuZ3RoUmVhY2hlZF0gLSBjYWxsYmFjayB3aGVuIGEgcmVjb3JkaW5nIHJlYWNoZXMgaXRzIG1heGltdW0gbGVuZ3RoXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5ycndlYlJlY29yZF0gLSBycndlYidzIGByZWNvcmRgIGZ1bmN0aW9uXG4gKi9cbnZhciBTZXNzaW9uUmVjb3JkaW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMuX21peHBhbmVsID0gb3B0aW9ucy5taXhwYW5lbEluc3RhbmNlO1xuICAgIHRoaXMuX29uSWRsZVRpbWVvdXQgPSBvcHRpb25zLm9uSWRsZVRpbWVvdXQ7XG4gICAgdGhpcy5fb25NYXhMZW5ndGhSZWFjaGVkID0gb3B0aW9ucy5vbk1heExlbmd0aFJlYWNoZWQ7XG4gICAgdGhpcy5fcnJ3ZWJSZWNvcmQgPSBvcHRpb25zLnJyd2ViUmVjb3JkO1xuXG4gICAgdGhpcy5yZXBsYXlJZCA9IG9wdGlvbnMucmVwbGF5SWQ7XG5cbiAgICAvLyBpbnRlcm5hbCBycndlYiBzdG9wUmVjb3JkaW5nIGZ1bmN0aW9uXG4gICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG5cbiAgICB0aGlzLnNlcU5vID0gMDtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VGltZSA9IG51bGw7XG4gICAgdGhpcy5yZXBsYXlTdGFydFVybCA9IG51bGw7XG4gICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gbnVsbDtcblxuICAgIHRoaXMuaWRsZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgdGhpcy5tYXhUaW1lb3V0SWQgPSBudWxsO1xuXG4gICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IDA7XG5cbiAgICAvLyBlYWNoIHJlcGxheSBoYXMgaXRzIG93biBiYXRjaGVyIGtleSB0byBhdm9pZCBjb25mbGljdHMgYmV0d2VlbiBycndlYiBldmVudHMgb2YgZGlmZmVyZW50IHJlY29yZGluZ3NcbiAgICAvLyB0aGlzIHdpbGwgYmUgaW1wb3J0YW50IHdoZW4gcGVyc2lzdGVuY2UgaXMgaW50cm9kdWNlZFxuICAgIHZhciBiYXRjaGVyS2V5ID0gJ19fbXByZWNfJyArIHRoaXMuZ2V0Q29uZmlnKCd0b2tlbicpICsgJ18nICsgdGhpcy5yZXBsYXlJZDtcbiAgICB0aGlzLmJhdGNoZXIgPSBuZXcgUmVxdWVzdEJhdGNoZXIoYmF0Y2hlcktleSwge1xuICAgICAgICBlcnJvclJlcG9ydGVyOiBfLmJpbmQodGhpcy5yZXBvcnRFcnJvciwgdGhpcyksXG4gICAgICAgIGZsdXNoT25seU9uSW50ZXJ2YWw6IHRydWUsXG4gICAgICAgIGxpYkNvbmZpZzogUkVDT1JERVJfQkFUQ0hFUl9MSUJfQ09ORklHLFxuICAgICAgICBzZW5kUmVxdWVzdEZ1bmM6IF8uYmluZCh0aGlzLmZsdXNoRXZlbnRzV2l0aE9wdE91dCwgdGhpcyksXG4gICAgICAgIHVzZVBlcnNpc3RlbmNlOiBmYWxzZVxuICAgIH0pO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZ2V0Q29uZmlnID0gZnVuY3Rpb24oY29uZmlnVmFyKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZmlnVmFyKTtcbn07XG5cbi8vIEFsaWFzIGZvciBnZXRDb25maWcsIHVzZWQgYnkgdGhlIGNvbW1vbiBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGZ1bmN0aW9uIHdoaWNoXG4vLyByZWFjaGVzIGludG8gdGhpcyBjbGFzcyBpbnN0YW5jZSBhbmQgZXhwZWN0cyB0aGUgc25ha2UgY2FzZSB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbi5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLmdldF9jb25maWcgPSBmdW5jdGlvbihjb25maWdWYXIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDb25maWcoY29uZmlnVmFyKTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnN0YXJ0UmVjb3JkaW5nID0gZnVuY3Rpb24gKHNob3VsZFN0b3BCYXRjaGVyKSB7XG4gICAgaWYgKHRoaXMuX3N0b3BSZWNvcmRpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbG9nZ2VyJDEubG9nKCdSZWNvcmRpbmcgYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJlY29yZE1heE1zID0gdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXhfbXMnKTtcbiAgICBpZiAodGhpcy5yZWNvcmRNYXhNcyA+IE1BWF9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRNYXhNcyA9IE1BWF9SRUNPUkRJTkdfTVM7XG4gICAgICAgIGxvZ2dlciQxLmNyaXRpY2FsKCdyZWNvcmRfbWF4X21zIGNhbm5vdCBiZSBncmVhdGVyIHRoYW4gJyArIE1BWF9SRUNPUkRJTkdfTVMgKyAnbXMuIENhcHBpbmcgdmFsdWUuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZWNvcmRNaW5NcyA9IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWluX21zJyk7XG4gICAgaWYgKHRoaXMucmVjb3JkTWluTXMgPiBNQVhfVkFMVUVfRk9SX01JTl9SRUNPUkRJTkdfTVMpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRNaW5NcyA9IE1BWF9WQUxVRV9GT1JfTUlOX1JFQ09SRElOR19NUztcbiAgICAgICAgbG9nZ2VyJDEuY3JpdGljYWwoJ3JlY29yZF9taW5fbXMgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiAnICsgTUFYX1ZBTFVFX0ZPUl9NSU5fUkVDT1JESU5HX01TICsgJ21zLiBDYXBwaW5nIHZhbHVlLicpO1xuICAgIH1cblxuICAgIHRoaXMucmVwbGF5U3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICB0aGlzLnJlcGxheVN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcblxuICAgIGlmIChzaG91bGRTdG9wQmF0Y2hlciB8fCB0aGlzLnJlY29yZE1pbk1zID4gMCkge1xuICAgICAgICAvLyB0aGUgcHJpbWFyeSBjYXNlIGZvciBzaG91bGRTdG9wQmF0Y2hlciBpcyB3aGVuIHdlJ3JlIHN0YXJ0aW5nIHJlY29yZGluZyBhZnRlciBhIHJlc2V0XG4gICAgICAgIC8vIGFuZCBkb24ndCB3YW50IHRvIHNlbmQgYW55dGhpbmcgb3ZlciB0aGUgbmV0d29yayB1bnRpbCB0aGVyZSdzXG4gICAgICAgIC8vIGFjdHVhbCB1c2VyIGFjdGl2aXR5XG4gICAgICAgIC8vIHRoaXMgYWxzbyBhcHBsaWVzIGlmIHRoZSBtaW5pbXVtIHJlY29yZGluZyBsZW5ndGggaGFzIG5vdCBiZWVuIGhpdCB5ZXRcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBzZW5kIGRhdGEgdW50aWwgd2Uga25vdyB0aGUgcmVjb3JkaW5nIHdpbGwgYmUgbG9uZyBlbm91Z2hcbiAgICAgICAgdGhpcy5iYXRjaGVyLnN0b3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhdGNoZXIuc3RhcnQoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzZXRJZGxlVGltZW91dCA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0SWQpO1xuICAgICAgICB0aGlzLmlkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX29uSWRsZVRpbWVvdXQsIHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfaWRsZV90aW1lb3V0X21zJykpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdmFyIGJsb2NrU2VsZWN0b3IgPSB0aGlzLmdldENvbmZpZygncmVjb3JkX2Jsb2NrX3NlbGVjdG9yJyk7XG4gICAgaWYgKGJsb2NrU2VsZWN0b3IgPT09ICcnIHx8IGJsb2NrU2VsZWN0b3IgPT09IG51bGwpIHtcbiAgICAgICAgYmxvY2tTZWxlY3RvciA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB0aGlzLl9zdG9wUmVjb3JkaW5nID0gdGhpcy5fcnJ3ZWJSZWNvcmQoe1xuICAgICAgICAnZW1pdCc6IF8uYmluZChmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hlci5lbnF1ZXVlKGV2KTtcbiAgICAgICAgICAgIGlmIChpc1VzZXJFdmVudChldikpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXRjaGVyLnN0b3BwZWQgJiYgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLnJlcGxheVN0YXJ0VGltZSA+PSB0aGlzLnJlY29yZE1pbk1zKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGZsdXNoaW5nIGFnYWluIGFmdGVyIHVzZXIgYWN0aXZpdHlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc2V0SWRsZVRpbWVvdXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICdibG9ja0NsYXNzJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9ibG9ja19jbGFzcycpLFxuICAgICAgICAnYmxvY2tTZWxlY3Rvcic6IGJsb2NrU2VsZWN0b3IsXG4gICAgICAgICdjb2xsZWN0Rm9udHMnOiB0aGlzLmdldENvbmZpZygncmVjb3JkX2NvbGxlY3RfZm9udHMnKSxcbiAgICAgICAgJ2RhdGFVUkxPcHRpb25zJzogeyAvLyBjYW52YXMgaW1hZ2Ugb3B0aW9ucyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxDYW52YXNFbGVtZW50L3RvRGF0YVVSTClcbiAgICAgICAgICAgICd0eXBlJzogJ2ltYWdlL3dlYnAnLFxuICAgICAgICAgICAgJ3F1YWxpdHknOiAwLjZcbiAgICAgICAgfSxcbiAgICAgICAgJ21hc2tBbGxJbnB1dHMnOiB0cnVlLFxuICAgICAgICAnbWFza1RleHRDbGFzcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfbWFza190ZXh0X2NsYXNzJyksXG4gICAgICAgICdtYXNrVGV4dFNlbGVjdG9yJzogdGhpcy5nZXRDb25maWcoJ3JlY29yZF9tYXNrX3RleHRfc2VsZWN0b3InKSxcbiAgICAgICAgJ3JlY29yZENhbnZhcyc6IHRoaXMuZ2V0Q29uZmlnKCdyZWNvcmRfY2FudmFzJyksXG4gICAgICAgICdzYW1wbGluZyc6IHtcbiAgICAgICAgICAgICdjYW52YXMnOiAxNVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMuX3N0b3BSZWNvcmRpbmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRFcnJvcigncnJ3ZWIgZmFpbGVkIHRvIHN0YXJ0LCBza2lwcGluZyB0aGlzIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpOyAvLyBzdG9wIGJhdGNoZXIgbG9vcGluZyBhbmQgYW55IHRpbWVvdXRzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNldElkbGVUaW1lb3V0KCk7XG5cbiAgICB0aGlzLm1heFRpbWVvdXRJZCA9IHNldFRpbWVvdXQoXy5iaW5kKHRoaXMuX29uTWF4TGVuZ3RoUmVhY2hlZCwgdGhpcyksIHRoaXMucmVjb3JkTWF4TXMpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuc3RvcFJlY29yZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZygpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ0Vycm9yIHdpdGggcnJ3ZWIgc3RvcFJlY29yZGluZycsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGluZyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYmF0Y2hlci5zdG9wcGVkKSB7XG4gICAgICAgIC8vIG5ldmVyIGdvdCB1c2VyIGFjdGl2aXR5IHRvIGZsdXNoIGFmdGVyIHJlc2V0LCBzbyBqdXN0IGNsZWFyIHRoZSBiYXRjaGVyXG4gICAgICAgIHRoaXMuYmF0Y2hlci5jbGVhcigpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGZsdXNoIGFueSByZW1haW5pbmcgZXZlbnRzIGZyb20gcnVubmluZyBiYXRjaGVyXG4gICAgICAgIHRoaXMuYmF0Y2hlci5mbHVzaCgpO1xuICAgICAgICB0aGlzLmJhdGNoZXIuc3RvcCgpO1xuICAgIH1cblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lb3V0SWQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLm1heFRpbWVvdXRJZCk7XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5pc1Jyd2ViU3RvcHBlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RvcFJlY29yZGluZyA9PT0gbnVsbDtcbn07XG5cbi8qKlxuICogRmx1c2hlcyB0aGUgY3VycmVudCBiYXRjaCBvZiBldmVudHMgdG8gdGhlIHNlcnZlciwgYnV0IHBhc3NlcyBhbiBvcHQtb3V0IGNhbGxiYWNrIHRvIG1ha2Ugc3VyZVxuICogd2Ugc3RvcCByZWNvcmRpbmcgYW5kIGR1bXAgYW55IHF1ZXVlZCBldmVudHMgaWYgdGhlIHVzZXIgaGFzIG9wdGVkIG91dC5cbiAqL1xuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuZmx1c2hFdmVudHNXaXRoT3B0T3V0ID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgdGhpcy5fZmx1c2hFdmVudHMoZGF0YSwgb3B0aW9ucywgY2IsIF8uYmluZCh0aGlzLl9vbk9wdE91dCwgdGhpcykpO1xufTtcblxuU2Vzc2lvblJlY29yZGluZy5wcm90b3R5cGUuX29uT3B0T3V0ID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAvLyBhZGRPcHRPdXRDaGVja01peHBhbmVsTGliIGludm9rZXMgdGhpcyBmdW5jdGlvbiB3aXRoIGNvZGU9MCB3aGVuIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXRcbiAgICBpZiAoY29kZSA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0b3BSZWNvcmRpbmcoKTtcbiAgICB9XG59O1xuXG5TZXNzaW9uUmVjb3JkaW5nLnByb3RvdHlwZS5fc2VuZFJlcXVlc3QgPSBmdW5jdGlvbihjdXJyZW50UmVwbGF5SWQsIHJlcVBhcmFtcywgcmVxQm9keSwgY2FsbGJhY2spIHtcbiAgICB2YXIgb25TdWNjZXNzID0gXy5iaW5kKGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VCb2R5KSB7XG4gICAgICAgIC8vIFVwZGF0ZSBiYXRjaCBzcGVjaWZpYyBwcm9wcyBvbmx5IGlmIHRoZSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsIHRvIGd1YXJhbnRlZSBvcmRlcmluZy5cbiAgICAgICAgLy8gUmVxdWVzdEJhdGNoZXIgd2lsbCBhbHdheXMgZmx1c2ggdGhlIG5leHQgYmF0Y2ggYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZSBzdWNjZWVkcy5cbiAgICAgICAgLy8gZXh0cmEgY2hlY2sgdG8gc2VlIGlmIHRoZSByZXBsYXkgSUQgaGFzIGNoYW5nZWQgc28gdGhhdCB3ZSBkb24ndCBpbmNyZW1lbnQgdGhlIHNlcU5vIG9uIHRoZSB3cm9uZyByZXBsYXlcbiAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwICYmIHRoaXMucmVwbGF5SWQgPT09IGN1cnJlbnRSZXBsYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5zZXFObysrO1xuICAgICAgICAgICAgdGhpcy5iYXRjaFN0YXJ0VXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayh7XG4gICAgICAgICAgICBzdGF0dXM6IDAsXG4gICAgICAgICAgICBodHRwU3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgcmVzcG9uc2VCb2R5OiByZXNwb25zZUJvZHksXG4gICAgICAgICAgICByZXRyeUFmdGVyOiByZXNwb25zZS5oZWFkZXJzLmdldCgnUmV0cnktQWZ0ZXInKVxuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHdpblsnZmV0Y2gnXSh0aGlzLmdldENvbmZpZygnYXBpX2hvc3QnKSArICcvJyArIHRoaXMuZ2V0Q29uZmlnKCdhcGlfcm91dGVzJylbJ3JlY29yZCddICsgJz8nICsgbmV3IFVSTFNlYXJjaFBhcmFtcyhyZXFQYXJhbXMpLCB7XG4gICAgICAgICdtZXRob2QnOiAnUE9TVCcsXG4gICAgICAgICdoZWFkZXJzJzoge1xuICAgICAgICAgICAgJ0F1dGhvcml6YXRpb24nOiAnQmFzaWMgJyArIGJ0b2EodGhpcy5nZXRDb25maWcoJ3Rva2VuJykgKyAnOicpLFxuICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nXG4gICAgICAgIH0sXG4gICAgICAgICdib2R5JzogcmVxQm9keSxcbiAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICByZXNwb25zZS5qc29uKCkudGhlbihmdW5jdGlvbiAocmVzcG9uc2VCb2R5KSB7XG4gICAgICAgICAgICBvblN1Y2Nlc3MocmVzcG9uc2UsIHJlc3BvbnNlQm9keSk7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvcn0pO1xuICAgICAgICB9KTtcbiAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgY2FsbGJhY2soe2Vycm9yOiBlcnJvciwgaHR0cFN0YXR1c0NvZGU6IDB9KTtcbiAgICB9KTtcbn07XG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLl9mbHVzaEV2ZW50cyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgbnVtRXZlbnRzID0gZGF0YS5sZW5ndGg7XG5cbiAgICBpZiAobnVtRXZlbnRzID4gMCkge1xuICAgICAgICB2YXIgcmVwbGF5SWQgPSB0aGlzLnJlcGxheUlkO1xuICAgICAgICAvLyBlYWNoIHJyd2ViIGV2ZW50IGhhcyBhIHRpbWVzdGFtcCAtIGxldmVyYWdlIHRob3NlIHRvIGdldCB0aW1lIHByb3BlcnRpZXNcbiAgICAgICAgdmFyIGJhdGNoU3RhcnRUaW1lID0gZGF0YVswXS50aW1lc3RhbXA7XG4gICAgICAgIGlmICh0aGlzLnNlcU5vID09PSAwIHx8ICF0aGlzLnJlcGxheVN0YXJ0VGltZSkge1xuICAgICAgICAgICAgLy8gZXh0cmEgc2FmZXR5IG5ldCBzbyB0aGF0IHdlIGRvbid0IHNlbmQgYSBudWxsIHJlcGxheSBzdGFydCB0aW1lXG4gICAgICAgICAgICBpZiAodGhpcy5zZXFObyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVwb3J0RXJyb3IoJ1JlcGxheSBzdGFydCB0aW1lIG5vdCBzZXQgYnV0IHNlcU5vIGlzIG5vdCAwLiBVc2luZyBjdXJyZW50IGJhdGNoIHN0YXJ0IHRpbWUgYXMgYSBmYWxsYmFjay4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXBsYXlTdGFydFRpbWUgPSBiYXRjaFN0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVwbGF5TGVuZ3RoTXMgPSBkYXRhW251bUV2ZW50cyAtIDFdLnRpbWVzdGFtcCAtIHRoaXMucmVwbGF5U3RhcnRUaW1lO1xuXG4gICAgICAgIHZhciByZXFQYXJhbXMgPSB7XG4gICAgICAgICAgICAnJGN1cnJlbnRfdXJsJzogdGhpcy5iYXRjaFN0YXJ0VXJsLFxuICAgICAgICAgICAgJyRsaWJfdmVyc2lvbic6IENvbmZpZy5MSUJfVkVSU0lPTixcbiAgICAgICAgICAgICdiYXRjaF9zdGFydF90aW1lJzogYmF0Y2hTdGFydFRpbWUgLyAxMDAwLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogU3RyaW5nKHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpKSxcbiAgICAgICAgICAgICdtcF9saWInOiAnd2ViJyxcbiAgICAgICAgICAgICdyZXBsYXlfaWQnOiByZXBsYXlJZCxcbiAgICAgICAgICAgICdyZXBsYXlfbGVuZ3RoX21zJzogcmVwbGF5TGVuZ3RoTXMsXG4gICAgICAgICAgICAncmVwbGF5X3N0YXJ0X3RpbWUnOiB0aGlzLnJlcGxheVN0YXJ0VGltZSAvIDEwMDAsXG4gICAgICAgICAgICAncmVwbGF5X3N0YXJ0X3VybCc6IHRoaXMucmVwbGF5U3RhcnRVcmwsXG4gICAgICAgICAgICAnc2VxJzogdGhpcy5zZXFOb1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZXZlbnRzSnNvbiA9IF8uSlNPTkVuY29kZShkYXRhKTtcblxuICAgICAgICAvLyBzZW5kIElEIG1hbmFnZW1lbnQgcHJvcHMgaWYgdGhleSBleGlzdFxuICAgICAgICB2YXIgZGV2aWNlSWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICAgICAgaWYgKGRldmljZUlkKSB7XG4gICAgICAgICAgICByZXFQYXJhbXNbJyRkZXZpY2VfaWQnXSA9IGRldmljZUlkO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1c2VySWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyR1c2VyX2lkJyk7XG4gICAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgICAgIHJlcVBhcmFtc1snJHVzZXJfaWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChDb21wcmVzc2lvblN0cmVhbSkge1xuICAgICAgICAgICAgdmFyIGpzb25TdHJlYW0gPSBuZXcgQmxvYihbZXZlbnRzSnNvbl0sIHt0eXBlOiAnYXBwbGljYXRpb24vanNvbid9KS5zdHJlYW0oKTtcbiAgICAgICAgICAgIHZhciBnemlwU3RyZWFtID0ganNvblN0cmVhbS5waXBlVGhyb3VnaChuZXcgQ29tcHJlc3Npb25TdHJlYW0oJ2d6aXAnKSk7XG4gICAgICAgICAgICBuZXcgUmVzcG9uc2UoZ3ppcFN0cmVhbSlcbiAgICAgICAgICAgICAgICAuYmxvYigpXG4gICAgICAgICAgICAgICAgLnRoZW4oXy5iaW5kKGZ1bmN0aW9uKGNvbXByZXNzZWRCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcVBhcmFtc1snZm9ybWF0J10gPSAnZ3ppcCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcGxheUlkLCByZXFQYXJhbXMsIGNvbXByZXNzZWRCbG9iLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxUGFyYW1zWydmb3JtYXQnXSA9ICdib2R5JztcbiAgICAgICAgICAgIHRoaXMuX3NlbmRSZXF1ZXN0KHJlcGxheUlkLCByZXFQYXJhbXMsIGV2ZW50c0pzb24sIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblNlc3Npb25SZWNvcmRpbmcucHJvdG90eXBlLnJlcG9ydEVycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBsb2dnZXIkMS5lcnJvci5hcHBseShsb2dnZXIkMS5lcnJvciwgYXJndW1lbnRzKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWVyciAmJiAhKG1zZyBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgbXNnID0gbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRDb25maWcoJ2Vycm9yX3JlcG9ydGVyJykobXNnLCBlcnIpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGxvZ2dlciQxLmVycm9yKGVycik7XG4gICAgfVxufTtcblxudmFyIGxvZ2dlciA9IGNvbnNvbGVfd2l0aF9wcmVmaXgoJ3JlY29yZGVyJyk7XG5cbi8qKlxuICogUmVjb3JkZXIgQVBJOiBtYW5hZ2VzIHJlY29yZGluZ3MgYW5kIGV4cG9zZXMgbWV0aG9kcyBwdWJsaWMgdG8gdGhlIGNvcmUgTWl4cGFuZWwgbGlicmFyeS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5taXhwYW5lbEluc3RhbmNlXSAtIHJlZmVyZW5jZSB0byB0aGUgY29yZSBNaXhwYW5lbExpYlxuICovXG52YXIgTWl4cGFuZWxSZWNvcmRlciA9IGZ1bmN0aW9uKG1peHBhbmVsSW5zdGFuY2UpIHtcbiAgICB0aGlzLl9taXhwYW5lbCA9IG1peHBhbmVsSW5zdGFuY2U7XG4gICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBudWxsO1xufTtcblxuTWl4cGFuZWxSZWNvcmRlci5wcm90b3R5cGUuc3RhcnRSZWNvcmRpbmcgPSBmdW5jdGlvbihzaG91bGRTdG9wQmF0Y2hlcikge1xuICAgIGlmICh0aGlzLmFjdGl2ZVJlY29yZGluZyAmJiAhdGhpcy5hY3RpdmVSZWNvcmRpbmcuaXNScndlYlN0b3BwZWQoKSkge1xuICAgICAgICBsb2dnZXIubG9nKCdSZWNvcmRpbmcgYWxyZWFkeSBpbiBwcm9ncmVzcywgc2tpcHBpbmcgc3RhcnRSZWNvcmRpbmcuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb25JZGxlVGltZW91dCA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ0lkbGUgdGltZW91dCByZWFjaGVkLCByZXN0YXJ0aW5nIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5yZXNldFJlY29yZGluZygpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdmFyIG9uTWF4TGVuZ3RoUmVhY2hlZCA9IF8uYmluZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlci5sb2coJ01heCByZWNvcmRpbmcgbGVuZ3RoIHJlYWNoZWQsIHN0b3BwaW5nIHJlY29yZGluZy4nKTtcbiAgICAgICAgdGhpcy5yZXNldFJlY29yZGluZygpO1xuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBuZXcgU2Vzc2lvblJlY29yZGluZyh7XG4gICAgICAgIG1peHBhbmVsSW5zdGFuY2U6IHRoaXMuX21peHBhbmVsLFxuICAgICAgICBvbklkbGVUaW1lb3V0OiBvbklkbGVUaW1lb3V0LFxuICAgICAgICBvbk1heExlbmd0aFJlYWNoZWQ6IG9uTWF4TGVuZ3RoUmVhY2hlZCxcbiAgICAgICAgcmVwbGF5SWQ6IF8uVVVJRCgpLFxuICAgICAgICBycndlYlJlY29yZDogcmVjb3JkXG4gICAgfSk7XG5cbiAgICB0aGlzLmFjdGl2ZVJlY29yZGluZy5zdGFydFJlY29yZGluZyhzaG91bGRTdG9wQmF0Y2hlcik7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5zdG9wUmVjb3JkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYWN0aXZlUmVjb3JkaW5nKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnN0b3BSZWNvcmRpbmcoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVSZWNvcmRpbmcgPSBudWxsO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUmVjb3JkZXIucHJvdG90eXBlLnJlc2V0UmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgIHRoaXMuc3RhcnRSZWNvcmRpbmcodHJ1ZSk7XG59O1xuXG5NaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZS5nZXRBY3RpdmVSZXBsYXlJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5hY3RpdmVSZWNvcmRpbmcgJiYgIXRoaXMuYWN0aXZlUmVjb3JkaW5nLmlzUnJ3ZWJTdG9wcGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlUmVjb3JkaW5nLnJlcGxheUlkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8vIGdldHRlciBzbyB0aGF0IG9sZGVyIG1peHBhbmVsLWNvcmUgdmVyc2lvbnMgY2FuIHN0aWxsIHJldHJpZXZlIHRoZSByZXBsYXkgSURcbi8vIHdoZW4gcHVsbGluZyB0aGUgbGF0ZXN0IHJlY29yZGVyIGJ1bmRsZSBmcm9tIHRoZSBDRE5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNaXhwYW5lbFJlY29yZGVyLnByb3RvdHlwZSwgJ3JlcGxheUlkJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBY3RpdmVSZXBsYXlJZCgpO1xuICAgIH1cbn0pO1xuXG53aW5bJ19fbXBfcmVjb3JkZXInXSA9IE1peHBhbmVsUmVjb3JkZXI7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBEb21UcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEb21UcmFja2VyID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vLyBpbnRlcmZhY2VcbkRvbVRyYWNrZXIucHJvdG90eXBlLmNyZWF0ZV9wcm9wZXJ0aWVzID0gZnVuY3Rpb24oKSB7fTtcbkRvbVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbigpIHt9O1xuRG9tVHJhY2tlci5wcm90b3R5cGUuYWZ0ZXJfdHJhY2tfaGFuZGxlciA9IGZ1bmN0aW9uKCkge307XG5cbkRvbVRyYWNrZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSkge1xuICAgIHRoaXMubXAgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBxdWVyeVxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50X25hbWVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICogQHBhcmFtIHtmdW5jdGlvbj19IHVzZXJfY2FsbGJhY2tcbiAqL1xuRG9tVHJhY2tlci5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbihxdWVyeSwgZXZlbnRfbmFtZSwgcHJvcGVydGllcywgdXNlcl9jYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgZWxlbWVudHMgPSBfLmRvbV9xdWVyeShxdWVyeSk7XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignVGhlIERPTSBxdWVyeSAoJyArIHF1ZXJ5ICsgJykgcmV0dXJuZWQgMCBlbGVtZW50cycpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgXy5lYWNoKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIF8ucmVnaXN0ZXJfZXZlbnQoZWxlbWVudCwgdGhpcy5vdmVycmlkZV9ldmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHRoYXQuY3JlYXRlX3Byb3BlcnRpZXMocHJvcGVydGllcywgdGhpcyk7XG4gICAgICAgICAgICB2YXIgdGltZW91dCA9IHRoYXQubXAuZ2V0X2NvbmZpZygndHJhY2tfbGlua3NfdGltZW91dCcpO1xuXG4gICAgICAgICAgICB0aGF0LmV2ZW50X2hhbmRsZXIoZSwgdGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIG1peHBhbmVsIHNlcnZlcnMgZG9uJ3QgZ2V0IGJhY2sgdG8gdXMgaW4gdGltZVxuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGhhdC50cmFja19jYWxsYmFjayh1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucywgdHJ1ZSksIHRpbWVvdXQpO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHRoZSB0cmFja2luZyBldmVudFxuICAgICAgICAgICAgdGhhdC5tcC50cmFjayhldmVudF9uYW1lLCBwcm9wcywgdGhhdC50cmFja19jYWxsYmFjayh1c2VyX2NhbGxiYWNrLCBwcm9wcywgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9LCB0aGlzKTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB1c2VyX2NhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHRpbWVvdXRfb2NjdXJlZFxuICovXG5Eb21UcmFja2VyLnByb3RvdHlwZS50cmFja19jYWxsYmFjayA9IGZ1bmN0aW9uKHVzZXJfY2FsbGJhY2ssIHByb3BzLCBvcHRpb25zLCB0aW1lb3V0X29jY3VyZWQpIHtcbiAgICB0aW1lb3V0X29jY3VyZWQgPSB0aW1lb3V0X29jY3VyZWQgfHwgZmFsc2U7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBvcHRpb25zIGlzIHJlZmVyZW5jZWQgZnJvbSBib3RoIGNhbGxiYWNrcywgc28gd2UgY2FuIGhhdmVcbiAgICAgICAgLy8gYSAnbG9jaycgb2Ygc29ydHMgdG8gZW5zdXJlIG9ubHkgb25lIGZpcmVzXG4gICAgICAgIGlmIChvcHRpb25zLmNhbGxiYWNrX2ZpcmVkKSB7IHJldHVybjsgfVxuICAgICAgICBvcHRpb25zLmNhbGxiYWNrX2ZpcmVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAodXNlcl9jYWxsYmFjayAmJiB1c2VyX2NhbGxiYWNrKHRpbWVvdXRfb2NjdXJlZCwgcHJvcHMpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gdXNlciBjYW4gcHJldmVudCB0aGUgZGVmYXVsdCBmdW5jdGlvbmFsaXR5IGJ5XG4gICAgICAgICAgICAvLyByZXR1cm5pbmcgZmFsc2UgZnJvbSB0aGVpciBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhhdC5hZnRlcl90cmFja19oYW5kbGVyKHByb3BzLCBvcHRpb25zLCB0aW1lb3V0X29jY3VyZWQpO1xuICAgIH07XG59O1xuXG5Eb21UcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcHM7XG5cbiAgICBpZiAodHlwZW9mKHByb3BlcnRpZXMpID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb3BzID0gcHJvcGVydGllcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wcyA9IF8uZXh0ZW5kKHt9LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvcHM7XG59O1xuXG4vKipcbiAqIExpbmtUcmFja2VyIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBEb21UcmFja2VyXG4gKi9cbnZhciBMaW5rVHJhY2tlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3ZlcnJpZGVfZXZlbnQgPSAnY2xpY2snO1xufTtcbl8uaW5oZXJpdChMaW5rVHJhY2tlciwgRG9tVHJhY2tlcik7XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5jcmVhdGVfcHJvcGVydGllcyA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGVsZW1lbnQpIHtcbiAgICB2YXIgcHJvcHMgPSBMaW5rVHJhY2tlci5zdXBlcmNsYXNzLmNyZWF0ZV9wcm9wZXJ0aWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoZWxlbWVudC5ocmVmKSB7IHByb3BzWyd1cmwnXSA9IGVsZW1lbnQuaHJlZjsgfVxuXG4gICAgcmV0dXJuIHByb3BzO1xufTtcblxuTGlua1RyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLm5ld190YWIgPSAoXG4gICAgICAgIGV2dC53aGljaCA9PT0gMiB8fFxuICAgICAgICBldnQubWV0YUtleSB8fFxuICAgICAgICBldnQuY3RybEtleSB8fFxuICAgICAgICBlbGVtZW50LnRhcmdldCA9PT0gJ19ibGFuaydcbiAgICApO1xuICAgIG9wdGlvbnMuaHJlZiA9IGVsZW1lbnQuaHJlZjtcblxuICAgIGlmICghb3B0aW9ucy5uZXdfdGFiKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbkxpbmtUcmFja2VyLnByb3RvdHlwZS5hZnRlcl90cmFja19oYW5kbGVyID0gZnVuY3Rpb24ocHJvcHMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5uZXdfdGFiKSB7IHJldHVybjsgfVxuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uID0gb3B0aW9ucy5ocmVmO1xuICAgIH0sIDApO1xufTtcblxuLyoqXG4gKiBGb3JtVHJhY2tlciBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgRG9tVHJhY2tlclxuICovXG52YXIgRm9ybVRyYWNrZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm92ZXJyaWRlX2V2ZW50ID0gJ3N1Ym1pdCc7XG59O1xuXy5pbmhlcml0KEZvcm1UcmFja2VyLCBEb21UcmFja2VyKTtcblxuRm9ybVRyYWNrZXIucHJvdG90eXBlLmV2ZW50X2hhbmRsZXIgPSBmdW5jdGlvbihldnQsIGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufTtcblxuRm9ybVRyYWNrZXIucHJvdG90eXBlLmFmdGVyX3RyYWNrX2hhbmRsZXIgPSBmdW5jdGlvbihwcm9wcywgb3B0aW9ucykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9wdGlvbnMuZWxlbWVudC5zdWJtaXQoKTtcbiAgICB9LCAwKTtcbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqIEBjb25zdCAqLyB2YXIgU0VUX0FDVElPTiAgICAgID0gJyRzZXQnO1xuLyoqIEBjb25zdCAqLyB2YXIgU0VUX09OQ0VfQUNUSU9OID0gJyRzZXRfb25jZSc7XG4vKiogQGNvbnN0ICovIHZhciBVTlNFVF9BQ1RJT04gICAgPSAnJHVuc2V0Jztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9BQ1RJT04gICAgICA9ICckYWRkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFQUEVORF9BQ1RJT04gICA9ICckYXBwZW5kJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOSU9OX0FDVElPTiAgICA9ICckdW5pb24nO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX0FDVElPTiAgID0gJyRyZW1vdmUnO1xuLyoqIEBjb25zdCAqLyB2YXIgREVMRVRFX0FDVElPTiAgID0gJyRkZWxldGUnO1xuXG4vLyBDb21tb24gaW50ZXJuYWwgbWV0aG9kcyBmb3IgbWl4cGFuZWwucGVvcGxlIGFuZCBtaXhwYW5lbC5ncm91cCBBUElzLlxuLy8gVGhlc2UgbWV0aG9kcyBzaG91bGRuJ3QgaW52b2x2ZSBuZXR3b3JrIEkvTy5cbnZhciBhcGlBY3Rpb25zID0ge1xuICAgIHNldF9hY3Rpb246IGZ1bmN0aW9uKHByb3AsIHRvKSB7XG4gICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgIHZhciAkc2V0ID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkc2V0W3Byb3BdID0gdG87XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW1NFVF9BQ1RJT05dID0gJHNldDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHVuc2V0X2FjdGlvbjogZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHVuc2V0ID0gW107XG4gICAgICAgIGlmICghXy5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICBwcm9wID0gW3Byb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKGspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAkdW5zZXQucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZGF0YVtVTlNFVF9BQ1RJT05dID0gJHVuc2V0O1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9LFxuXG4gICAgc2V0X29uY2VfYWN0aW9uOiBmdW5jdGlvbihwcm9wLCB0bykge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICB2YXIgJHNldF9vbmNlID0ge307XG4gICAgICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgICAgICBfLmVhY2gocHJvcCwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHNldF9vbmNlW2tdID0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICRzZXRfb25jZVtwcm9wXSA9IHRvO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbU0VUX09OQ0VfQUNUSU9OXSA9ICRzZXRfb25jZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHVuaW9uX2FjdGlvbjogZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICR1bmlvbiA9IHt9O1xuICAgICAgICBpZiAoXy5pc09iamVjdChsaXN0X25hbWUpKSB7XG4gICAgICAgICAgICBfLmVhY2gobGlzdF9uYW1lLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9pc19yZXNlcnZlZF9wcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAkdW5pb25ba10gPSBfLmlzQXJyYXkodikgPyB2IDogW3ZdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJHVuaW9uW2xpc3RfbmFtZV0gPSBfLmlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcyA6IFt2YWx1ZXNdO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbVU5JT05fQUNUSU9OXSA9ICR1bmlvbjtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGFwcGVuZF9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRhcHBlbmQgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJGFwcGVuZFtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkYXBwZW5kW2xpc3RfbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW0FQUEVORF9BQ1RJT05dID0gJGFwcGVuZDtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIHJlbW92ZV9hY3Rpb246IGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyICRyZW1vdmUgPSB7fTtcbiAgICAgICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICAgICAgXy5lYWNoKGxpc3RfbmFtZSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgJHJlbW92ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAkcmVtb3ZlW2xpc3RfbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW1JFTU9WRV9BQ1RJT05dID0gJHJlbW92ZTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSxcblxuICAgIGRlbGV0ZV9hY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICBkYXRhW0RFTEVURV9BQ1RJT05dID0gJyc7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn07XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLyoqXG4gKiBNaXhwYW5lbCBHcm91cCBPYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWl4cGFuZWxHcm91cCA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsR3JvdXAucHJvdG90eXBlLCBhcGlBY3Rpb25zKTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbihtaXhwYW5lbF9pbnN0YW5jZSwgZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHRoaXMuX21peHBhbmVsID0gbWl4cGFuZWxfaW5zdGFuY2U7XG4gICAgdGhpcy5fZ3JvdXBfa2V5ID0gZ3JvdXBfa2V5O1xuICAgIHRoaXMuX2dyb3VwX2lkID0gZ3JvdXBfaWQ7XG59O1xuXG4vKipcbiAqIFNldCBwcm9wZXJ0aWVzIG9uIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXQoJ0xvY2F0aW9uJywgJzQwNSBIb3dhcmQnKTtcbiAqXG4gKiAgICAgLy8gb3Igc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnNldCh7XG4gKiAgICAgICAgICAnTG9jYXRpb24nOiAnNDA1IEhvd2FyZCcsXG4gKiAgICAgICAgICAnRm91bmRlZCcgOiAyMDA5LFxuICogICAgIH0pO1xuICogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzLCBkYXRlcywgb3IgbGlzdHNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsR3JvdXAoZnVuY3Rpb24ocHJvcCwgdG8sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnNldF9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogU2V0IHByb3BlcnRpZXMgb24gYSBncm91cCwgb25seSBpZiB0aGV5IGRvIG5vdCB5ZXQgZXhpc3QuXG4gKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBncm91cCBwcm9wZXJ0eSB2YWx1ZXMsIHVubGlrZVxuICogZ3JvdXAuc2V0KCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5zZXRfb25jZSgnTG9jYXRpb24nLCAnNDA1IEhvd2FyZCcpO1xuICpcbiAqICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4gKiAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKCdjb21wYW55JywgJ21peHBhbmVsJykuc2V0X29uY2Uoe1xuICogICAgICAgICAgJ0xvY2F0aW9uJzogJzQwNSBIb3dhcmQnLFxuICogICAgICAgICAgJ0ZvdW5kZWQnIDogMjAwOSxcbiAqICAgICB9KTtcbiAqICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgbGlzdHMgb3IgZGF0ZXNcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHByb3AgSWYgYSBzdHJpbmcsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LiBJZiBhbiBvYmplY3QsIHRoaXMgaXMgYW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgbmFtZXMgYW5kIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gW3RvXSBBIHZhbHVlIHRvIHNldCBvbiB0aGUgZ2l2ZW4gcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXRfb25jZSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X29uY2VfYWN0aW9uKHByb3AsIHRvKTtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wKSkge1xuICAgICAgICBjYWxsYmFjayA9IHRvO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFVuc2V0IHByb3BlcnRpZXMgb24gYSBncm91cCBwZXJtYW5lbnRseS5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnVuc2V0KCdGb3VuZGVkJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3AgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRoZSB0cmFja2luZyBldmVudFxuICovXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihwcm9wLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy51bnNldF9hY3Rpb24ocHJvcCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIGdyb3VwIHByb3BlcnR5LCBleGNsdWRpbmcgZHVwbGljYXRlIHZhbHVlcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIG1lcmdlIGEgdmFsdWUgdG8gYSBsaXN0LCBjcmVhdGluZyBpdCBpZiBuZWVkZWRcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS51bmlvbignTG9jYXRpb24nLCBbJ1NhbiBGcmFuY2lzY28nLCAnTG9uZG9uJ10pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaXN0X25hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVmFsdWVzIHRvIG1lcmdlIHdpdGggdGhlIGdpdmVuIHByb3BlcnR5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLnVuaW9uID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWVzLCBjYWxsYmFjaykge1xuICAgIGlmIChfLmlzT2JqZWN0KGxpc3RfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHZhciBkYXRhID0gdGhpcy51bmlvbl9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMpO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qKlxuICogUGVybWFuZW50bHkgZGVsZXRlIGEgZ3JvdXAuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICBtaXhwYW5lbC5nZXRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKS5kZWxldGUoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdGhlIHRyYWNraW5nIGV2ZW50XG4gKi9cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydkZWxldGUnXSA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxHcm91cChmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIC8vIGJyYWNrZXQgbm90YXRpb24gYWJvdmUgcHJldmVudHMgYSBtaW5pZmljYXRpb24gZXJyb3IgcmVsYXRlZCB0byByZXNlcnZlZCB3b3Jkc1xuICAgIHZhciBkYXRhID0gdGhpcy5kZWxldGVfYWN0aW9uKCk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBSZW1vdmUgYSBwcm9wZXJ0eSBmcm9tIGEgZ3JvdXAuIFRoZSB2YWx1ZSB3aWxsIGJlIGlnbm9yZWQgaWYgZG9lc24ndCBleGlzdC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIG1peHBhbmVsLmdldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpLnJlbW92ZSgnTG9jYXRpb24nLCAnTG9uZG9uJyk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxpc3RfbmFtZSBOYW1lIG9mIHRoZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBWYWx1ZSB0byByZW1vdmUgZnJvbSB0aGUgZ2l2ZW4gZ3JvdXAgcHJvcGVydHlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBhZnRlciB0aGUgdHJhY2tpbmcgZXZlbnRcbiAqL1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbEdyb3VwKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSB0aGlzLnJlbW92ZV9hY3Rpb24obGlzdF9uYW1lLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgZGF0YVsnJGdyb3VwX2tleSddID0gdGhpcy5fZ3JvdXBfa2V5O1xuICAgIGRhdGFbJyRncm91cF9pZCddID0gdGhpcy5fZ3JvdXBfaWQ7XG4gICAgZGF0YVsnJHRva2VuJ10gPSB0aGlzLl9nZXRfY29uZmlnKCd0b2tlbicpO1xuXG4gICAgdmFyIGRhdGVfZW5jb2RlZF9kYXRhID0gXy5lbmNvZGVEYXRlcyhkYXRhKTtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuX3RyYWNrX29yX2JhdGNoKHtcbiAgICAgICAgdHlwZTogJ2dyb3VwcycsXG4gICAgICAgIGRhdGE6IGRhdGVfZW5jb2RlZF9kYXRhLFxuICAgICAgICBlbmRwb2ludDogdGhpcy5fZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArICcvJyArICB0aGlzLl9nZXRfY29uZmlnKCdhcGlfcm91dGVzJylbJ2dyb3VwcyddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLl9taXhwYW5lbC5yZXF1ZXN0X2JhdGNoZXJzLmdyb3Vwc1xuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbk1peHBhbmVsR3JvdXAucHJvdG90eXBlLl9pc19yZXNlcnZlZF9wcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICByZXR1cm4gcHJvcCA9PT0gJyRncm91cF9rZXknIHx8IHByb3AgPT09ICckZ3JvdXBfaWQnO1xufTtcblxuTWl4cGFuZWxHcm91cC5wcm90b3R5cGUuX2dldF9jb25maWcgPSBmdW5jdGlvbihjb25mKSB7XG4gICAgcmV0dXJuIHRoaXMuX21peHBhbmVsLmdldF9jb25maWcoY29uZik7XG59O1xuXG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5ncm91cC4nICsgdGhpcy5fZ3JvdXBfa2V5ICsgJy4nICsgdGhpcy5fZ3JvdXBfaWQ7XG59O1xuXG4vLyBNaXhwYW5lbEdyb3VwIEV4cG9ydHNcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWydyZW1vdmUnXSAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUucmVtb3ZlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3NldCddICAgICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsnc2V0X29uY2UnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnNldF9vbmNlO1xuTWl4cGFuZWxHcm91cC5wcm90b3R5cGVbJ3VuaW9uJ10gICAgPSBNaXhwYW5lbEdyb3VwLnByb3RvdHlwZS51bmlvbjtcbk1peHBhbmVsR3JvdXAucHJvdG90eXBlWyd1bnNldCddICAgID0gTWl4cGFuZWxHcm91cC5wcm90b3R5cGUudW5zZXQ7XG5NaXhwYW5lbEdyb3VwLnByb3RvdHlwZVsndG9TdHJpbmcnXSA9IE1peHBhbmVsR3JvdXAucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiBlc2xpbnQgY2FtZWxjYXNlOiBcIm9mZlwiICovXG5cbi8qKlxuICogTWl4cGFuZWwgUGVvcGxlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlb3BsZSA9IGZ1bmN0aW9uKCkge307XG5cbl8uZXh0ZW5kKE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZSwgYXBpQWN0aW9ucyk7XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKG1peHBhbmVsX2luc3RhbmNlKSB7XG4gICAgdGhpcy5fbWl4cGFuZWwgPSBtaXhwYW5lbF9pbnN0YW5jZTtcbn07XG5cbi8qXG4qIFNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXQoJ2dlbmRlcicsICdtJyk7XG4qXG4qICAgICAvLyBvciBzZXQgbXVsdGlwbGUgcHJvcGVydGllcyBhdCBvbmNlXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0KHtcbiogICAgICAgICAnQ29tcGFueSc6ICdBY21lJyxcbiogICAgICAgICAnUGxhbic6ICdQcmVtaXVtJyxcbiogICAgICAgICAnVXBncmFkZSBkYXRlJzogbmV3IERhdGUoKVxuKiAgICAgfSk7XG4qICAgICAvLyBwcm9wZXJ0aWVzIGNhbiBiZSBzdHJpbmdzLCBpbnRlZ2VycywgZGF0ZXMsIG9yIGxpc3RzXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCB0bywgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuc2V0X2FjdGlvbihwcm9wLCB0byk7XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSB0bztcbiAgICB9XG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIHJlZmVycmVyIGluZm8gaGFzIGJlZW4gdXBkYXRlZCBhbmQgc2F2ZWRcbiAgICBpZiAodGhpcy5fZ2V0X2NvbmZpZygnc2F2ZV9yZWZlcnJlcicpKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLnVwZGF0ZV9yZWZlcnJlcl9pbmZvKGRvY3VtZW50LnJlZmVycmVyKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgJHNldCBvYmplY3Qgd2l0aCBkZWZhdWx0IHBlb3BsZSBwcm9wZXJ0aWVzXG4gICAgZGF0YVtTRVRfQUNUSU9OXSA9IF8uZXh0ZW5kKFxuICAgICAgICB7fSxcbiAgICAgICAgXy5pbmZvLnBlb3BsZV9wcm9wZXJ0aWVzKCksXG4gICAgICAgIGRhdGFbU0VUX0FDVElPTl1cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFNldCBwcm9wZXJ0aWVzIG9uIGEgdXNlciByZWNvcmQsIG9ubHkgaWYgdGhleSBkbyBub3QgeWV0IGV4aXN0LlxuKiBUaGlzIHdpbGwgbm90IG92ZXJ3cml0ZSBwcmV2aW91cyBwZW9wbGUgcHJvcGVydHkgdmFsdWVzLCB1bmxpa2VcbiogcGVvcGxlLnNldCgpLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuc2V0X29uY2UoJ0ZpcnN0IExvZ2luIERhdGUnLCBuZXcgRGF0ZSgpKTtcbipcbiogICAgIC8vIG9yIHNldCBtdWx0aXBsZSBwcm9wZXJ0aWVzIGF0IG9uY2VcbiogICAgIG1peHBhbmVsLnBlb3BsZS5zZXRfb25jZSh7XG4qICAgICAgICAgJ0ZpcnN0IExvZ2luIERhdGUnOiBuZXcgRGF0ZSgpLFxuKiAgICAgICAgICdTdGFydGluZyBQbGFuJzogJ1ByZW1pdW0nXG4qICAgICB9KTtcbipcbiogICAgIC8vIHByb3BlcnRpZXMgY2FuIGJlIHN0cmluZ3MsIGludGVnZXJzIG9yIGRhdGVzXG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcHJvcCBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt0b10gQSB2YWx1ZSB0byBzZXQgb24gdGhlIGdpdmVuIHByb3BlcnR5IG5hbWVcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0X29uY2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKHByb3AsIHRvLCBjYWxsYmFjaykge1xuICAgIHZhciBkYXRhID0gdGhpcy5zZXRfb25jZV9hY3Rpb24ocHJvcCwgdG8pO1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3ApKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdG87XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIFVuc2V0IHByb3BlcnRpZXMgb24gYSB1c2VyIHJlY29yZCAocGVybWFuZW50bHkgcmVtb3ZlcyB0aGUgcHJvcGVydGllcyBhbmQgdGhlaXIgdmFsdWVzIGZyb20gYSBwcm9maWxlKS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KCdnZW5kZXInKTtcbipcbiogICAgIC8vIG9yIHVuc2V0IG11bHRpcGxlIHByb3BlcnRpZXMgYXQgb25jZVxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuc2V0KFsnZ2VuZGVyJywgJ0NvbXBhbnknXSk7XG4qXG4qIEBwYXJhbSB7QXJyYXl8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gYXJyYXksIHRoaXMgaXMgYSBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLlxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bnNldCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24ocHJvcCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMudW5zZXRfYWN0aW9uKHByb3ApO1xuICAgIHJldHVybiB0aGlzLl9zZW5kX3JlcXVlc3QoZGF0YSwgY2FsbGJhY2spO1xufSk7XG5cbi8qXG4qIEluY3JlbWVudC9kZWNyZW1lbnQgbnVtZXJpYyBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnRpZXMuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3BhZ2Vfdmlld3MnLCAxKTtcbipcbiogICAgIC8vIG9yLCBmb3IgY29udmVuaWVuY2UsIGlmIHlvdSdyZSBqdXN0IGluY3JlbWVudGluZyBhIGNvdW50ZXIgYnlcbiogICAgIC8vIDEsIHlvdSBjYW4gc2ltcGx5IGRvXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdwYWdlX3ZpZXdzJyk7XG4qXG4qICAgICAvLyB0byBkZWNyZW1lbnQgYSBjb3VudGVyLCBwYXNzIGEgbmVnYXRpdmUgbnVtYmVyXG4qICAgICBtaXhwYW5lbC5wZW9wbGUuaW5jcmVtZW50KCdjcmVkaXRzX2xlZnQnLCAtMSk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5zZXQoKSwgeW91IGNhbiBpbmNyZW1lbnQgbXVsdGlwbGVcbiogICAgIC8vIHByb3BlcnRpZXMgYXQgb25jZTpcbiogICAgIG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoe1xuKiAgICAgICAgIGNvdW50ZXIxOiAxLFxuKiAgICAgICAgIGNvdW50ZXIyOiA2XG4qICAgICB9KTtcbipcbiogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBwcm9wIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCBudW1lcmljIHZhbHVlcy5cbiogQHBhcmFtIHtOdW1iZXJ9IFtieV0gQW4gYW1vdW50IHRvIGluY3JlbWVudCB0aGUgZ2l2ZW4gcHJvcGVydHlcbiogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiovXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuaW5jcmVtZW50ID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbFBlb3BsZShmdW5jdGlvbihwcm9wLCBieSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIHZhciAkYWRkID0ge307XG4gICAgaWYgKF8uaXNPYmplY3QocHJvcCkpIHtcbiAgICAgICAgXy5lYWNoKHByb3AsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faXNfcmVzZXJ2ZWRfcHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGFyc2VGbG9hdCh2KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIGluY3JlbWVudCB2YWx1ZSBwYXNzZWQgdG8gbWl4cGFuZWwucGVvcGxlLmluY3JlbWVudCAtIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICRhZGRba10gPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGNhbGxiYWNrID0gYnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29udmVuaWVuY2U6IG1peHBhbmVsLnBlb3BsZS5pbmNyZW1lbnQoJ3Byb3BlcnR5Jyk7IHdpbGxcbiAgICAgICAgLy8gaW5jcmVtZW50ICdwcm9wZXJ0eScgYnkgMVxuICAgICAgICBpZiAoXy5pc1VuZGVmaW5lZChieSkpIHtcbiAgICAgICAgICAgIGJ5ID0gMTtcbiAgICAgICAgfVxuICAgICAgICAkYWRkW3Byb3BdID0gYnk7XG4gICAgfVxuICAgIGRhdGFbQUREX0FDVElPTl0gPSAkYWRkO1xuXG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiogQXBwZW5kIGEgdmFsdWUgdG8gYSBsaXN0LXZhbHVlZCBwZW9wbGUgYW5hbHl0aWNzIHByb3BlcnR5LlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyBhcHBlbmQgYSB2YWx1ZSB0byBhIGxpc3QsIGNyZWF0aW5nIGl0IGlmIG5lZWRlZFxuKiAgICAgbWl4cGFuZWwucGVvcGxlLmFwcGVuZCgncGFnZXNfdmlzaXRlZCcsICdob21lcGFnZScpO1xuKlxuKiAgICAgLy8gbGlrZSBtaXhwYW5lbC5wZW9wbGUuc2V0KCksIHlvdSBjYW4gYXBwZW5kIG11bHRpcGxlXG4qICAgICAvLyBwcm9wZXJ0aWVzIGF0IG9uY2U6XG4qICAgICBtaXhwYW5lbC5wZW9wbGUuYXBwZW5kKHtcbiogICAgICAgICBsaXN0MTogJ2JvYicsXG4qICAgICAgICAgbGlzdDI6IDEyM1xuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSB2YWx1ZSBBbiBpdGVtIHRvIGFwcGVuZCB0byB0aGUgbGlzdFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5hcHBlbmQgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMuYXBwZW5kX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBSZW1vdmUgYSB2YWx1ZSBmcm9tIGEgbGlzdC12YWx1ZWQgcGVvcGxlIGFuYWx5dGljcyBwcm9wZXJ0eS5cbipcbiogIyMjIFVzYWdlOlxuKlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnJlbW92ZSgnU2Nob29sJywgJ1VDQicpO1xuKlxuKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxpc3RfbmFtZSBJZiBhIHN0cmluZywgdGhpcyBpcyB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHkuIElmIGFuIG9iamVjdCwgdGhpcyBpcyBhbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBuYW1lcyBhbmQgdmFsdWVzLlxuKiBAcGFyYW0geyp9IFt2YWx1ZV0gdmFsdWUgSXRlbSB0byByZW1vdmUgZnJvbSB0aGUgbGlzdFxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5yZW1vdmUgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGxpc3RfbmFtZSwgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHRoaXMucmVtb3ZlX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5fc2VuZF9yZXF1ZXN0KGRhdGEsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuKiBNZXJnZSBhIGdpdmVuIGxpc3Qgd2l0aCBhIGxpc3QtdmFsdWVkIHBlb3BsZSBhbmFseXRpY3MgcHJvcGVydHksXG4qIGV4Y2x1ZGluZyBkdXBsaWNhdGUgdmFsdWVzLlxuKlxuKiAjIyMgVXNhZ2U6XG4qXG4qICAgICAvLyBtZXJnZSBhIHZhbHVlIHRvIGEgbGlzdCwgY3JlYXRpbmcgaXQgaWYgbmVlZGVkXG4qICAgICBtaXhwYW5lbC5wZW9wbGUudW5pb24oJ3BhZ2VzX3Zpc2l0ZWQnLCAnaG9tZXBhZ2UnKTtcbipcbiogICAgIC8vIGxpa2UgbWl4cGFuZWwucGVvcGxlLnNldCgpLCB5b3UgY2FuIGFwcGVuZCBtdWx0aXBsZVxuKiAgICAgLy8gcHJvcGVydGllcyBhdCBvbmNlOlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKHtcbiogICAgICAgICBsaXN0MTogJ2JvYicsXG4qICAgICAgICAgbGlzdDI6IDEyM1xuKiAgICAgfSk7XG4qXG4qICAgICAvLyBsaWtlIG1peHBhbmVsLnBlb3BsZS5hcHBlbmQoKSwgeW91IGNhbiBhcHBlbmQgbXVsdGlwbGVcbiogICAgIC8vIHZhbHVlcyB0byB0aGUgc2FtZSBsaXN0OlxuKiAgICAgbWl4cGFuZWwucGVvcGxlLnVuaW9uKHtcbiogICAgICAgICBsaXN0MTogWydib2InLCAnYmlsbHknXVxuKiAgICAgfSk7XG4qXG4qIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gbGlzdF9uYW1lIElmIGEgc3RyaW5nLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eS4gSWYgYW4gb2JqZWN0LCB0aGlzIGlzIGFuIGFzc29jaWF0aXZlIGFycmF5IG9mIG5hbWVzIGFuZCB2YWx1ZXMuXG4qIEBwYXJhbSB7Kn0gW3ZhbHVlXSBWYWx1ZSAvIHZhbHVlcyB0byBtZXJnZSB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eVxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bmlvbiA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxQZW9wbGUoZnVuY3Rpb24obGlzdF9uYW1lLCB2YWx1ZXMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKF8uaXNPYmplY3QobGlzdF9uYW1lKSkge1xuICAgICAgICBjYWxsYmFjayA9IHZhbHVlcztcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB0aGlzLnVuaW9uX2FjdGlvbihsaXN0X25hbWUsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhLCBjYWxsYmFjayk7XG59KTtcblxuLypcbiAqIFJlY29yZCB0aGF0IHlvdSBoYXZlIGNoYXJnZWQgdGhlIGN1cnJlbnQgdXNlciBhIGNlcnRhaW4gYW1vdW50XG4gKiBvZiBtb25leS4gQ2hhcmdlcyByZWNvcmRlZCB3aXRoIHRyYWNrX2NoYXJnZSgpIHdpbGwgYXBwZWFyIGluIHRoZVxuICogTWl4cGFuZWwgcmV2ZW51ZSByZXBvcnQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBjaGFyZ2UgYSB1c2VyICQ1MFxuICogICAgIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UoNTApO1xuICpcbiAqICAgICAvLyBjaGFyZ2UgYSB1c2VyICQzMC41MCBvbiB0aGUgMm5kIG9mIGphbnVhcnlcbiAqICAgICBtaXhwYW5lbC5wZW9wbGUudHJhY2tfY2hhcmdlKDMwLjUwLCB7XG4gKiAgICAgICAgICckdGltZSc6IG5ldyBEYXRlKCdqYW4gMSAyMDEyJylcbiAqICAgICB9KTtcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gYW1vdW50IFRoZSBhbW91bnQgb2YgbW9uZXkgY2hhcmdlZCB0byB0aGUgY3VycmVudCB1c2VyXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXNdIEFuIGFzc29jaWF0aXZlIGFycmF5IG9mIHByb3BlcnRpZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGFyZ2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBzZXJ2ZXIgcmVzcG9uZHNcbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50cmFja19jaGFyZ2UgPSBhZGRPcHRPdXRDaGVja01peHBhbmVsUGVvcGxlKGZ1bmN0aW9uKGFtb3VudCwgcHJvcGVydGllcywgY2FsbGJhY2spIHtcbiAgICBpZiAoIV8uaXNOdW1iZXIoYW1vdW50KSkge1xuICAgICAgICBhbW91bnQgPSBwYXJzZUZsb2F0KGFtb3VudCk7XG4gICAgICAgIGlmIChpc05hTihhbW91bnQpKSB7XG4gICAgICAgICAgICBjb25zb2xlJDEuZXJyb3IoJ0ludmFsaWQgdmFsdWUgcGFzc2VkIHRvIG1peHBhbmVsLnBlb3BsZS50cmFja19jaGFyZ2UgLSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBlbmQoJyR0cmFuc2FjdGlvbnMnLCBfLmV4dGVuZCh7XG4gICAgICAgICckYW1vdW50JzogYW1vdW50XG4gICAgfSwgcHJvcGVydGllcyksIGNhbGxiYWNrKTtcbn0pO1xuXG4vKlxuICogUGVybWFuZW50bHkgY2xlYXIgYWxsIHJldmVudWUgcmVwb3J0IHRyYW5zYWN0aW9ucyBmcm9tIHRoZVxuICogY3VycmVudCB1c2VyJ3MgcGVvcGxlIGFuYWx5dGljcyBwcm9maWxlLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgbWl4cGFuZWwucGVvcGxlLmNsZWFyX2NoYXJnZXMoKTtcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmNsZWFyX2NoYXJnZXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnNldCgnJHRyYW5zYWN0aW9ucycsIFtdLCBjYWxsYmFjayk7XG59O1xuXG4vKlxuKiBQZXJtYW5lbnRseSBkZWxldGVzIHRoZSBjdXJyZW50IHBlb3BsZSBhbmFseXRpY3MgcHJvZmlsZSBmcm9tXG4qIE1peHBhbmVsICh1c2luZyB0aGUgY3VycmVudCBkaXN0aW5jdF9pZCkuXG4qXG4qICMjIyBVc2FnZTpcbipcbiogICAgIC8vIHJlbW92ZSB0aGUgYWxsIGRhdGEgeW91IGhhdmUgc3RvcmVkIGFib3V0IHRoZSBjdXJyZW50IHVzZXJcbiogICAgIG1peHBhbmVsLnBlb3BsZS5kZWxldGVfdXNlcigpO1xuKlxuKi9cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5kZWxldGVfdXNlciA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdtaXhwYW5lbC5wZW9wbGUuZGVsZXRlX3VzZXIoKSByZXF1aXJlcyB5b3UgdG8gY2FsbCBpZGVudGlmeSgpIGZpcnN0Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSB7JyRkZWxldGUnOiB0aGlzLl9taXhwYW5lbC5nZXRfZGlzdGluY3RfaWQoKX07XG4gICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChkYXRhKTtcbn07XG5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC50b1N0cmluZygpICsgJy5wZW9wbGUnO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9zZW5kX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICAgIGRhdGFbJyR0b2tlbiddID0gdGhpcy5fZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICBkYXRhWyckZGlzdGluY3RfaWQnXSA9IHRoaXMuX21peHBhbmVsLmdldF9kaXN0aW5jdF9pZCgpO1xuICAgIHZhciBkZXZpY2VfaWQgPSB0aGlzLl9taXhwYW5lbC5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKTtcbiAgICB2YXIgdXNlcl9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJHVzZXJfaWQnKTtcbiAgICB2YXIgaGFkX3BlcnNpc3RlZF9kaXN0aW5jdF9pZCA9IHRoaXMuX21peHBhbmVsLmdldF9wcm9wZXJ0eSgnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnKTtcbiAgICBpZiAoZGV2aWNlX2lkKSB7XG4gICAgICAgIGRhdGFbJyRkZXZpY2VfaWQnXSA9IGRldmljZV9pZDtcbiAgICB9XG4gICAgaWYgKHVzZXJfaWQpIHtcbiAgICAgICAgZGF0YVsnJHVzZXJfaWQnXSA9IHVzZXJfaWQ7XG4gICAgfVxuICAgIGlmIChoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkKSB7XG4gICAgICAgIGRhdGFbJyRoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkJ10gPSBoYWRfcGVyc2lzdGVkX2Rpc3RpbmN0X2lkO1xuICAgIH1cblxuICAgIHZhciBkYXRlX2VuY29kZWRfZGF0YSA9IF8uZW5jb2RlRGF0ZXMoZGF0YSk7XG5cbiAgICBpZiAoIXRoaXMuX2lkZW50aWZ5X2NhbGxlZCgpKSB7XG4gICAgICAgIHRoaXMuX2VucXVldWUoZGF0YSk7XG4gICAgICAgIGlmICghXy5pc1VuZGVmaW5lZChjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRfY29uZmlnKCd2ZXJib3NlJykpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh7c3RhdHVzOiAtMSwgZXJyb3I6IG51bGx9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfLnRydW5jYXRlKGRhdGVfZW5jb2RlZF9kYXRhLCAyNTUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fdHJhY2tfb3JfYmF0Y2goe1xuICAgICAgICB0eXBlOiAncGVvcGxlJyxcbiAgICAgICAgZGF0YTogZGF0ZV9lbmNvZGVkX2RhdGEsXG4gICAgICAgIGVuZHBvaW50OiB0aGlzLl9nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgJy8nICsgIHRoaXMuX2dldF9jb25maWcoJ2FwaV9yb3V0ZXMnKVsnZW5nYWdlJ10sXG4gICAgICAgIGJhdGNoZXI6IHRoaXMuX21peHBhbmVsLnJlcXVlc3RfYmF0Y2hlcnMucGVvcGxlXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9nZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZl92YXIpIHtcbiAgICByZXR1cm4gdGhpcy5fbWl4cGFuZWwuZ2V0X2NvbmZpZyhjb25mX3Zhcik7XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2lkZW50aWZ5X2NhbGxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9taXhwYW5lbC5fZmxhZ3MuaWRlbnRpZnlfY2FsbGVkID09PSB0cnVlO1xufTtcblxuLy8gUXVldWUgdXAgZW5nYWdlIG9wZXJhdGlvbnMgaWYgaWRlbnRpZnkgaGFzbid0IGJlZW4gY2FsbGVkIHlldC5cbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS5fZW5xdWV1ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBpZiAoU0VUX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFNFVF9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSBpZiAoU0VUX09OQ0VfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoU0VUX09OQ0VfQUNUSU9OLCBkYXRhKTtcbiAgICB9IGVsc2UgaWYgKFVOU0VUX0FDVElPTiBpbiBkYXRhKSB7XG4gICAgICAgIHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChBRERfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChBUFBFTkRfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoQVBQRU5EX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChSRU1PVkVfQUNUSU9OIGluIGRhdGEpIHtcbiAgICAgICAgdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoUkVNT1ZFX0FDVElPTiwgZGF0YSk7XG4gICAgfSBlbHNlIGlmIChVTklPTl9BQ1RJT04gaW4gZGF0YSkge1xuICAgICAgICB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShVTklPTl9BQ1RJT04sIGRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcignSW52YWxpZCBjYWxsIHRvIF9lbnF1ZXVlKCk6JywgZGF0YSk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9mbHVzaF9vbmVfcXVldWUgPSBmdW5jdGlvbihhY3Rpb24sIGFjdGlvbl9tZXRob2QsIGNhbGxiYWNrLCBxdWV1ZV90b19wYXJhbXNfZm4pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBxdWV1ZWRfZGF0YSA9IF8uZXh0ZW5kKHt9LCB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKGFjdGlvbikpO1xuICAgIHZhciBhY3Rpb25fcGFyYW1zID0gcXVldWVkX2RhdGE7XG5cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocXVldWVkX2RhdGEpICYmIF8uaXNPYmplY3QocXVldWVkX2RhdGEpICYmICFfLmlzRW1wdHlPYmplY3QocXVldWVkX2RhdGEpKSB7XG4gICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKGFjdGlvbiwgcXVldWVkX2RhdGEpO1xuICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICBpZiAocXVldWVfdG9fcGFyYW1zX2ZuKSB7XG4gICAgICAgICAgICBhY3Rpb25fcGFyYW1zID0gcXVldWVfdG9fcGFyYW1zX2ZuKHF1ZXVlZF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBhY3Rpb25fbWV0aG9kLmNhbGwoX3RoaXMsIGFjdGlvbl9wYXJhbXMsIGZ1bmN0aW9uKHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgICAgICAgICAvLyBvbiBiYWQgcmVzcG9uc2UsIHdlIHdhbnQgdG8gYWRkIGl0IGJhY2sgdG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UgPT09IDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uX2FkZF90b19wZW9wbGVfcXVldWUoYWN0aW9uLCBxdWV1ZWRfZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG4vLyBGbHVzaCBxdWV1ZWQgZW5nYWdlIG9wZXJhdGlvbnMgLSBvcmRlciBkb2VzIG5vdCBtYXR0ZXIsXG4vLyBhbmQgdGhlcmUgYXJlIG5ldHdvcmsgbGV2ZWwgcmFjZSBjb25kaXRpb25zIGFueXdheVxuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uKFxuICAgIF9zZXRfY2FsbGJhY2ssIF9hZGRfY2FsbGJhY2ssIF9hcHBlbmRfY2FsbGJhY2ssIF9zZXRfb25jZV9jYWxsYmFjaywgX3VuaW9uX2NhbGxiYWNrLCBfdW5zZXRfY2FsbGJhY2ssIF9yZW1vdmVfY2FsbGJhY2tcbikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoU0VUX0FDVElPTiwgdGhpcy5zZXQsIF9zZXRfY2FsbGJhY2spO1xuICAgIHRoaXMuX2ZsdXNoX29uZV9xdWV1ZShTRVRfT05DRV9BQ1RJT04sIHRoaXMuc2V0X29uY2UsIF9zZXRfb25jZV9jYWxsYmFjayk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKFVOU0VUX0FDVElPTiwgdGhpcy51bnNldCwgX3Vuc2V0X2NhbGxiYWNrLCBmdW5jdGlvbihxdWV1ZSkgeyByZXR1cm4gXy5rZXlzKHF1ZXVlKTsgfSk7XG4gICAgdGhpcy5fZmx1c2hfb25lX3F1ZXVlKEFERF9BQ1RJT04sIHRoaXMuaW5jcmVtZW50LCBfYWRkX2NhbGxiYWNrKTtcbiAgICB0aGlzLl9mbHVzaF9vbmVfcXVldWUoVU5JT05fQUNUSU9OLCB0aGlzLnVuaW9uLCBfdW5pb25fY2FsbGJhY2spO1xuXG4gICAgLy8gd2UgaGF2ZSB0byBmaXJlIG9mZiBlYWNoICRhcHBlbmQgaW5kaXZpZHVhbGx5IHNpbmNlIHRoZXJlIGlzXG4gICAgLy8gbm8gY29uY2F0IG1ldGhvZCBzZXJ2ZXIgc2lkZVxuICAgIHZhciAkYXBwZW5kX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShBUFBFTkRfQUNUSU9OKTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoJGFwcGVuZF9xdWV1ZSkgJiYgXy5pc0FycmF5KCRhcHBlbmRfcXVldWUpICYmICRhcHBlbmRfcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciAkYXBwZW5kX2l0ZW07XG4gICAgICAgIHZhciBhcHBlbmRfY2FsbGJhY2sgPSBmdW5jdGlvbihyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLl9hZGRfdG9fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sICRhcHBlbmRfaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV8uaXNVbmRlZmluZWQoX2FwcGVuZF9jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBfYXBwZW5kX2NhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgaSA9ICRhcHBlbmRfcXVldWUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICRhcHBlbmRfcXVldWUgPSB0aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5sb2FkX3F1ZXVlKEFQUEVORF9BQ1RJT04pO1xuICAgICAgICAgICAgJGFwcGVuZF9pdGVtID0gJGFwcGVuZF9xdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5zYXZlKCk7XG4gICAgICAgICAgICBpZiAoIV8uaXNFbXB0eU9iamVjdCgkYXBwZW5kX2l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYXBwZW5kKCRhcHBlbmRfaXRlbSwgYXBwZW5kX2NhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIHNhbWUgZm9yICRyZW1vdmVcbiAgICB2YXIgJHJlbW92ZV9xdWV1ZSA9IHRoaXMuX21peHBhbmVsWydwZXJzaXN0ZW5jZSddLmxvYWRfcXVldWUoUkVNT1ZFX0FDVElPTik7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKCRyZW1vdmVfcXVldWUpICYmIF8uaXNBcnJheSgkcmVtb3ZlX3F1ZXVlKSAmJiAkcmVtb3ZlX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgJHJlbW92ZV9pdGVtO1xuICAgICAgICB2YXIgcmVtb3ZlX2NhbGxiYWNrID0gZnVuY3Rpb24ocmVzcG9uc2UsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9taXhwYW5lbFsncGVyc2lzdGVuY2UnXS5fYWRkX3RvX3Blb3BsZV9xdWV1ZShSRU1PVkVfQUNUSU9OLCAkcmVtb3ZlX2l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKF9yZW1vdmVfY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgX3JlbW92ZV9jYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGogPSAkcmVtb3ZlX3F1ZXVlLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAkcmVtb3ZlX3F1ZXVlID0gdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10ubG9hZF9xdWV1ZShSRU1PVkVfQUNUSU9OKTtcbiAgICAgICAgICAgICRyZW1vdmVfaXRlbSA9ICRyZW1vdmVfcXVldWUucG9wKCk7XG4gICAgICAgICAgICBfdGhpcy5fbWl4cGFuZWxbJ3BlcnNpc3RlbmNlJ10uc2F2ZSgpO1xuICAgICAgICAgICAgaWYgKCFfLmlzRW1wdHlPYmplY3QoJHJlbW92ZV9pdGVtKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZSgkcmVtb3ZlX2l0ZW0sIHJlbW92ZV9jYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuX2lzX3Jlc2VydmVkX3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHJldHVybiBwcm9wID09PSAnJGRpc3RpbmN0X2lkJyB8fCBwcm9wID09PSAnJHRva2VuJyB8fCBwcm9wID09PSAnJGRldmljZV9pZCcgfHwgcHJvcCA9PT0gJyR1c2VyX2lkJyB8fCBwcm9wID09PSAnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnO1xufTtcblxuLy8gTWl4cGFuZWxQZW9wbGUgRXhwb3J0c1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydzZXQnXSAgICAgICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0O1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydzZXRfb25jZSddICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuc2V0X29uY2U7XG5NaXhwYW5lbFBlb3BsZS5wcm90b3R5cGVbJ3Vuc2V0J10gICAgICAgICA9IE1peHBhbmVsUGVvcGxlLnByb3RvdHlwZS51bnNldDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnaW5jcmVtZW50J10gICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmluY3JlbWVudDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnYXBwZW5kJ10gICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmFwcGVuZDtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsncmVtb3ZlJ10gICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnJlbW92ZTtcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsndW5pb24nXSAgICAgICAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLnVuaW9uO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd0cmFja19jaGFyZ2UnXSAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudHJhY2tfY2hhcmdlO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWydjbGVhcl9jaGFyZ2VzJ10gPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUuY2xlYXJfY2hhcmdlcztcbk1peHBhbmVsUGVvcGxlLnByb3RvdHlwZVsnZGVsZXRlX3VzZXInXSAgID0gTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlLmRlbGV0ZV91c2VyO1xuTWl4cGFuZWxQZW9wbGUucHJvdG90eXBlWyd0b1N0cmluZyddICAgICAgPSBNaXhwYW5lbFBlb3BsZS5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxuLypcbiAqIENvbnN0YW50c1xuICovXG4vKiogQGNvbnN0ICovIHZhciBTRVRfUVVFVUVfS0VZICAgICAgICAgID0gJ19fbXBzJztcbi8qKiBAY29uc3QgKi8gdmFyIFNFVF9PTkNFX1FVRVVFX0tFWSAgICAgPSAnX19tcHNvJztcbi8qKiBAY29uc3QgKi8gdmFyIFVOU0VUX1FVRVVFX0tFWSAgICAgICAgPSAnX19tcHVzJztcbi8qKiBAY29uc3QgKi8gdmFyIEFERF9RVUVVRV9LRVkgICAgICAgICAgPSAnX19tcGEnO1xuLyoqIEBjb25zdCAqLyB2YXIgQVBQRU5EX1FVRVVFX0tFWSAgICAgICA9ICdfX21wYXAnO1xuLyoqIEBjb25zdCAqLyB2YXIgUkVNT1ZFX1FVRVVFX0tFWSAgICAgICA9ICdfX21wcic7XG4vKiogQGNvbnN0ICovIHZhciBVTklPTl9RVUVVRV9LRVkgICAgICAgID0gJ19fbXB1Jztcbi8vIFRoaXMga2V5IGlzIGRlcHJlY2F0ZWQsIGJ1dCB3ZSB3YW50IHRvIGNoZWNrIGZvciBpdCB0byBzZWUgd2hldGhlciBhbGlhc2luZyBpcyBhbGxvd2VkLlxuLyoqIEBjb25zdCAqLyB2YXIgUEVPUExFX0RJU1RJTkNUX0lEX0tFWSA9ICckcGVvcGxlX2Rpc3RpbmN0X2lkJztcbi8qKiBAY29uc3QgKi8gdmFyIEFMSUFTX0lEX0tFWSAgICAgICAgICAgPSAnX19hbGlhcyc7XG4vKiogQGNvbnN0ICovIHZhciBFVkVOVF9USU1FUlNfS0VZICAgICAgID0gJ19fdGltZXJzJztcbi8qKiBAY29uc3QgKi8gdmFyIFJFU0VSVkVEX1BST1BFUlRJRVMgPSBbXG4gICAgU0VUX1FVRVVFX0tFWSxcbiAgICBTRVRfT05DRV9RVUVVRV9LRVksXG4gICAgVU5TRVRfUVVFVUVfS0VZLFxuICAgIEFERF9RVUVVRV9LRVksXG4gICAgQVBQRU5EX1FVRVVFX0tFWSxcbiAgICBSRU1PVkVfUVVFVUVfS0VZLFxuICAgIFVOSU9OX1FVRVVFX0tFWSxcbiAgICBQRU9QTEVfRElTVElOQ1RfSURfS0VZLFxuICAgIEFMSUFTX0lEX0tFWSxcbiAgICBFVkVOVF9USU1FUlNfS0VZXG5dO1xuXG4vKipcbiAqIE1peHBhbmVsIFBlcnNpc3RlbmNlIE9iamVjdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNaXhwYW5lbFBlcnNpc3RlbmNlID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdGhpc1sncHJvcHMnXSA9IHt9O1xuICAgIHRoaXMuY2FtcGFpZ25fcGFyYW1zX3NhdmVkID0gZmFsc2U7XG5cbiAgICBpZiAoY29uZmlnWydwZXJzaXN0ZW5jZV9uYW1lJ10pIHtcbiAgICAgICAgdGhpcy5uYW1lID0gJ21wXycgKyBjb25maWdbJ3BlcnNpc3RlbmNlX25hbWUnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5hbWUgPSAnbXBfJyArIGNvbmZpZ1sndG9rZW4nXSArICdfbWl4cGFuZWwnO1xuICAgIH1cblxuICAgIHZhciBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ107XG4gICAgaWYgKHN0b3JhZ2VfdHlwZSAhPT0gJ2Nvb2tpZScgJiYgc3RvcmFnZV90eXBlICE9PSAnbG9jYWxTdG9yYWdlJykge1xuICAgICAgICBjb25zb2xlJDEuY3JpdGljYWwoJ1Vua25vd24gcGVyc2lzdGVuY2UgdHlwZSAnICsgc3RvcmFnZV90eXBlICsgJzsgZmFsbGluZyBiYWNrIHRvIGNvb2tpZScpO1xuICAgICAgICBzdG9yYWdlX3R5cGUgPSBjb25maWdbJ3BlcnNpc3RlbmNlJ10gPSAnY29va2llJztcbiAgICB9XG5cbiAgICBpZiAoc3RvcmFnZV90eXBlID09PSAnbG9jYWxTdG9yYWdlJyAmJiBfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmxvY2FsU3RvcmFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBfLmNvb2tpZTtcbiAgICB9XG5cbiAgICB0aGlzLmxvYWQoKTtcbiAgICB0aGlzLnVwZGF0ZV9jb25maWcoY29uZmlnKTtcbiAgICB0aGlzLnVwZ3JhZGUoKTtcbiAgICB0aGlzLnNhdmUoKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnByb3BlcnRpZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcCA9IHt9O1xuXG4gICAgdGhpcy5sb2FkKCk7XG5cbiAgICAvLyBGaWx0ZXIgb3V0IHJlc2VydmVkIHByb3BlcnRpZXNcbiAgICBfLmVhY2godGhpc1sncHJvcHMnXSwgZnVuY3Rpb24odiwgaykge1xuICAgICAgICBpZiAoIV8uaW5jbHVkZShSRVNFUlZFRF9QUk9QRVJUSUVTLCBrKSkge1xuICAgICAgICAgICAgcFtrXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcDtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHZhciBlbnRyeSA9IHRoaXMuc3RvcmFnZS5wYXJzZSh0aGlzLm5hbWUpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICAgIHRoaXNbJ3Byb3BzJ10gPSBfLmV4dGVuZCh7fSwgZW50cnkpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZ3JhZGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb2xkX2Nvb2tpZSxcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZTtcblxuICAgIC8vIGlmIHRyYW5zZmVycmluZyBmcm9tIGNvb2tpZSB0byBsb2NhbFN0b3JhZ2Ugb3IgdmljZS12ZXJzYSwgY29weSBleGlzdGluZ1xuICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgb3ZlciB0byBuZXcgc3RvcmFnZSBtb2RlXG4gICAgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgb2xkX2Nvb2tpZSA9IF8uY29va2llLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5jb29raWUucmVtb3ZlKHRoaXMubmFtZSk7XG4gICAgICAgIF8uY29va2llLnJlbW92ZSh0aGlzLm5hbWUsIHRydWUpO1xuXG4gICAgICAgIGlmIChvbGRfY29va2llKSB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyX29uY2Uob2xkX2Nvb2tpZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuc3RvcmFnZSA9PT0gXy5jb29raWUpIHtcbiAgICAgICAgb2xkX2xvY2Fsc3RvcmFnZSA9IF8ubG9jYWxTdG9yYWdlLnBhcnNlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgXy5sb2NhbFN0b3JhZ2UucmVtb3ZlKHRoaXMubmFtZSk7XG5cbiAgICAgICAgaWYgKG9sZF9sb2NhbHN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZShvbGRfbG9jYWxzdG9yYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkgeyByZXR1cm47IH1cblxuICAgIHRoaXMuc3RvcmFnZS5zZXQoXG4gICAgICAgIHRoaXMubmFtZSxcbiAgICAgICAgXy5KU09ORW5jb2RlKHRoaXNbJ3Byb3BzJ10pLFxuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzLFxuICAgICAgICB0aGlzLmNyb3NzX3N1YmRvbWFpbixcbiAgICAgICAgdGhpcy5zZWN1cmUsXG4gICAgICAgIHRoaXMuY3Jvc3Nfc2l0ZSxcbiAgICAgICAgdGhpcy5jb29raWVfZG9tYWluXG4gICAgKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLmxvYWRfcHJvcCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHRoaXMubG9hZCgpO1xuICAgIHJldHVybiB0aGlzWydwcm9wcyddW2tleV07XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAvLyByZW1vdmUgYm90aCBkb21haW4gYW5kIHN1YmRvbWFpbiBjb29raWVzXG4gICAgdGhpcy5zdG9yYWdlLnJlbW92ZSh0aGlzLm5hbWUsIGZhbHNlLCB0aGlzLmNvb2tpZV9kb21haW4pO1xuICAgIHRoaXMuc3RvcmFnZS5yZW1vdmUodGhpcy5uYW1lLCB0cnVlLCB0aGlzLmNvb2tpZV9kb21haW4pO1xufTtcblxuLy8gcmVtb3ZlcyB0aGUgc3RvcmFnZSBlbnRyeSBhbmQgZGVsZXRlcyBhbGwgbG9hZGVkIGRhdGFcbi8vIGZvcmNlZCBuYW1lIGZvciB0ZXN0c1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlbW92ZSgpO1xuICAgIHRoaXNbJ3Byb3BzJ10gPSB7fTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiogQHBhcmFtIHsqPX0gZGVmYXVsdF92YWx1ZVxuKiBAcGFyYW0ge251bWJlcj19IGRheXNcbiovXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlID0gZnVuY3Rpb24ocHJvcHMsIGRlZmF1bHRfdmFsdWUsIGRheXMpIHtcbiAgICBpZiAoXy5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgaWYgKHR5cGVvZihkZWZhdWx0X3ZhbHVlKSA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVmYXVsdF92YWx1ZSA9ICdOb25lJzsgfVxuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzID0gKHR5cGVvZihkYXlzKSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5kZWZhdWx0X2V4cGlyeSA6IGRheXM7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG5cbiAgICAgICAgXy5lYWNoKHByb3BzLCBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICghdGhpc1sncHJvcHMnXS5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCB0aGlzWydwcm9wcyddW3Byb3BdID09PSBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpc1sncHJvcHMnXVtwcm9wXSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuKiBAcGFyYW0ge09iamVjdH0gcHJvcHNcbiogQHBhcmFtIHtudW1iZXI9fSBkYXlzXG4qL1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wcywgZGF5cykge1xuICAgIGlmIChfLmlzT2JqZWN0KHByb3BzKSkge1xuICAgICAgICB0aGlzLmV4cGlyZV9kYXlzID0gKHR5cGVvZihkYXlzKSA9PT0gJ3VuZGVmaW5lZCcpID8gdGhpcy5kZWZhdWx0X2V4cGlyeSA6IGRheXM7XG5cbiAgICAgICAgdGhpcy5sb2FkKCk7XG4gICAgICAgIF8uZXh0ZW5kKHRoaXNbJ3Byb3BzJ10sIHByb3BzKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVucmVnaXN0ZXIgPSBmdW5jdGlvbihwcm9wKSB7XG4gICAgdGhpcy5sb2FkKCk7XG4gICAgaWYgKHByb3AgaW4gdGhpc1sncHJvcHMnXSkge1xuICAgICAgICBkZWxldGUgdGhpc1sncHJvcHMnXVtwcm9wXTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3NlYXJjaF9rZXl3b3JkID0gZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICB0aGlzLnJlZ2lzdGVyKF8uaW5mby5zZWFyY2hJbmZvKHJlZmVycmVyKSk7XG59O1xuXG4vLyBFWFBPUlRFRCBNRVRIT0QsIHdlIHRlc3QgdGhpcyBkaXJlY3RseS5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnVwZGF0ZV9yZWZlcnJlcl9pbmZvID0gZnVuY3Rpb24ocmVmZXJyZXIpIHtcbiAgICAvLyBJZiByZWZlcnJlciBkb2Vzbid0IGV4aXN0LCB3ZSB3YW50IHRvIG5vdGUgdGhlIGZhY3QgdGhhdCBpdCB3YXMgdHlwZS1pbiB0cmFmZmljLlxuICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICckaW5pdGlhbF9yZWZlcnJlcic6IHJlZmVycmVyIHx8ICckZGlyZWN0JyxcbiAgICAgICAgJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nOiBfLmluZm8ucmVmZXJyaW5nRG9tYWluKHJlZmVycmVyKSB8fCAnJGRpcmVjdCdcbiAgICB9LCAnJyk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfcmVmZXJyZXJfaW5mbyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnN0cmlwX2VtcHR5X3Byb3BlcnRpZXMoe1xuICAgICAgICAnJGluaXRpYWxfcmVmZXJyZXInOiB0aGlzWydwcm9wcyddWyckaW5pdGlhbF9yZWZlcnJlciddLFxuICAgICAgICAnJGluaXRpYWxfcmVmZXJyaW5nX2RvbWFpbic6IHRoaXNbJ3Byb3BzJ11bJyRpbml0aWFsX3JlZmVycmluZ19kb21haW4nXVxuICAgIH0pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX2NvbmZpZyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHRoaXMuZGVmYXVsdF9leHBpcnkgPSB0aGlzLmV4cGlyZV9kYXlzID0gY29uZmlnWydjb29raWVfZXhwaXJhdGlvbiddO1xuICAgIHRoaXMuc2V0X2Rpc2FibGVkKGNvbmZpZ1snZGlzYWJsZV9wZXJzaXN0ZW5jZSddKTtcbiAgICB0aGlzLnNldF9jb29raWVfZG9tYWluKGNvbmZpZ1snY29va2llX2RvbWFpbiddKTtcbiAgICB0aGlzLnNldF9jcm9zc19zaXRlKGNvbmZpZ1snY3Jvc3Nfc2l0ZV9jb29raWUnXSk7XG4gICAgdGhpcy5zZXRfY3Jvc3Nfc3ViZG9tYWluKGNvbmZpZ1snY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSddKTtcbiAgICB0aGlzLnNldF9zZWN1cmUoY29uZmlnWydzZWN1cmVfY29va2llJ10pO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Rpc2FibGVkID0gZnVuY3Rpb24oZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfY29va2llX2RvbWFpbiA9IGZ1bmN0aW9uKGNvb2tpZV9kb21haW4pIHtcbiAgICBpZiAoY29va2llX2RvbWFpbiAhPT0gdGhpcy5jb29raWVfZG9tYWluKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuY29va2llX2RvbWFpbiA9IGNvb2tpZV9kb21haW47XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLnNldF9jcm9zc19zaXRlID0gZnVuY3Rpb24oY3Jvc3Nfc2l0ZSkge1xuICAgIGlmIChjcm9zc19zaXRlICE9PSB0aGlzLmNyb3NzX3NpdGUpIHtcbiAgICAgICAgdGhpcy5jcm9zc19zaXRlID0gY3Jvc3Nfc2l0ZTtcbiAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X2Nyb3NzX3N1YmRvbWFpbiA9IGZ1bmN0aW9uKGNyb3NzX3N1YmRvbWFpbikge1xuICAgIGlmIChjcm9zc19zdWJkb21haW4gIT09IHRoaXMuY3Jvc3Nfc3ViZG9tYWluKSB7XG4gICAgICAgIHRoaXMuY3Jvc3Nfc3ViZG9tYWluID0gY3Jvc3Nfc3ViZG9tYWluO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Jvc3Nfc3ViZG9tYWluO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuc2V0X3NlY3VyZSA9IGZ1bmN0aW9uKHNlY3VyZSkge1xuICAgIGlmIChzZWN1cmUgIT09IHRoaXMuc2VjdXJlKSB7XG4gICAgICAgIHRoaXMuc2VjdXJlID0gc2VjdXJlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fYWRkX3RvX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHFfa2V5ID0gdGhpcy5fZ2V0X3F1ZXVlX2tleShxdWV1ZSksXG4gICAgICAgIHFfZGF0YSA9IGRhdGFbcXVldWVdLFxuICAgICAgICBzZXRfcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoU0VUX0FDVElPTiksXG4gICAgICAgIHNldF9vbmNlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFNFVF9PTkNFX0FDVElPTiksXG4gICAgICAgIHVuc2V0X3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFVOU0VUX0FDVElPTiksXG4gICAgICAgIGFkZF9xID0gdGhpcy5fZ2V0X29yX2NyZWF0ZV9xdWV1ZShBRERfQUNUSU9OKSxcbiAgICAgICAgdW5pb25fcSA9IHRoaXMuX2dldF9vcl9jcmVhdGVfcXVldWUoVU5JT05fQUNUSU9OKSxcbiAgICAgICAgcmVtb3ZlX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKFJFTU9WRV9BQ1RJT04sIFtdKSxcbiAgICAgICAgYXBwZW5kX3EgPSB0aGlzLl9nZXRfb3JfY3JlYXRlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIFtdKTtcblxuICAgIGlmIChxX2tleSA9PT0gU0VUX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHNldCBxdWV1ZSAtIHdlIGNhbiBvdmVycmlkZSBhbnkgZXhpc3RpbmcgdmFsdWVzXG4gICAgICAgIF8uZXh0ZW5kKHNldF9xLCBxX2RhdGEpO1xuICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBwZW5kaW5nIGluY3JlbWVudCwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoQUREX0FDVElPTiwgcV9kYXRhKTtcbiAgICAgICAgLy8gaWYgdGhlcmUgd2FzIGEgcGVuZGluZyB1bmlvbiwgb3ZlcnJpZGUgaXRcbiAgICAgICAgLy8gd2l0aCB0aGUgc2V0LlxuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5JT05fQUNUSU9OLCBxX2RhdGEpO1xuICAgICAgICB0aGlzLl9wb3BfZnJvbV9wZW9wbGVfcXVldWUoVU5TRVRfQUNUSU9OLCBxX2RhdGEpO1xuICAgIH0gZWxzZSBpZiAocV9rZXkgPT09IFNFVF9PTkNFX1FVRVVFX0tFWSkge1xuICAgICAgICAvLyBvbmx5IHF1ZXVlIHRoZSBkYXRhIGlmIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc2V0X29uY2UgY2FsbCBmb3IgaXQuXG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmICghKGsgaW4gc2V0X29uY2VfcSkpIHtcbiAgICAgICAgICAgICAgICBzZXRfb25jZV9xW2tdID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5TRVRfUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHByb3ApIHtcblxuICAgICAgICAgICAgLy8gdW5kbyBwcmV2aW91c2x5LXF1ZXVlZCBhY3Rpb25zIG9uIHRoaXMga2V5XG4gICAgICAgICAgICBfLmVhY2goW3NldF9xLCBzZXRfb25jZV9xLCBhZGRfcSwgdW5pb25fcV0sIGZ1bmN0aW9uKGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wIGluIGVucXVldWVkX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgZW5xdWV1ZWRfb2JqW3Byb3BdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXy5lYWNoKGFwcGVuZF9xLCBmdW5jdGlvbihhcHBlbmRfb2JqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gYXBwZW5kX29iaikge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYXBwZW5kX29ialtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdW5zZXRfcVtwcm9wXSA9IHRydWU7XG5cbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQUREX1FVRVVFX0tFWSkge1xuICAgICAgICBfLmVhY2gocV9kYXRhLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAvLyBJZiBpdCBleGlzdHMgaW4gdGhlIHNldCBxdWV1ZSwgaW5jcmVtZW50XG4gICAgICAgICAgICAvLyB0aGUgdmFsdWVcbiAgICAgICAgICAgIGlmIChrIGluIHNldF9xKSB7XG4gICAgICAgICAgICAgICAgc2V0X3Fba10gKz0gdjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBleGlzdCwgdXBkYXRlIHRoZSBhZGRcbiAgICAgICAgICAgICAgICAvLyBxdWV1ZVxuICAgICAgICAgICAgICAgIGlmICghKGsgaW4gYWRkX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZF9xW2tdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRkX3Fba10gKz0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gVU5JT05fUVVFVUVfS0VZKSB7XG4gICAgICAgIF8uZWFjaChxX2RhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChfLmlzQXJyYXkodikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrIGluIHVuaW9uX3EpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaW9uX3Fba10gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IHNlbmQgZHVwbGljYXRlcywgdGhlIHNlcnZlciB3aWxsIGRlZHVwIHRoZW0uXG4gICAgICAgICAgICAgICAgdW5pb25fcVtrXSA9IHVuaW9uX3Fba10uY29uY2F0KHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKFVOU0VUX0FDVElPTiwgcV9kYXRhKTtcbiAgICB9IGVsc2UgaWYgKHFfa2V5ID09PSBSRU1PVkVfUVVFVUVfS0VZKSB7XG4gICAgICAgIHJlbW92ZV9xLnB1c2gocV9kYXRhKTtcbiAgICAgICAgdGhpcy5fcG9wX2Zyb21fcGVvcGxlX3F1ZXVlKEFQUEVORF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfSBlbHNlIGlmIChxX2tleSA9PT0gQVBQRU5EX1FVRVVFX0tFWSkge1xuICAgICAgICBhcHBlbmRfcS5wdXNoKHFfZGF0YSk7XG4gICAgICAgIHRoaXMuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZShVTlNFVF9BQ1RJT04sIHFfZGF0YSk7XG4gICAgfVxuXG4gICAgY29uc29sZSQxLmxvZygnTUlYUEFORUwgUEVPUExFIFJFUVVFU1QgKFFVRVVFRCwgUEVORElORyBJREVOVElGWSk6Jyk7XG4gICAgY29uc29sZSQxLmxvZyhkYXRhKTtcblxuICAgIHRoaXMuc2F2ZSgpO1xufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuX3BvcF9mcm9tX3Blb3BsZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkYXRhKSB7XG4gICAgdmFyIHEgPSB0aGlzWydwcm9wcyddW3RoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpXTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocSkpIHtcbiAgICAgICAgXy5lYWNoKGRhdGEsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgICAgIGlmIChxdWV1ZSA9PT0gQVBQRU5EX0FDVElPTiB8fCBxdWV1ZSA9PT0gUkVNT1ZFX0FDVElPTikge1xuICAgICAgICAgICAgICAgIC8vIGxpc3QgYWN0aW9uczogb25seSByZW1vdmUgaWYgYm90aCBrK3YgbWF0Y2hcbiAgICAgICAgICAgICAgICAvLyBlLmcuIHJlbW92ZSBzaG91bGQgbm90IG92ZXJyaWRlIGFwcGVuZCBpbiBhIGNhc2UgbGlrZVxuICAgICAgICAgICAgICAgIC8vIGFwcGVuZCh7Zm9vOiAnYmFyJ30pOyByZW1vdmUoe2ZvbzogJ3F1eCd9KVxuICAgICAgICAgICAgICAgIF8uZWFjaChxLCBmdW5jdGlvbihxdWV1ZWRfYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZWRfYWN0aW9uW2tdID09PSB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcXVldWVkX2FjdGlvbltrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcVtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUubG9hZF9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlKSB7XG4gICAgcmV0dXJuIHRoaXMubG9hZF9wcm9wKHRoaXMuX2dldF9xdWV1ZV9rZXkocXVldWUpKTtcbn07XG5cbk1peHBhbmVsUGVyc2lzdGVuY2UucHJvdG90eXBlLl9nZXRfcXVldWVfa2V5ID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgICBpZiAocXVldWUgPT09IFNFVF9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gU0VUX09OQ0VfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBTRVRfT05DRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5TRVRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTlNFVF9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gQUREX0FDVElPTikge1xuICAgICAgICByZXR1cm4gQUREX1FVRVVFX0tFWTtcbiAgICB9IGVsc2UgaWYgKHF1ZXVlID09PSBBUFBFTkRfQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBBUFBFTkRfUVVFVUVfS0VZO1xuICAgIH0gZWxzZSBpZiAocXVldWUgPT09IFJFTU9WRV9BQ1RJT04pIHtcbiAgICAgICAgcmV0dXJuIFJFTU9WRV9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIGlmIChxdWV1ZSA9PT0gVU5JT05fQUNUSU9OKSB7XG4gICAgICAgIHJldHVybiBVTklPTl9RVUVVRV9LRVk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZSQxLmVycm9yKCdJbnZhbGlkIHF1ZXVlOicsIHF1ZXVlKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5fZ2V0X29yX2NyZWF0ZV9xdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBkZWZhdWx0X3ZhbCkge1xuICAgIHZhciBrZXkgPSB0aGlzLl9nZXRfcXVldWVfa2V5KHF1ZXVlKTtcbiAgICBkZWZhdWx0X3ZhbCA9IF8uaXNVbmRlZmluZWQoZGVmYXVsdF92YWwpID8ge30gOiBkZWZhdWx0X3ZhbDtcbiAgICByZXR1cm4gdGhpc1sncHJvcHMnXVtrZXldIHx8ICh0aGlzWydwcm9wcyddW2tleV0gPSBkZWZhdWx0X3ZhbCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5zZXRfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lLCB0aW1lc3RhbXApIHtcbiAgICB2YXIgdGltZXJzID0gdGhpcy5sb2FkX3Byb3AoRVZFTlRfVElNRVJTX0tFWSkgfHwge307XG4gICAgdGltZXJzW2V2ZW50X25hbWVdID0gdGltZXN0YW1wO1xuICAgIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV0gPSB0aW1lcnM7XG4gICAgdGhpcy5zYXZlKCk7XG59O1xuXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5yZW1vdmVfZXZlbnRfdGltZXIgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgdmFyIHRpbWVycyA9IHRoaXMubG9hZF9wcm9wKEVWRU5UX1RJTUVSU19LRVkpIHx8IHt9O1xuICAgIHZhciB0aW1lc3RhbXAgPSB0aW1lcnNbZXZlbnRfbmFtZV07XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHRpbWVzdGFtcCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXNbJ3Byb3BzJ11bRVZFTlRfVElNRVJTX0tFWV1bZXZlbnRfbmFtZV07XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGltZXN0YW1wO1xufTtcblxuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG4vKlxuICogTWl4cGFuZWwgSlMgTGlicmFyeVxuICpcbiAqIENvcHlyaWdodCAyMDEyLCBNaXhwYW5lbCwgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkXG4gKiBodHRwOi8vbWl4cGFuZWwuY29tL1xuICpcbiAqIEluY2x1ZGVzIHBvcnRpb25zIG9mIFVuZGVyc2NvcmUuanNcbiAqIGh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vdW5kZXJzY29yZS9cbiAqIChjKSAyMDExIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cblxuLy8gPT1DbG9zdXJlQ29tcGlsZXI9PVxuLy8gQGNvbXBpbGF0aW9uX2xldmVsIEFEVkFOQ0VEX09QVElNSVpBVElPTlNcbi8vIEBvdXRwdXRfZmlsZV9uYW1lIG1peHBhbmVsLTIuOC5taW4uanNcbi8vID09L0Nsb3N1cmVDb21waWxlcj09XG5cbi8qXG5TSU1QTEUgU1RZTEUgR1VJREU6XG5cbnRoaXMueCA9PT0gcHVibGljIGZ1bmN0aW9uXG50aGlzLl94ID09PSBpbnRlcm5hbCAtIG9ubHkgdXNlIHdpdGhpbiB0aGlzIGZpbGVcbnRoaXMuX194ID09PSBwcml2YXRlIC0gb25seSB1c2Ugd2l0aGluIHRoZSBjbGFzc1xuXG5HbG9iYWxzIHNob3VsZCBiZSBhbGwgY2Fwc1xuKi9cblxudmFyIGluaXRfdHlwZTsgICAgICAgLy8gTU9EVUxFIG9yIFNOSVBQRVQgbG9hZGVyXG4vLyBhbGxvdyBidW5kbGVycyB0byBzcGVjaWZ5IGhvdyBleHRyYSBjb2RlIChyZWNvcmRlciBidW5kbGUpIHNob3VsZCBiZSBsb2FkZWRcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xudmFyIGxvYWRfZXh0cmFfYnVuZGxlID0gZnVuY3Rpb24oc3JjLCBfb25sb2FkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKHNyYyArICcgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGJ1aWxkLicpO1xufTtcblxudmFyIG1peHBhbmVsX21hc3RlcjsgLy8gbWFpbiBtaXhwYW5lbCBpbnN0YW5jZSAvIG9iamVjdFxudmFyIElOSVRfTU9EVUxFICA9IDA7XG52YXIgSU5JVF9TTklQUEVUID0gMTtcblxudmFyIElERU5USVRZX0ZVTkMgPSBmdW5jdGlvbih4KSB7cmV0dXJuIHg7fTtcbnZhciBOT09QX0ZVTkMgPSBmdW5jdGlvbigpIHt9O1xuXG4vKiogQGNvbnN0ICovIHZhciBQUklNQVJZX0lOU1RBTkNFX05BTUUgPSAnbWl4cGFuZWwnO1xuLyoqIEBjb25zdCAqLyB2YXIgUEFZTE9BRF9UWVBFX0JBU0U2NCAgID0gJ2Jhc2U2NCc7XG4vKiogQGNvbnN0ICovIHZhciBQQVlMT0FEX1RZUEVfSlNPTiAgICAgPSAnanNvbic7XG4vKiogQGNvbnN0ICovIHZhciBERVZJQ0VfSURfUFJFRklYICAgICAgPSAnJGRldmljZTonO1xuXG5cbi8qXG4gKiBEeW5hbWljLi4uIGNvbnN0YW50cz8gSXMgdGhhdCBhbiBveHltb3Jvbj9cbiAqL1xuLy8gaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0RPTS9YTUxIdHRwUmVxdWVzdCN3aXRoQ3JlZGVudGlhbHNcbnZhciBVU0VfWEhSID0gKHdpbi5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSk7XG5cbi8vIElFPDEwIGRvZXMgbm90IHN1cHBvcnQgY3Jvc3Mtb3JpZ2luIFhIUidzIGJ1dCBzY3JpcHQgdGFnc1xuLy8gd2l0aCBkZWZlciB3b24ndCBibG9jayB3aW5kb3cub25sb2FkOyBFTlFVRVVFX1JFUVVFU1RTXG4vLyBzaG91bGQgb25seSBiZSB0cnVlIGZvciBPcGVyYTwxMlxudmFyIEVOUVVFVUVfUkVRVUVTVFMgPSAhVVNFX1hIUiAmJiAodXNlckFnZW50LmluZGV4T2YoJ01TSUUnKSA9PT0gLTEpICYmICh1c2VyQWdlbnQuaW5kZXhPZignTW96aWxsYScpID09PSAtMSk7XG5cbi8vIHNhdmUgcmVmZXJlbmNlIHRvIG5hdmlnYXRvci5zZW5kQmVhY29uIHNvIGl0IGNhbiBiZSBtaW5pZmllZFxudmFyIHNlbmRCZWFjb24gPSBudWxsO1xuaWYgKG5hdmlnYXRvclsnc2VuZEJlYWNvbiddKSB7XG4gICAgc2VuZEJlYWNvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBsYXRlIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3Iuc2VuZEJlYWNvbiB0byBhbGxvdyBwYXRjaGluZy9zcHlpbmdcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvclsnc2VuZEJlYWNvbiddLmFwcGx5KG5hdmlnYXRvciwgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG52YXIgREVGQVVMVF9BUElfUk9VVEVTID0ge1xuICAgICd0cmFjayc6ICd0cmFjay8nLFxuICAgICdlbmdhZ2UnOiAnZW5nYWdlLycsXG4gICAgJ2dyb3Vwcyc6ICdncm91cHMvJyxcbiAgICAncmVjb3JkJzogJ3JlY29yZC8nXG59O1xuXG4vKlxuICogTW9kdWxlLWxldmVsIGdsb2JhbHNcbiAqL1xudmFyIERFRkFVTFRfQ09ORklHID0ge1xuICAgICdhcGlfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9hcGktanMubWl4cGFuZWwuY29tJyxcbiAgICAnYXBpX3JvdXRlcyc6ICAgICAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9BUElfUk9VVEVTLFxuICAgICdhcGlfbWV0aG9kJzogICAgICAgICAgICAgICAgICAgICAgICAnUE9TVCcsXG4gICAgJ2FwaV90cmFuc3BvcnQnOiAgICAgICAgICAgICAgICAgICAgICdYSFInLFxuICAgICdhcGlfcGF5bG9hZF9mb3JtYXQnOiAgICAgICAgICAgICAgICBQQVlMT0FEX1RZUEVfQkFTRTY0LFxuICAgICdhcHBfaG9zdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9taXhwYW5lbC5jb20nLFxuICAgICdjZG4nOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaHR0cHM6Ly9jZG4ubXhwbmwuY29tJyxcbiAgICAnY3Jvc3Nfc2l0ZV9jb29raWUnOiAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Nyb3NzX3N1YmRvbWFpbl9jb29raWUnOiAgICAgICAgICAgIHRydWUsXG4gICAgJ2Vycm9yX3JlcG9ydGVyJzogICAgICAgICAgICAgICAgICAgIE5PT1BfRlVOQyxcbiAgICAncGVyc2lzdGVuY2UnOiAgICAgICAgICAgICAgICAgICAgICAgJ2Nvb2tpZScsXG4gICAgJ3BlcnNpc3RlbmNlX25hbWUnOiAgICAgICAgICAgICAgICAgICcnLFxuICAgICdjb29raWVfZG9tYWluJzogICAgICAgICAgICAgICAgICAgICAnJyxcbiAgICAnY29va2llX25hbWUnOiAgICAgICAgICAgICAgICAgICAgICAgJycsXG4gICAgJ2xvYWRlZCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5PT1BfRlVOQyxcbiAgICAnbXBfbG9hZGVyJzogICAgICAgICAgICAgICAgICAgICAgICAgbnVsbCxcbiAgICAndHJhY2tfbWFya2V0aW5nJzogICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAndHJhY2tfcGFnZXZpZXcnOiAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3NraXBfZmlyc3RfdG91Y2hfbWFya2V0aW5nJzogICAgICAgIGZhbHNlLFxuICAgICdzdG9yZV9nb29nbGUnOiAgICAgICAgICAgICAgICAgICAgICB0cnVlLFxuICAgICdzdG9wX3V0bV9wZXJzaXN0ZW5jZSc6ICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnc2F2ZV9yZWZlcnJlcic6ICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAndGVzdCc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3ZlcmJvc2UnOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdpbWcnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnZGVidWcnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3RyYWNrX2xpbmtzX3RpbWVvdXQnOiAgICAgICAgICAgICAgIDMwMCxcbiAgICAnY29va2llX2V4cGlyYXRpb24nOiAgICAgICAgICAgICAgICAgMzY1LFxuICAgICd1cGdyYWRlJzogICAgICAgICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnZGlzYWJsZV9wZXJzaXN0ZW5jZSc6ICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2Rpc2FibGVfY29va2llJzogICAgICAgICAgICAgICAgICAgIGZhbHNlLFxuICAgICdzZWN1cmVfY29va2llJzogICAgICAgICAgICAgICAgICAgICBmYWxzZSxcbiAgICAnaXAnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0JzogICAgICAgZmFsc2UsXG4gICAgJ29wdF9vdXRfcGVyc2lzdGVuY2VfYnlfZGVmYXVsdCc6ICAgIGZhbHNlLFxuICAgICdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnOiAnbG9jYWxTdG9yYWdlJyxcbiAgICAnb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4JzogICAgbnVsbCxcbiAgICAncHJvcGVydHlfYmxhY2tsaXN0JzogICAgICAgICAgICAgICAgW10sXG4gICAgJ3hocl9oZWFkZXJzJzogICAgICAgICAgICAgICAgICAgICAgIHt9LCAvLyB7IGhlYWRlcjogdmFsdWUsIGhlYWRlcjI6IHZhbHVlIH1cbiAgICAnaWdub3JlX2RudCc6ICAgICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ2JhdGNoX3JlcXVlc3RzJzogICAgICAgICAgICAgICAgICAgIHRydWUsXG4gICAgJ2JhdGNoX3NpemUnOiAgICAgICAgICAgICAgICAgICAgICAgIDUwLFxuICAgICdiYXRjaF9mbHVzaF9pbnRlcnZhbF9tcyc6ICAgICAgICAgICA1MDAwLFxuICAgICdiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXMnOiAgICAgICAgICA5MDAwMCxcbiAgICAnYmF0Y2hfYXV0b3N0YXJ0JzogICAgICAgICAgICAgICAgICAgdHJ1ZSxcbiAgICAnaG9va3MnOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAge30sXG4gICAgJ3JlY29yZF9ibG9ja19jbGFzcyc6ICAgICAgICAgICAgICAgIG5ldyBSZWdFeHAoJ14obXAtYmxvY2t8ZnMtZXhjbHVkZXxhbXAtYmxvY2t8cnItYmxvY2t8cGgtbm8tY2FwdHVyZSkkJyksXG4gICAgJ3JlY29yZF9ibG9ja19zZWxlY3Rvcic6ICAgICAgICAgICAgICdpbWcsIHZpZGVvJyxcbiAgICAncmVjb3JkX2NhbnZhcyc6ICAgICAgICAgICAgICAgICAgICAgZmFsc2UsXG4gICAgJ3JlY29yZF9jb2xsZWN0X2ZvbnRzJzogICAgICAgICAgICAgIGZhbHNlLFxuICAgICdyZWNvcmRfaWRsZV90aW1lb3V0X21zJzogICAgICAgICAgICAzMCAqIDYwICogMTAwMCwgLy8gMzAgbWludXRlc1xuICAgICdyZWNvcmRfbWFza190ZXh0X2NsYXNzJzogICAgICAgICAgICBuZXcgUmVnRXhwKCdeKG1wLW1hc2t8ZnMtbWFza3xhbXAtbWFza3xyci1tYXNrfHBoLW1hc2spJCcpLFxuICAgICdyZWNvcmRfbWFza190ZXh0X3NlbGVjdG9yJzogICAgICAgICAnKicsXG4gICAgJ3JlY29yZF9tYXhfbXMnOiAgICAgICAgICAgICAgICAgICAgIE1BWF9SRUNPUkRJTkdfTVMsXG4gICAgJ3JlY29yZF9taW5fbXMnOiAgICAgICAgICAgICAgICAgICAgIDAsXG4gICAgJ3JlY29yZF9zZXNzaW9uc19wZXJjZW50JzogICAgICAgICAgIDAsXG4gICAgJ3JlY29yZGVyX3NyYyc6ICAgICAgICAgICAgICAgICAgICAgICdodHRwczovL2Nkbi5teHBubC5jb20vbGlicy9taXhwYW5lbC1yZWNvcmRlci5taW4uanMnXG59O1xuXG52YXIgRE9NX0xPQURFRCA9IGZhbHNlO1xuXG4vKipcbiAqIE1peHBhbmVsIExpYnJhcnkgT2JqZWN0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1peHBhbmVsTGliID0gZnVuY3Rpb24oKSB7fTtcblxuXG4vKipcbiAqIGNyZWF0ZV9tcGxpYih0b2tlbjpzdHJpbmcsIGNvbmZpZzpvYmplY3QsIG5hbWU6c3RyaW5nKVxuICpcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBieSB0aGUgaW5pdCBtZXRob2Qgb2YgTWl4cGFuZWxMaWIgb2JqZWN0c1xuICogYXMgd2VsbCBhcyB0aGUgbWFpbiBpbml0aWFsaXplciBhdCB0aGUgZW5kIG9mIHRoZSBKU0xpYiAodGhhdFxuICogaW5pdGlhbGl6ZXMgZG9jdW1lbnQubWl4cGFuZWwgYXMgd2VsbCBhcyBhbnkgYWRkaXRpb25hbCBpbnN0YW5jZXNcbiAqIGRlY2xhcmVkIGJlZm9yZSB0aGlzIGZpbGUgaGFzIGxvYWRlZCkuXG4gKi9cbnZhciBjcmVhdGVfbXBsaWIgPSBmdW5jdGlvbih0b2tlbiwgY29uZmlnLCBuYW1lKSB7XG4gICAgdmFyIGluc3RhbmNlLFxuICAgICAgICB0YXJnZXQgPSAobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSA/IG1peHBhbmVsX21hc3RlciA6IG1peHBhbmVsX21hc3RlcltuYW1lXTtcblxuICAgIGlmICh0YXJnZXQgJiYgaW5pdF90eXBlID09PSBJTklUX01PRFVMRSkge1xuICAgICAgICBpbnN0YW5jZSA9IHRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGFyZ2V0ICYmICFfLmlzQXJyYXkodGFyZ2V0KSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmVycm9yKCdZb3UgaGF2ZSBhbHJlYWR5IGluaXRpYWxpemVkICcgKyBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZSA9IG5ldyBNaXhwYW5lbExpYigpO1xuICAgIH1cblxuICAgIGluc3RhbmNlLl9jYWNoZWRfZ3JvdXBzID0ge307IC8vIGNhY2hlIGdyb3VwcyBpbiBhIHBvb2xcblxuICAgIGluc3RhbmNlLl9pbml0KHRva2VuLCBjb25maWcsIG5hbWUpO1xuXG4gICAgaW5zdGFuY2VbJ3Blb3BsZSddID0gbmV3IE1peHBhbmVsUGVvcGxlKCk7XG4gICAgaW5zdGFuY2VbJ3Blb3BsZSddLl9pbml0KGluc3RhbmNlKTtcblxuICAgIGlmICghaW5zdGFuY2UuZ2V0X2NvbmZpZygnc2tpcF9maXJzdF90b3VjaF9tYXJrZXRpbmcnKSkge1xuICAgICAgICAvLyBXZSBuZWVkIG51bGwgVVRNIHBhcmFtcyBpbiB0aGUgb2JqZWN0IGJlY2F1c2VcbiAgICAgICAgLy8gVVRNIHBhcmFtZXRlcnMgYWN0IGFzIGEgdHVwbGUuIElmIGFueSBVVE0gcGFyYW1cbiAgICAgICAgLy8gaXMgcHJlc2VudCwgdGhlbiB3ZSBzZXQgYWxsIFVUTSBwYXJhbXMgaW5jbHVkaW5nXG4gICAgICAgIC8vIGVtcHR5IG9uZXMgdG9nZXRoZXJcbiAgICAgICAgdmFyIHV0bV9wYXJhbXMgPSBfLmluZm8uY2FtcGFpZ25QYXJhbXMobnVsbCk7XG4gICAgICAgIHZhciBpbml0aWFsX3V0bV9wYXJhbXMgPSB7fTtcbiAgICAgICAgdmFyIGhhc191dG0gPSBmYWxzZTtcbiAgICAgICAgXy5lYWNoKHV0bV9wYXJhbXMsIGZ1bmN0aW9uKHV0bV92YWx1ZSwgdXRtX2tleSkge1xuICAgICAgICAgICAgaW5pdGlhbF91dG1fcGFyYW1zWydpbml0aWFsXycgKyB1dG1fa2V5XSA9IHV0bV92YWx1ZTtcbiAgICAgICAgICAgIGlmICh1dG1fdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBoYXNfdXRtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNfdXRtKSB7XG4gICAgICAgICAgICBpbnN0YW5jZVsncGVvcGxlJ10uc2V0X29uY2UoaW5pdGlhbF91dG1fcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlmIGFueSBpbnN0YW5jZSBvbiB0aGUgcGFnZSBoYXMgZGVidWcgPSB0cnVlLCB3ZSBzZXQgdGhlXG4gICAgLy8gZ2xvYmFsIGRlYnVnIHRvIGJlIHRydWVcbiAgICBDb25maWcuREVCVUcgPSBDb25maWcuREVCVUcgfHwgaW5zdGFuY2UuZ2V0X2NvbmZpZygnZGVidWcnKTtcblxuICAgIC8vIGlmIHRhcmdldCBpcyBub3QgZGVmaW5lZCwgd2UgY2FsbGVkIGluaXQgYWZ0ZXIgdGhlIGxpYiBhbHJlYWR5XG4gICAgLy8gbG9hZGVkLCBzbyB0aGVyZSB3b24ndCBiZSBhbiBhcnJheSBvZiB0aGluZ3MgdG8gZXhlY3V0ZVxuICAgIGlmICghXy5pc1VuZGVmaW5lZCh0YXJnZXQpICYmIF8uaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgICAgIC8vIENydW5jaCB0aHJvdWdoIHRoZSBwZW9wbGUgcXVldWUgZmlyc3QgLSB3ZSBxdWV1ZSB0aGlzIGRhdGEgdXAgJlxuICAgICAgICAvLyBmbHVzaCBvbiBpZGVudGlmeSwgc28gaXQncyBiZXR0ZXIgdG8gZG8gYWxsIHRoZXNlIG9wZXJhdGlvbnMgZmlyc3RcbiAgICAgICAgaW5zdGFuY2UuX2V4ZWN1dGVfYXJyYXkuY2FsbChpbnN0YW5jZVsncGVvcGxlJ10sIHRhcmdldFsncGVvcGxlJ10pO1xuICAgICAgICBpbnN0YW5jZS5fZXhlY3V0ZV9hcnJheSh0YXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vIEluaXRpYWxpemF0aW9uIG1ldGhvZHNcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBNaXhwYW5lbCB0cmFja2luZyBvYmplY3QuXG4gKiBBbGwgbmV3IGluc3RhbmNlcyBhcmUgYWRkZWQgdG8gdGhlIG1haW4gbWl4cGFuZWwgb2JqZWN0IGFzIHN1YiBwcm9wZXJ0aWVzIChzdWNoIGFzXG4gKiBtaXhwYW5lbC5saWJyYXJ5X25hbWUpIGFuZCBhbHNvIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24uIFRvIGRlZmluZSBhXG4gKiBzZWNvbmQgaW5zdGFuY2Ugb24gdGhlIHBhZ2UsIHlvdSB3b3VsZCBjYWxsOlxuICpcbiAqICAgICBtaXhwYW5lbC5pbml0KCduZXcgdG9rZW4nLCB7IHlvdXI6ICdjb25maWcnIH0sICdsaWJyYXJ5X25hbWUnKTtcbiAqXG4gKiBhbmQgdXNlIGl0IGxpa2Ugc286XG4gKlxuICogICAgIG1peHBhbmVsLmxpYnJhcnlfbmFtZS50cmFjayguLi4pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbiAgIFlvdXIgTWl4cGFuZWwgQVBJIHRva2VuXG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ10gIEEgZGljdGlvbmFyeSBvZiBjb25maWcgb3B0aW9ucyB0byBvdmVycmlkZS4gPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9taXhwYW5lbC9taXhwYW5lbC1qcy9ibG9iL3YyLjQ2LjAvc3JjL21peHBhbmVsLWNvcmUuanMjTDg4LUwxMjdcIj5TZWUgYSBsaXN0IG9mIGRlZmF1bHQgY29uZmlnIG9wdGlvbnM8L2E+LlxuICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lXSAgICBUaGUgbmFtZSBmb3IgdGhlIG5ldyBtaXhwYW5lbCBpbnN0YW5jZSB0aGF0IHlvdSB3YW50IGNyZWF0ZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAodG9rZW4sIGNvbmZpZywgbmFtZSkge1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgbXVzdCBuYW1lIHlvdXIgbmV3IGxpYnJhcnk6IGluaXQodG9rZW4sIGNvbmZpZywgbmFtZSknKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdZb3UgbXVzdCBpbml0aWFsaXplIHRoZSBtYWluIG1peHBhbmVsIG9iamVjdCByaWdodCBhZnRlciB5b3UgaW5jbHVkZSB0aGUgTWl4cGFuZWwganMgc25pcHBldCcpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlX21wbGliKHRva2VuLCBjb25maWcsIG5hbWUpO1xuICAgIG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlO1xuICAgIGluc3RhbmNlLl9sb2FkZWQoKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbn07XG5cbi8vIG1peHBhbmVsLl9pbml0KHRva2VuOnN0cmluZywgY29uZmlnOm9iamVjdCwgbmFtZTpzdHJpbmcpXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBzZXRzIHVwIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBtaXhwYW5lbFxuLy8gbGlicmFyeS4gIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhpcyBtZXRob2QgYW5kIHRoZSBpbml0KC4uLilcbi8vIG1ldGhvZCBpcyB0aGlzIG9uZSBpbml0aWFsaXplcyB0aGUgYWN0dWFsIGluc3RhbmNlLCB3aGVyZWFzIHRoZVxuLy8gaW5pdCguLi4pIG1ldGhvZCBzZXRzIHVwIGEgbmV3IGxpYnJhcnkgYW5kIGNhbGxzIF9pbml0IG9uIGl0LlxuLy9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG5cbiAgICB0aGlzWydfX2xvYWRlZCddID0gdHJ1ZTtcbiAgICB0aGlzWydjb25maWcnXSA9IHt9O1xuXG4gICAgdmFyIHZhcmlhYmxlX2ZlYXR1cmVzID0ge307XG5cbiAgICAvLyBkZWZhdWx0IHRvIEpTT04gcGF5bG9hZCBmb3Igc3RhbmRhcmQgbWl4cGFuZWwuY29tIEFQSSBob3N0c1xuICAgIGlmICghKCdhcGlfcGF5bG9hZF9mb3JtYXQnIGluIGNvbmZpZykpIHtcbiAgICAgICAgdmFyIGFwaV9ob3N0ID0gY29uZmlnWydhcGlfaG9zdCddIHx8IERFRkFVTFRfQ09ORklHWydhcGlfaG9zdCddO1xuICAgICAgICBpZiAoYXBpX2hvc3QubWF0Y2goL1xcLm1peHBhbmVsXFwuY29tLykpIHtcbiAgICAgICAgICAgIHZhcmlhYmxlX2ZlYXR1cmVzWydhcGlfcGF5bG9hZF9mb3JtYXQnXSA9IFBBWUxPQURfVFlQRV9KU09OO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRfY29uZmlnKF8uZXh0ZW5kKHt9LCBERUZBVUxUX0NPTkZJRywgdmFyaWFibGVfZmVhdHVyZXMsIGNvbmZpZywge1xuICAgICAgICAnbmFtZSc6IG5hbWUsXG4gICAgICAgICd0b2tlbic6IHRva2VuLFxuICAgICAgICAnY2FsbGJhY2tfZm4nOiAoKG5hbWUgPT09IFBSSU1BUllfSU5TVEFOQ0VfTkFNRSkgPyBuYW1lIDogUFJJTUFSWV9JTlNUQU5DRV9OQU1FICsgJy4nICsgbmFtZSkgKyAnLl9qc2MnXG4gICAgfSkpO1xuXG4gICAgdGhpc1snX2pzYyddID0gTk9PUF9GVU5DO1xuXG4gICAgdGhpcy5fX2RvbV9sb2FkZWRfcXVldWUgPSBbXTtcbiAgICB0aGlzLl9fcmVxdWVzdF9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX19kaXNhYmxlZF9ldmVudHMgPSBbXTtcbiAgICB0aGlzLl9mbGFncyA9IHtcbiAgICAgICAgJ2Rpc2FibGVfYWxsX2V2ZW50cyc6IGZhbHNlLFxuICAgICAgICAnaWRlbnRpZnlfY2FsbGVkJzogZmFsc2VcbiAgICB9O1xuXG4gICAgLy8gc2V0IHVwIHJlcXVlc3QgcXVldWVpbmcvYmF0Y2hpbmdcbiAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMgPSB7fTtcbiAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IHRoaXMuZ2V0X2NvbmZpZygnYmF0Y2hfcmVxdWVzdHMnKTtcbiAgICBpZiAodGhpcy5fYmF0Y2hfcmVxdWVzdHMpIHtcbiAgICAgICAgaWYgKCFfLmxvY2FsU3RvcmFnZS5pc19zdXBwb3J0ZWQodHJ1ZSkgfHwgIVVTRV9YSFIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhdGNoX3JlcXVlc3RzID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zb2xlJDEubG9nKCdUdXJuaW5nIG9mZiBNaXhwYW5lbCByZXF1ZXN0LXF1ZXVlaW5nOyBuZWVkcyBYSFIgYW5kIGxvY2FsU3RvcmFnZSBzdXBwb3J0Jyk7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5nZXRfYmF0Y2hlcl9jb25maWdzKCksIGZ1bmN0aW9uKGJhdGNoZXJfY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZSQxLmxvZygnQ2xlYXJpbmcgYmF0Y2ggcXVldWUgJyArIGJhdGNoZXJfY29uZmlnLnF1ZXVlX2tleSk7XG4gICAgICAgICAgICAgICAgXy5sb2NhbFN0b3JhZ2UucmVtb3ZlKGJhdGNoZXJfY29uZmlnLnF1ZXVlX2tleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdF9iYXRjaGVycygpO1xuICAgICAgICAgICAgaWYgKHNlbmRCZWFjb24gJiYgd2luLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBCZWZvcmUgcGFnZSBjbG9zZXMgb3IgaGlkZXMgKHVzZXIgdGFicyBhd2F5IGV0YyksIGF0dGVtcHQgdG8gZmx1c2ggYW55IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIHF1ZXVlZCB1cCB2aWEgbmF2aWdhdG9yLnNlbmRCZWFjb24uIFNpbmNlIHNlbmRCZWFjb24gZG9lc24ndCByZXBvcnQgc3VjY2Vzcy9mYWlsdXJlLFxuICAgICAgICAgICAgICAgIC8vIGV2ZW50cyB3aWxsIG5vdCBiZSByZW1vdmVkIGZyb20gdGhlIHBlcnNpc3RlbnQgc3RvcmU7IGlmIHRoZSBzaXRlIGlzIGxvYWRlZCBhZ2FpbixcbiAgICAgICAgICAgICAgICAvLyB0aGUgZXZlbnRzIHdpbGwgYmUgZmx1c2hlZCBhZ2FpbiBvbiBzdGFydHVwIGFuZCBkZWR1cGxpY2F0ZWQgb24gdGhlIE1peHBhbmVsIHNlcnZlclxuICAgICAgICAgICAgICAgIC8vIHNpZGUuXG4gICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gcmVsaWFibGUgd2F5IHRvIGNhcHR1cmUgb25seSBwYWdlIGNsb3NlIGV2ZW50cywgc28gd2UgbGVhbiBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyB2aXNpYmlsaXR5Y2hhbmdlIGFuZCBwYWdlaGlkZSBldmVudHMgYXMgcmVjb21tZW5kZWQgYXRcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L3VubG9hZF9ldmVudCN1c2FnZV9ub3Rlcy5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBldmVudHMgZmlyZSB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhd2F5IGZyb20gdGhlIGN1cnJlbnQgcGFnZS90YWIsIHNvIHdpbGwgb2NjdXJcbiAgICAgICAgICAgICAgICAvLyBtb3JlIGZyZXF1ZW50bHkgdGhhbiBwYWdlIHVubG9hZCwgYnV0IGFyZSB0aGUgb25seSBtZWNoYW5pc20gY3VycmVudGx5IGZvciBjYXB0dXJpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHNjZW5hcmlvIHNvbWV3aGF0IHJlbGlhYmx5LlxuICAgICAgICAgICAgICAgIHZhciBmbHVzaF9vbl91bmxvYWQgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXF1ZXN0X2JhdGNoZXJzLmV2ZW50cy5zdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLmZsdXNoKHt1bmxvYWRpbmc6IHRydWV9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldlsncGVyc2lzdGVkJ10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZsdXNoX29uX3VubG9hZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50JDFbJ3Zpc2liaWxpdHlTdGF0ZSddID09PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hfb25fdW5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10gPSB0aGlzWydjb29raWUnXSA9IG5ldyBNaXhwYW5lbFBlcnNpc3RlbmNlKHRoaXNbJ2NvbmZpZyddKTtcbiAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMgPSB7fTtcbiAgICB0aGlzLl9nZHByX2luaXQoKTtcblxuICAgIHZhciB1dWlkID0gXy5VVUlEKCk7XG4gICAgaWYgKCF0aGlzLmdldF9kaXN0aW5jdF9pZCgpKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IHRoZSBkaXN0aW5jdCBpZFxuICAgICAgICAvLyBvciB0aGUgZGV2aWNlIGlkIGlmIHNvbWV0aGluZyB3YXMgYWxyZWFkeSBzdG9yZWRcbiAgICAgICAgLy8gaW4gdGhlIHBlcnNpdGVuY2VcbiAgICAgICAgdGhpcy5yZWdpc3Rlcl9vbmNlKHtcbiAgICAgICAgICAgICdkaXN0aW5jdF9pZCc6IERFVklDRV9JRF9QUkVGSVggKyB1dWlkLFxuICAgICAgICAgICAgJyRkZXZpY2VfaWQnOiB1dWlkXG4gICAgICAgIH0sICcnKTtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2tfcGFnZXZpZXdfb3B0aW9uID0gdGhpcy5nZXRfY29uZmlnKCd0cmFja19wYWdldmlldycpO1xuICAgIGlmICh0cmFja19wYWdldmlld19vcHRpb24pIHtcbiAgICAgICAgdGhpcy5faW5pdF91cmxfY2hhbmdlX3RyYWNraW5nKHRyYWNrX3BhZ2V2aWV3X29wdGlvbik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygncmVjb3JkX3Nlc3Npb25zX3BlcmNlbnQnKSA+IDAgJiYgTWF0aC5yYW5kb20oKSAqIDEwMCA8PSB0aGlzLmdldF9jb25maWcoJ3JlY29yZF9zZXNzaW9uc19wZXJjZW50JykpIHtcbiAgICAgICAgdGhpcy5zdGFydF9zZXNzaW9uX3JlY29yZGluZygpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9zZXNzaW9uX3JlY29yZGluZyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24gKCkge1xuICAgIGlmICghd2luWydNdXRhdGlvbk9ic2VydmVyJ10pIHtcbiAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgTXV0YXRpb25PYnNlcnZlcjsgc2tpcHBpbmcgc2Vzc2lvbiByZWNvcmRpbmcnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBoYW5kbGVMb2FkZWRSZWNvcmRlciA9IF8uYmluZChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fcmVjb3JkZXIgPSB0aGlzLl9yZWNvcmRlciB8fCBuZXcgd2luWydfX21wX3JlY29yZGVyJ10odGhpcyk7XG4gICAgICAgIHRoaXMuX3JlY29yZGVyWydzdGFydFJlY29yZGluZyddKCk7XG4gICAgfSwgdGhpcyk7XG5cbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh3aW5bJ19fbXBfcmVjb3JkZXInXSkpIHtcbiAgICAgICAgbG9hZF9leHRyYV9idW5kbGUodGhpcy5nZXRfY29uZmlnKCdyZWNvcmRlcl9zcmMnKSwgaGFuZGxlTG9hZGVkUmVjb3JkZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbmRsZUxvYWRlZFJlY29yZGVyKCk7XG4gICAgfVxufSk7XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX3Nlc3Npb25fcmVjb3JkaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWNvcmRlcikge1xuICAgICAgICB0aGlzLl9yZWNvcmRlclsnc3RvcFJlY29yZGluZyddKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZSQxLmNyaXRpY2FsKCdTZXNzaW9uIHJlY29yZGVyIG1vZHVsZSBub3QgbG9hZGVkJyk7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciByZXBsYXlfaWQgPSB0aGlzLl9nZXRfc2Vzc2lvbl9yZXBsYXlfaWQoKTtcbiAgICBpZiAocmVwbGF5X2lkKSB7XG4gICAgICAgIHByb3BzWyckbXBfcmVwbGF5X2lkJ10gPSByZXBsYXlfaWQ7XG4gICAgfVxuICAgIHJldHVybiBwcm9wcztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZXBsYXlfdXJsID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXBsYXlfdXJsID0gbnVsbDtcbiAgICB2YXIgcmVwbGF5X2lkID0gdGhpcy5fZ2V0X3Nlc3Npb25fcmVwbGF5X2lkKCk7XG4gICAgaWYgKHJlcGxheV9pZCkge1xuICAgICAgICB2YXIgcXVlcnlfcGFyYW1zID0gXy5IVFRQQnVpbGRRdWVyeSh7XG4gICAgICAgICAgICAncmVwbGF5X2lkJzogcmVwbGF5X2lkLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogdGhpcy5nZXRfZGlzdGluY3RfaWQoKSxcbiAgICAgICAgICAgICd0b2tlbic6IHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKVxuICAgICAgICB9KTtcbiAgICAgICAgcmVwbGF5X3VybCA9ICdodHRwczovL21peHBhbmVsLmNvbS9wcm9qZWN0cy9yZXBsYXktcmVkaXJlY3Q/JyArIHF1ZXJ5X3BhcmFtcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcGxheV91cmw7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dldF9zZXNzaW9uX3JlcGxheV9pZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVwbGF5X2lkID0gbnVsbDtcbiAgICBpZiAodGhpcy5fcmVjb3JkZXIpIHtcbiAgICAgICAgcmVwbGF5X2lkID0gdGhpcy5fcmVjb3JkZXJbJ3JlcGxheUlkJ107XG4gICAgfVxuICAgIHJldHVybiByZXBsYXlfaWQgfHwgbnVsbDtcbn07XG5cbi8vIFByaXZhdGUgbWV0aG9kc1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2xvYWRlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZ2V0X2NvbmZpZygnbG9hZGVkJykodGhpcyk7XG4gICAgdGhpcy5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcygpO1xuICAgIHRoaXNbJ3Blb3BsZSddLnNldF9vbmNlKHRoaXNbJ3BlcnNpc3RlbmNlJ10uZ2V0X3JlZmVycmVyX2luZm8oKSk7XG5cbiAgICAvLyBgc3RvcmVfZ29vZ2xlYCBpcyBub3cgZGVwcmVjYXRlZCBhbmQgcHJldmlvdXNseSBzdG9yZWQgVVRNIHBhcmFtZXRlcnMgYXJlIGNsZWFyZWRcbiAgICAvLyBmcm9tIHBlcnNpc3RlbmNlIGJ5IGRlZmF1bHQuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc3RvcmVfZ29vZ2xlJykgJiYgdGhpcy5nZXRfY29uZmlnKCdzdG9wX3V0bV9wZXJzaXN0ZW5jZScpKSB7XG4gICAgICAgIHZhciB1dG1fcGFyYW1zID0gXy5pbmZvLmNhbXBhaWduUGFyYW1zKG51bGwpO1xuICAgICAgICBfLmVhY2godXRtX3BhcmFtcywgZnVuY3Rpb24oX3V0bV92YWx1ZSwgdXRtX2tleSkge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1bnJlZ2lzdGVyIHBlcnNpc3RlZCBVVE0gcGFyYW1ldGVycyBzbyBvbGQgdmFsdWVzXG4gICAgICAgICAgICAvLyBhcmUgbm90IG1peGVkIHdpdGggdGhlIG5ldyBVVE0gcGFyYW1ldGVyc1xuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKHV0bV9rZXkpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cbn07XG5cbi8vIHVwZGF0ZSBwZXJzaXN0ZW5jZSB3aXRoIGluZm8gb24gcmVmZXJyZXIsIFVUTSBwYXJhbXMsIGV0Y1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9zZXRfZGVmYXVsdF9zdXBlcnByb3BzID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpc1sncGVyc2lzdGVuY2UnXS51cGRhdGVfc2VhcmNoX2tleXdvcmQoZG9jdW1lbnQkMS5yZWZlcnJlcik7XG4gICAgLy8gUmVnaXN0ZXJpbmcgc3VwZXIgcHJvcGVydGllcyBmb3IgVVRNIHBlcnNpc3RlbmNlIGJ5ICdzdG9yZV9nb29nbGUnIGlzIGRlcHJlY2F0ZWQuXG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc3RvcmVfZ29vZ2xlJykgJiYgIXRoaXMuZ2V0X2NvbmZpZygnc3RvcF91dG1fcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyKF8uaW5mby5jYW1wYWlnblBhcmFtcygpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnc2F2ZV9yZWZlcnJlcicpKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX3JlZmVycmVyX2luZm8oZG9jdW1lbnQkMS5yZWZlcnJlcik7XG4gICAgfVxufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9kb21fbG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgXy5lYWNoKHRoaXMuX19kb21fbG9hZGVkX3F1ZXVlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrX2RvbS5hcHBseSh0aGlzLCBpdGVtKTtcbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICghdGhpcy5oYXNfb3B0ZWRfb3V0X3RyYWNraW5nKCkpIHtcbiAgICAgICAgXy5lYWNoKHRoaXMuX19yZXF1ZXN0X3F1ZXVlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kX3JlcXVlc3QuYXBwbHkodGhpcywgaXRlbSk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgIH1cblxuICAgIGRlbGV0ZSB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZTtcbiAgICBkZWxldGUgdGhpcy5fX3JlcXVlc3RfcXVldWU7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3RyYWNrX2RvbSA9IGZ1bmN0aW9uKERvbUNsYXNzLCBhcmdzKSB7XG4gICAgaWYgKHRoaXMuZ2V0X2NvbmZpZygnaW1nJykpIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ1lvdSBjYW5cXCd0IHVzZSBET00gdHJhY2tpbmcgZnVuY3Rpb25zIHdpdGggaW1nID0gdHJ1ZS4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghRE9NX0xPQURFRCkge1xuICAgICAgICB0aGlzLl9fZG9tX2xvYWRlZF9xdWV1ZS5wdXNoKFtEb21DbGFzcywgYXJnc10pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGR0ID0gbmV3IERvbUNsYXNzKCkuaW5pdCh0aGlzKTtcbiAgICByZXR1cm4gZHQudHJhY2suYXBwbHkoZHQsIGFyZ3MpO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9pbml0X3VybF9jaGFuZ2VfdHJhY2tpbmcgPSBmdW5jdGlvbih0cmFja19wYWdldmlld19vcHRpb24pIHtcbiAgICB2YXIgcHJldmlvdXNfdHJhY2tlZF91cmwgPSAnJztcbiAgICB2YXIgdHJhY2tlZCA9IHRoaXMudHJhY2tfcGFnZXZpZXcoKTtcbiAgICBpZiAodHJhY2tlZCkge1xuICAgICAgICBwcmV2aW91c190cmFja2VkX3VybCA9IF8uaW5mby5jdXJyZW50VXJsKCk7XG4gICAgfVxuXG4gICAgaWYgKF8uaW5jbHVkZShbJ2Z1bGwtdXJsJywgJ3VybC13aXRoLXBhdGgtYW5kLXF1ZXJ5LXN0cmluZycsICd1cmwtd2l0aC1wYXRoJ10sIHRyYWNrX3BhZ2V2aWV3X29wdGlvbikpIHtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ3BvcHN0YXRlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB3aW4uZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ21wX2xvY2F0aW9uY2hhbmdlJykpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luLmFkZEV2ZW50TGlzdGVuZXIoJ2hhc2hjaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbXBfbG9jYXRpb25jaGFuZ2UnKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbmF0aXZlUHVzaFN0YXRlID0gd2luLmhpc3RvcnkucHVzaFN0YXRlO1xuICAgICAgICBpZiAodHlwZW9mIG5hdGl2ZVB1c2hTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgd2luLmhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHVudXNlZCwgdXJsKSB7XG4gICAgICAgICAgICAgICAgbmF0aXZlUHVzaFN0YXRlLmNhbGwod2luLmhpc3RvcnksIHN0YXRlLCB1bnVzZWQsIHVybCk7XG4gICAgICAgICAgICAgICAgd2luLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdtcF9sb2NhdGlvbmNoYW5nZScpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hdGl2ZVJlcGxhY2VTdGF0ZSA9IHdpbi5oaXN0b3J5LnJlcGxhY2VTdGF0ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYXRpdmVSZXBsYWNlU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHdpbi5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCB1bnVzZWQsIHVybCkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZVJlcGxhY2VTdGF0ZS5jYWxsKHdpbi5oaXN0b3J5LCBzdGF0ZSwgdW51c2VkLCB1cmwpO1xuICAgICAgICAgICAgICAgIHdpbi5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbXBfbG9jYXRpb25jaGFuZ2UnKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHdpbi5hZGRFdmVudExpc3RlbmVyKCdtcF9sb2NhdGlvbmNoYW5nZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRfdXJsID0gXy5pbmZvLmN1cnJlbnRVcmwoKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRfdHJhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh0cmFja19wYWdldmlld19vcHRpb24gPT09ICdmdWxsLXVybCcpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRfdHJhY2sgPSBjdXJyZW50X3VybCAhPT0gcHJldmlvdXNfdHJhY2tlZF91cmw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrX3BhZ2V2aWV3X29wdGlvbiA9PT0gJ3VybC13aXRoLXBhdGgtYW5kLXF1ZXJ5LXN0cmluZycpIHtcbiAgICAgICAgICAgICAgICBzaG91bGRfdHJhY2sgPSBjdXJyZW50X3VybC5zcGxpdCgnIycpWzBdICE9PSBwcmV2aW91c190cmFja2VkX3VybC5zcGxpdCgnIycpWzBdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0cmFja19wYWdldmlld19vcHRpb24gPT09ICd1cmwtd2l0aC1wYXRoJykge1xuICAgICAgICAgICAgICAgIHNob3VsZF90cmFjayA9IGN1cnJlbnRfdXJsLnNwbGl0KCcjJylbMF0uc3BsaXQoJz8nKVswXSAhPT0gcHJldmlvdXNfdHJhY2tlZF91cmwuc3BsaXQoJyMnKVswXS5zcGxpdCgnPycpWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvdWxkX3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWNrZWQgPSB0aGlzLnRyYWNrX3BhZ2V2aWV3KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNfdHJhY2tlZF91cmwgPSBjdXJyZW50X3VybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBfcHJlcGFyZV9jYWxsYmFjaygpIHNob3VsZCBiZSBjYWxsZWQgYnkgY2FsbGVycyBvZiBfc2VuZF9yZXF1ZXN0IGZvciB1c2VcbiAqIGFzIHRoZSBjYWxsYmFjayBhcmd1bWVudC5cbiAqXG4gKiBJZiB0aGVyZSBpcyBubyBjYWxsYmFjaywgdGhpcyByZXR1cm5zIG51bGwuXG4gKiBJZiB3ZSBhcmUgZ29pbmcgdG8gbWFrZSBYSFIvWERSIHJlcXVlc3RzLCB0aGlzIHJldHVybnMgYSBmdW5jdGlvbi5cbiAqIElmIHdlIGFyZSBnb2luZyB0byB1c2Ugc2NyaXB0IHRhZ3MsIHRoaXMgcmV0dXJucyBhIHN0cmluZyB0byB1c2UgYXMgdGhlXG4gKiBjYWxsYmFjayBHRVQgcGFyYW0uXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcHJlcGFyZV9jYWxsYmFjayA9IGZ1bmN0aW9uKGNhbGxiYWNrLCBkYXRhKSB7XG4gICAgaWYgKF8uaXNVbmRlZmluZWQoY2FsbGJhY2spKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChVU0VfWEhSKSB7XG4gICAgICAgIHZhciBjYWxsYmFja19mdW5jdGlvbiA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSwgZGF0YSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjYWxsYmFja19mdW5jdGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiB0aGUgdXNlciBnaXZlcyB1cyBhIGNhbGxiYWNrLCB3ZSBzdG9yZSBhcyBhIHJhbmRvbVxuICAgICAgICAvLyBwcm9wZXJ0eSBvbiB0aGlzIGluc3RhbmNlcyBqc2MgZnVuY3Rpb24gYW5kIHVwZGF0ZSBvdXJcbiAgICAgICAgLy8gY2FsbGJhY2sgc3RyaW5nIHRvIHJlZmxlY3QgdGhhdC5cbiAgICAgICAgdmFyIGpzYyA9IHRoaXNbJ19qc2MnXTtcbiAgICAgICAgdmFyIHJhbmRvbWl6ZWRfY2IgPSAnJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDAwMCk7XG4gICAgICAgIHZhciBjYWxsYmFja19zdHJpbmcgPSB0aGlzLmdldF9jb25maWcoJ2NhbGxiYWNrX2ZuJykgKyAnWycgKyByYW5kb21pemVkX2NiICsgJ10nO1xuICAgICAgICBqc2NbcmFuZG9taXplZF9jYl0gPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgZGVsZXRlIGpzY1tyYW5kb21pemVkX2NiXTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlLCBkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrX3N0cmluZztcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3NlbmRfcmVxdWVzdCA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgc3VjY2VlZGVkID0gdHJ1ZTtcblxuICAgIGlmIChFTlFVRVVFX1JFUVVFU1RTKSB7XG4gICAgICAgIHRoaXMuX19yZXF1ZXN0X3F1ZXVlLnB1c2goYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHN1Y2NlZWRlZDtcbiAgICB9XG5cbiAgICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICAgICAgICBtZXRob2Q6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX21ldGhvZCcpLFxuICAgICAgICB0cmFuc3BvcnQ6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX3RyYW5zcG9ydCcpLFxuICAgICAgICB2ZXJib3NlOiB0aGlzLmdldF9jb25maWcoJ3ZlcmJvc2UnKVxuICAgIH07XG4gICAgdmFyIGJvZHlfZGF0YSA9IG51bGw7XG5cbiAgICBpZiAoIWNhbGxiYWNrICYmIChfLmlzRnVuY3Rpb24ob3B0aW9ucykgfHwgdHlwZW9mIG9wdGlvbnMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cbiAgICBvcHRpb25zID0gXy5leHRlbmQoREVGQVVMVF9PUFRJT05TLCBvcHRpb25zIHx8IHt9KTtcbiAgICBpZiAoIVVTRV9YSFIpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSAnR0VUJztcbiAgICB9XG4gICAgdmFyIHVzZV9wb3N0ID0gb3B0aW9ucy5tZXRob2QgPT09ICdQT1NUJztcbiAgICB2YXIgdXNlX3NlbmRCZWFjb24gPSBzZW5kQmVhY29uICYmIHVzZV9wb3N0ICYmIG9wdGlvbnMudHJhbnNwb3J0LnRvTG93ZXJDYXNlKCkgPT09ICdzZW5kYmVhY29uJztcblxuICAgIC8vIG5lZWRlZCB0byBjb3JyZWN0bHkgZm9ybWF0IHJlc3BvbnNlc1xuICAgIHZhciB2ZXJib3NlX21vZGUgPSBvcHRpb25zLnZlcmJvc2U7XG4gICAgaWYgKGRhdGFbJ3ZlcmJvc2UnXSkgeyB2ZXJib3NlX21vZGUgPSB0cnVlOyB9XG5cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCd0ZXN0JykpIHsgZGF0YVsndGVzdCddID0gMTsgfVxuICAgIGlmICh2ZXJib3NlX21vZGUpIHsgZGF0YVsndmVyYm9zZSddID0gMTsgfVxuICAgIGlmICh0aGlzLmdldF9jb25maWcoJ2ltZycpKSB7IGRhdGFbJ2ltZyddID0gMTsgfVxuICAgIGlmICghVVNFX1hIUikge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGRhdGFbJ2NhbGxiYWNrJ10gPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJib3NlX21vZGUgfHwgdGhpcy5nZXRfY29uZmlnKCd0ZXN0JykpIHtcbiAgICAgICAgICAgIC8vIFZlcmJvc2Ugb3V0cHV0IChmcm9tIHZlcmJvc2UgbW9kZSwgb3IgYW4gZXJyb3IgaW4gdGVzdCBtb2RlKSBpcyBhIGpzb24gYmxvYixcbiAgICAgICAgICAgIC8vIHdoaWNoIGJ5IGl0c2VsZiBpcyBub3QgdmFsaWQgamF2YXNjcmlwdC4gV2l0aG91dCBhIGNhbGxiYWNrLCB0aGlzIHZlcmJvc2Ugb3V0cHV0IHdpbGxcbiAgICAgICAgICAgIC8vIGNhdXNlIGFuIGVycm9yIHdoZW4gcmV0dXJuZWQgdmlhIGpzb25wLCBzbyB3ZSBmb3JjZSBhIG5vLW9wIGNhbGxiYWNrIHBhcmFtLlxuICAgICAgICAgICAgLy8gU2VlIHRoZSBFQ01BIHNjcmlwdCBzcGVjOiBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNS4xLyNzZWMtMTIuNFxuICAgICAgICAgICAgZGF0YVsnY2FsbGJhY2snXSA9ICcoZnVuY3Rpb24oKXt9KSc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkYXRhWydpcCddID0gdGhpcy5nZXRfY29uZmlnKCdpcCcpPzE6MDtcbiAgICBkYXRhWydfJ10gPSBuZXcgRGF0ZSgpLmdldFRpbWUoKS50b1N0cmluZygpO1xuXG4gICAgaWYgKHVzZV9wb3N0KSB7XG4gICAgICAgIGJvZHlfZGF0YSA9ICdkYXRhPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVsnZGF0YSddKTtcbiAgICAgICAgZGVsZXRlIGRhdGFbJ2RhdGEnXTtcbiAgICB9XG5cbiAgICB1cmwgKz0gJz8nICsgXy5IVFRQQnVpbGRRdWVyeShkYXRhKTtcblxuICAgIHZhciBsaWIgPSB0aGlzO1xuICAgIGlmICgnaW1nJyBpbiBkYXRhKSB7XG4gICAgICAgIHZhciBpbWcgPSBkb2N1bWVudCQxLmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgICBkb2N1bWVudCQxLmJvZHkuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9IGVsc2UgaWYgKHVzZV9zZW5kQmVhY29uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdWNjZWVkZWQgPSBzZW5kQmVhY29uKHVybCwgYm9keV9kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhzdWNjZWVkZWQgPyAxIDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxpYi5yZXBvcnRfZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFVTRV9YSFIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJlcS5vcGVuKG9wdGlvbnMubWV0aG9kLCB1cmwsIHRydWUpO1xuXG4gICAgICAgICAgICB2YXIgaGVhZGVycyA9IHRoaXMuZ2V0X2NvbmZpZygneGhyX2hlYWRlcnMnKTtcbiAgICAgICAgICAgIGlmICh1c2VfcG9zdCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfLmVhY2goaGVhZGVycywgZnVuY3Rpb24oaGVhZGVyVmFsdWUsIGhlYWRlck5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXEuc2V0UmVxdWVzdEhlYWRlcihoZWFkZXJOYW1lLCBoZWFkZXJWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dF9tcyAmJiB0eXBlb2YgcmVxLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVxLnRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXRfbXM7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0X3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2VuZCB0aGUgbXBfb3B0b3V0IGNvb2tpZVxuICAgICAgICAgICAgLy8gd2l0aENyZWRlbnRpYWxzIGNhbm5vdCBiZSBtb2RpZmllZCB1bnRpbCBhZnRlciBjYWxsaW5nIC5vcGVuIG9uIEFuZHJvaWQgYW5kIE1vYmlsZSBTYWZhcmlcbiAgICAgICAgICAgIHJlcS53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICAgICAgcmVxLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnJlYWR5U3RhdGUgPT09IDQpIHsgLy8gWE1MSHR0cFJlcXVlc3QuRE9ORSA9PSA0LCBleGNlcHQgaW4gc2FmYXJpIDRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2VfbW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF8uSlNPTkRlY29kZShyZXEucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmlnbm9yZV9qc29uX2Vycm9ycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVxLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhOdW1iZXIocmVxLnJlc3BvbnNlVGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXEudGltZW91dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFyZXEuc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydF90aW1lID49IHJlcS50aW1lb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9ICd0aW1lb3V0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAnQmFkIEhUVFAgc3RhdHVzOiAnICsgcmVxLnN0YXR1cyArICcgJyArIHJlcS5zdGF0dXNUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGliLnJlcG9ydF9lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmVyYm9zZV9tb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZV9oZWFkZXJzID0gcmVxWydyZXNwb25zZUhlYWRlcnMnXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soe3N0YXR1czogMCwgaHR0cFN0YXR1c0NvZGU6IHJlcVsnc3RhdHVzJ10sIGVycm9yOiBlcnJvciwgcmV0cnlBZnRlcjogcmVzcG9uc2VfaGVhZGVyc1snUmV0cnktQWZ0ZXInXX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEuc2VuZChib2R5X2RhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsaWIucmVwb3J0X2Vycm9yKGUpO1xuICAgICAgICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQkMS5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LmRlZmVyID0gdHJ1ZTtcbiAgICAgICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICAgICAgdmFyIHMgPSBkb2N1bWVudCQxLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgICAgICAgcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIHMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdWNjZWVkZWQ7XG59O1xuXG4vKipcbiAqIF9leGVjdXRlX2FycmF5KCkgZGVhbHMgd2l0aCBwcm9jZXNzaW5nIGFueSBtaXhwYW5lbCBmdW5jdGlvblxuICogY2FsbHMgdGhhdCB3ZXJlIGNhbGxlZCBiZWZvcmUgdGhlIE1peHBhbmVsIGxpYnJhcnkgd2VyZSBsb2FkZWRcbiAqIChhbmQgYXJlIHRodXMgc3RvcmVkIGluIGFuIGFycmF5IHNvIHRoZXkgY2FuIGJlIGNhbGxlZCBsYXRlcilcbiAqXG4gKiBOb3RlOiB3ZSBmaXJlIG9mZiBhbGwgdGhlIG1peHBhbmVsIGZ1bmN0aW9uIGNhbGxzICYmIHVzZXIgZGVmaW5lZFxuICogZnVuY3Rpb25zIEJFRk9SRSB3ZSBmaXJlIG9mZiBtaXhwYW5lbCB0cmFja2luZyBjYWxscy4gVGhpcyBpcyBzb1xuICogaWRlbnRpZnkvcmVnaXN0ZXIvc2V0X2NvbmZpZyBjYWxscyBjYW4gcHJvcGVybHkgbW9kaWZ5IGVhcmx5XG4gKiB0cmFja2luZyBjYWxscy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2V4ZWN1dGVfYXJyYXkgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBmbl9uYW1lLCBhbGlhc19jYWxscyA9IFtdLCBvdGhlcl9jYWxscyA9IFtdLCB0cmFja2luZ19jYWxscyA9IFtdO1xuICAgIF8uZWFjaChhcnJheSwgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgZm5fbmFtZSA9IGl0ZW1bMF07XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGZuX25hbWUpKSB7XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdfY2FsbHMucHVzaChpdGVtKTsgLy8gY2hhaW5lZCBjYWxsIGUuZy4gbWl4cGFuZWwuZ2V0X2dyb3VwKCkuc2V0KClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mKGl0ZW0pID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfLmlzQXJyYXkoaXRlbSkgJiYgZm5fbmFtZSA9PT0gJ2FsaWFzJykge1xuICAgICAgICAgICAgICAgIGFsaWFzX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShpdGVtKSAmJiBmbl9uYW1lLmluZGV4T2YoJ3RyYWNrJykgIT09IC0xICYmIHR5cGVvZih0aGlzW2ZuX25hbWVdKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRyYWNraW5nX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG90aGVyX2NhbGxzLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHZhciBleGVjdXRlID0gZnVuY3Rpb24oY2FsbHMsIGNvbnRleHQpIHtcbiAgICAgICAgXy5lYWNoKGNhbGxzLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAoXy5pc0FycmF5KGl0ZW1bMF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gY2hhaW5lZCBjYWxsXG4gICAgICAgICAgICAgICAgdmFyIGNhbGxlciA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgXy5lYWNoKGl0ZW0sIGZ1bmN0aW9uKGNhbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGVyID0gY2FsbGVyW2NhbGxbMF1dLmFwcGx5KGNhbGxlciwgY2FsbC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXNbaXRlbVswXV0uYXBwbHkodGhpcywgaXRlbS5zbGljZSgxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBleGVjdXRlKGFsaWFzX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKG90aGVyX2NhbGxzLCB0aGlzKTtcbiAgICBleGVjdXRlKHRyYWNraW5nX2NhbGxzLCB0aGlzKTtcbn07XG5cbi8vIHJlcXVlc3QgcXVldWVpbmcgdXRpbHNcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMucmVxdWVzdF9iYXRjaGVycy5ldmVudHM7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2JhdGNoZXJfY29uZmlncyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBxdWV1ZV9wcmVmaXggPSAnX19tcHFfJyArIHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKTtcbiAgICB2YXIgYXBpX3JvdXRlcyA9IHRoaXMuZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpO1xuICAgIHRoaXMuX2JhdGNoZXJfY29uZmlncyA9IHRoaXMuX2JhdGNoZXJfY29uZmlncyB8fCB7XG4gICAgICAgIGV2ZW50czoge3R5cGU6ICdldmVudHMnLCBlbmRwb2ludDogJy8nICsgYXBpX3JvdXRlc1sndHJhY2snXSwgcXVldWVfa2V5OiBxdWV1ZV9wcmVmaXggKyAnX2V2J30sXG4gICAgICAgIHBlb3BsZToge3R5cGU6ICdwZW9wbGUnLCBlbmRwb2ludDogJy8nICsgYXBpX3JvdXRlc1snZW5nYWdlJ10sIHF1ZXVlX2tleTogcXVldWVfcHJlZml4ICsgJ19wcCd9LFxuICAgICAgICBncm91cHM6IHt0eXBlOiAnZ3JvdXBzJywgZW5kcG9pbnQ6ICcvJyArIGFwaV9yb3V0ZXNbJ2dyb3VwcyddLCBxdWV1ZV9rZXk6IHF1ZXVlX3ByZWZpeCArICdfZ3InfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuX2JhdGNoZXJfY29uZmlncztcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0X2JhdGNoZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmFyZV9iYXRjaGVyc19pbml0aWFsaXplZCgpKSB7XG4gICAgICAgIHZhciBiYXRjaGVyX2ZvciA9IF8uYmluZChmdW5jdGlvbihhdHRycykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0QmF0Y2hlcihcbiAgICAgICAgICAgICAgICBhdHRycy5xdWV1ZV9rZXksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBsaWJDb25maWc6IHRoaXNbJ2NvbmZpZyddLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclJlcG9ydGVyOiB0aGlzLmdldF9jb25maWcoJ2Vycm9yX3JlcG9ydGVyJyksXG4gICAgICAgICAgICAgICAgICAgIHNlbmRSZXF1ZXN0RnVuYzogXy5iaW5kKGZ1bmN0aW9uKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZW5kX3JlcXVlc3QoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRfY29uZmlnKCdhcGlfaG9zdCcpICsgYXR0cnMuZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QoZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcmVwYXJlX2NhbGxiYWNrKGNiLCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcyksXG4gICAgICAgICAgICAgICAgICAgIGJlZm9yZVNlbmRIb29rOiBfLmJpbmQoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bl9ob29rKCdiZWZvcmVfc2VuZF8nICsgYXR0cnMudHlwZSwgaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICBzdG9wQWxsQmF0Y2hpbmdGdW5jOiBfLmJpbmQodGhpcy5zdG9wX2JhdGNoX3NlbmRlcnMsIHRoaXMpLFxuICAgICAgICAgICAgICAgICAgICB1c2VQZXJzaXN0ZW5jZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB2YXIgYmF0Y2hlcl9jb25maWdzID0gdGhpcy5nZXRfYmF0Y2hlcl9jb25maWdzKCk7XG4gICAgICAgIHRoaXMucmVxdWVzdF9iYXRjaGVycyA9IHtcbiAgICAgICAgICAgIGV2ZW50czogYmF0Y2hlcl9mb3IoYmF0Y2hlcl9jb25maWdzLmV2ZW50cyksXG4gICAgICAgICAgICBwZW9wbGU6IGJhdGNoZXJfZm9yKGJhdGNoZXJfY29uZmlncy5wZW9wbGUpLFxuICAgICAgICAgICAgZ3JvdXBzOiBiYXRjaGVyX2ZvcihiYXRjaGVyX2NvbmZpZ3MuZ3JvdXBzKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdiYXRjaF9hdXRvc3RhcnQnKSkge1xuICAgICAgICB0aGlzLnN0YXJ0X2JhdGNoX3NlbmRlcnMoKTtcbiAgICB9XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuc3RhcnRfYmF0Y2hfc2VuZGVycyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2JhdGNoZXJzX3dlcmVfc3RhcnRlZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuYXJlX2JhdGNoZXJzX2luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgdGhpcy5fYmF0Y2hfcmVxdWVzdHMgPSB0cnVlO1xuICAgICAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgICAgICBiYXRjaGVyLnN0YXJ0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX2JhdGNoX3NlbmRlcnMgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9iYXRjaF9yZXF1ZXN0cyA9IGZhbHNlO1xuICAgIF8uZWFjaCh0aGlzLnJlcXVlc3RfYmF0Y2hlcnMsIGZ1bmN0aW9uKGJhdGNoZXIpIHtcbiAgICAgICAgYmF0Y2hlci5zdG9wKCk7XG4gICAgICAgIGJhdGNoZXIuY2xlYXIoKTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogcHVzaCgpIGtlZXBzIHRoZSBzdGFuZGFyZCBhc3luYy1hcnJheS1wdXNoXG4gKiBiZWhhdmlvciBhcm91bmQgYWZ0ZXIgdGhlIGxpYiBpcyBsb2FkZWQuXG4gKiBUaGlzIGlzIG9ubHkgdXNlZnVsIGZvciBleHRlcm5hbCBpbnRlZ3JhdGlvbnMgdGhhdFxuICogZG8gbm90IHdpc2ggdG8gcmVseSBvbiBvdXIgY29udmVuaWVuY2UgbWV0aG9kc1xuICogKGNyZWF0ZWQgaW4gdGhlIHNuaXBwZXQpLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqICAgICBtaXhwYW5lbC5wdXNoKFsncmVnaXN0ZXInLCB7IGE6ICdiJyB9XSk7XG4gKlxuICogQHBhcmFtIHtBcnJheX0gaXRlbSBBIFtmdW5jdGlvbl9uYW1lLCBhcmdzLi4uXSBhcnJheSB0byBiZSBleGVjdXRlZFxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICB0aGlzLl9leGVjdXRlX2FycmF5KFtpdGVtXSk7XG59O1xuXG4vKipcbiAqIERpc2FibGUgZXZlbnRzIG9uIHRoZSBNaXhwYW5lbCBvYmplY3QuIElmIHBhc3NlZCBubyBhcmd1bWVudHMsXG4gKiB0aGlzIGZ1bmN0aW9uIGRpc2FibGVzIHRyYWNraW5nIG9mIGFueSBldmVudC4gSWYgcGFzc2VkIGFuXG4gKiBhcnJheSBvZiBldmVudCBuYW1lcywgdGhvc2UgZXZlbnRzIHdpbGwgYmUgZGlzYWJsZWQsIGJ1dCBvdGhlclxuICogZXZlbnRzIHdpbGwgY29udGludWUgdG8gYmUgdHJhY2tlZC5cbiAqXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN0b3Agb3RoZXIgbWl4cGFuZWwgZnVuY3Rpb25zIGZyb21cbiAqIGZpcmluZywgc3VjaCBhcyByZWdpc3RlcigpIG9yIHBlb3BsZS5zZXQoKS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBbZXZlbnRzXSBBbiBhcnJheSBvZiBldmVudCBuYW1lcyB0byBkaXNhYmxlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5kaXNhYmxlID0gZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgaWYgKHR5cGVvZihldmVudHMpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9mbGFncy5kaXNhYmxlX2FsbF9ldmVudHMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19kaXNhYmxlZF9ldmVudHMgPSB0aGlzLl9fZGlzYWJsZWRfZXZlbnRzLmNvbmNhdChldmVudHMpO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZW5jb2RlX2RhdGFfZm9yX3JlcXVlc3QgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGVuY29kZWRfZGF0YSA9IF8uSlNPTkVuY29kZShkYXRhKTtcbiAgICBpZiAodGhpcy5nZXRfY29uZmlnKCdhcGlfcGF5bG9hZF9mb3JtYXQnKSA9PT0gUEFZTE9BRF9UWVBFX0JBU0U2NCkge1xuICAgICAgICBlbmNvZGVkX2RhdGEgPSBfLmJhc2U2NEVuY29kZShlbmNvZGVkX2RhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geydkYXRhJzogZW5jb2RlZF9kYXRhfTtcbn07XG5cbi8vIGludGVybmFsIG1ldGhvZCBmb3IgaGFuZGxpbmcgdHJhY2sgdnMgYmF0Y2gtZW5xdWV1ZSBsb2dpY1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl90cmFja19vcl9iYXRjaCA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRydW5jYXRlZF9kYXRhID0gXy50cnVuY2F0ZShvcHRpb25zLmRhdGEsIDI1NSk7XG4gICAgdmFyIGVuZHBvaW50ID0gb3B0aW9ucy5lbmRwb2ludDtcbiAgICB2YXIgYmF0Y2hlciA9IG9wdGlvbnMuYmF0Y2hlcjtcbiAgICB2YXIgc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkgPSBvcHRpb25zLnNob3VsZF9zZW5kX2ltbWVkaWF0ZWx5O1xuICAgIHZhciBzZW5kX3JlcXVlc3Rfb3B0aW9ucyA9IG9wdGlvbnMuc2VuZF9yZXF1ZXN0X29wdGlvbnMgfHwge307XG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBOT09QX0ZVTkM7XG5cbiAgICB2YXIgcmVxdWVzdF9lbnF1ZXVlZF9vcl9pbml0aWF0ZWQgPSB0cnVlO1xuICAgIHZhciBzZW5kX3JlcXVlc3RfaW1tZWRpYXRlbHkgPSBfLmJpbmQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghc2VuZF9yZXF1ZXN0X29wdGlvbnMuc2tpcF9ob29rcykge1xuICAgICAgICAgICAgdHJ1bmNhdGVkX2RhdGEgPSB0aGlzLl9ydW5faG9vaygnYmVmb3JlX3NlbmRfJyArIG9wdGlvbnMudHlwZSwgdHJ1bmNhdGVkX2RhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cnVuY2F0ZWRfZGF0YSkge1xuICAgICAgICAgICAgY29uc29sZSQxLmxvZygnTUlYUEFORUwgUkVRVUVTVDonKTtcbiAgICAgICAgICAgIGNvbnNvbGUkMS5sb2codHJ1bmNhdGVkX2RhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRfcmVxdWVzdChcbiAgICAgICAgICAgICAgICBlbmRwb2ludCxcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVfZGF0YV9mb3JfcmVxdWVzdCh0cnVuY2F0ZWRfZGF0YSksXG4gICAgICAgICAgICAgICAgc2VuZF9yZXF1ZXN0X29wdGlvbnMsXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJlcGFyZV9jYWxsYmFjayhjYWxsYmFjaywgdHJ1bmNhdGVkX2RhdGEpXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIGlmICh0aGlzLl9iYXRjaF9yZXF1ZXN0cyAmJiAhc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHkpIHtcbiAgICAgICAgYmF0Y2hlci5lbnF1ZXVlKHRydW5jYXRlZF9kYXRhKS50aGVuKGZ1bmN0aW9uKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgaWYgKHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKDEsIHRydW5jYXRlZF9kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkID0gc2VuZF9yZXF1ZXN0X2ltbWVkaWF0ZWx5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcXVlc3RfZW5xdWV1ZWRfb3JfaW5pdGlhdGVkICYmIHRydW5jYXRlZF9kYXRhO1xufTtcblxuLyoqXG4gKiBUcmFjayBhbiBldmVudC4gVGhpcyBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgYW5kXG4gKiBmcmVxdWVudGx5IHVzZWQgTWl4cGFuZWwgZnVuY3Rpb24uXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBhbiBldmVudCBuYW1lZCAnUmVnaXN0ZXJlZCdcbiAqICAgICBtaXhwYW5lbC50cmFjaygnUmVnaXN0ZXJlZCcsIHsnR2VuZGVyJzogJ01hbGUnLCAnQWdlJzogMjF9KTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgYW4gZXZlbnQgdXNpbmcgbmF2aWdhdG9yLnNlbmRCZWFjb25cbiAqICAgICBtaXhwYW5lbC50cmFjaygnTGVmdCBwYWdlJywgeydkdXJhdGlvbl9zZWNvbmRzJzogMzV9LCB7dHJhbnNwb3J0OiAnc2VuZEJlYWNvbid9KTtcbiAqXG4gKiBUbyB0cmFjayBsaW5rIGNsaWNrcyBvciBmb3JtIHN1Ym1pc3Npb25zLCBzZWUgdHJhY2tfbGlua3MoKSBvciB0cmFja19mb3JtcygpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudC4gVGhpcyBjYW4gYmUgYW55dGhpbmcgdGhlIHVzZXIgZG9lcyAtICdCdXR0b24gQ2xpY2snLCAnU2lnbiBVcCcsICdJdGVtIFB1cmNoYXNlZCcsIGV0Yy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gQSBzZXQgb2YgcHJvcGVydGllcyB0byBpbmNsdWRlIHdpdGggdGhlIGV2ZW50IHlvdSdyZSBzZW5kaW5nLiBUaGVzZSBkZXNjcmliZSB0aGUgdXNlciB3aG8gZGlkIHRoZSBldmVudCBvciBkZXRhaWxzIGFib3V0IHRoZSBldmVudCBpdHNlbGYuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgdHJhY2sgcmVxdWVzdC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy50cmFuc3BvcnRdIFRyYW5zcG9ydCBtZXRob2QgZm9yIG5ldHdvcmsgcmVxdWVzdCAoJ3hocicgb3IgJ3NlbmRCZWFjb24nKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VuZF9pbW1lZGlhdGVseV0gV2hldGhlciB0byBieXBhc3MgYmF0Y2hpbmcvcXVldWVpbmcgYW5kIHNlbmQgdHJhY2sgcmVxdWVzdCBpbW1lZGlhdGVseS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gSWYgcHJvdmlkZWQsIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciB0cmFja2luZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbnxPYmplY3R9IElmIHRoZSB0cmFja2luZyByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsbHkgaW5pdGlhdGVkL3F1ZXVlZCwgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSB0cmFja2luZyBwYXlsb2FkIHNlbnQgdG8gdGhlIEFQSSBzZXJ2ZXIgaXMgcmV0dXJuZWQ7IG90aGVyd2lzZSBmYWxzZS5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihldmVudF9uYW1lLCBwcm9wZXJ0aWVzLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghY2FsbGJhY2sgJiYgdHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHRyYW5zcG9ydCA9IG9wdGlvbnNbJ3RyYW5zcG9ydCddOyAvLyBleHRlcm5hbCBBUEksIGRvbid0IG1pbmlmeSAndHJhbnNwb3J0JyBwcm9wXG4gICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICBvcHRpb25zLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDsgLy8gJ3RyYW5zcG9ydCcgcHJvcCBuYW1lIGNhbiBiZSBtaW5pZmllZCBpbnRlcm5hbGx5XG4gICAgfVxuICAgIHZhciBzaG91bGRfc2VuZF9pbW1lZGlhdGVseSA9IG9wdGlvbnNbJ3NlbmRfaW1tZWRpYXRlbHknXTtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gTk9PUF9GVU5DO1xuICAgIH1cblxuICAgIGlmIChfLmlzVW5kZWZpbmVkKGV2ZW50X25hbWUpKSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdObyBldmVudCBuYW1lIHByb3ZpZGVkIHRvIG1peHBhbmVsLnRyYWNrJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRfaXNfZGlzYWJsZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgY2FsbGJhY2soMCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBzZXQgZGVmYXVsdHNcbiAgICBwcm9wZXJ0aWVzID0gXy5leHRlbmQoe30sIHByb3BlcnRpZXMpO1xuICAgIHByb3BlcnRpZXNbJ3Rva2VuJ10gPSB0aGlzLmdldF9jb25maWcoJ3Rva2VuJyk7XG5cbiAgICAvLyBzZXQgJGR1cmF0aW9uIGlmIHRpbWVfZXZlbnQgd2FzIHByZXZpb3VzbHkgY2FsbGVkIGZvciB0aGlzIGV2ZW50XG4gICAgdmFyIHN0YXJ0X3RpbWVzdGFtcCA9IHRoaXNbJ3BlcnNpc3RlbmNlJ10ucmVtb3ZlX2V2ZW50X3RpbWVyKGV2ZW50X25hbWUpO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChzdGFydF90aW1lc3RhbXApKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbl9pbl9tcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRfdGltZXN0YW1wO1xuICAgICAgICBwcm9wZXJ0aWVzWyckZHVyYXRpb24nXSA9IHBhcnNlRmxvYXQoKGR1cmF0aW9uX2luX21zIC8gMTAwMCkudG9GaXhlZCgzKSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0X2RlZmF1bHRfc3VwZXJwcm9wcygpO1xuXG4gICAgdmFyIG1hcmtldGluZ19wcm9wZXJ0aWVzID0gdGhpcy5nZXRfY29uZmlnKCd0cmFja19tYXJrZXRpbmcnKVxuICAgICAgICA/IF8uaW5mby5tYXJrZXRpbmdQYXJhbXMoKVxuICAgICAgICA6IHt9O1xuXG4gICAgLy8gbm90ZTogZXh0ZW5kIHdyaXRlcyB0byB0aGUgZmlyc3Qgb2JqZWN0LCBzbyBsZXRzIG1ha2Ugc3VyZSB3ZVxuICAgIC8vIGRvbid0IHdyaXRlIHRvIHRoZSBwZXJzaXN0ZW5jZSBwcm9wZXJ0aWVzIG9iamVjdCBhbmQgaW5mb1xuICAgIC8vIHByb3BlcnRpZXMgb2JqZWN0IGJ5IHBhc3NpbmcgaW4gYSBuZXcgb2JqZWN0XG5cbiAgICAvLyB1cGRhdGUgcHJvcGVydGllcyB3aXRoIHBhZ2V2aWV3IGluZm8gYW5kIHN1cGVyLXByb3BlcnRpZXNcbiAgICBwcm9wZXJ0aWVzID0gXy5leHRlbmQoXG4gICAgICAgIHt9LFxuICAgICAgICBfLmluZm8ucHJvcGVydGllcyh7J21wX2xvYWRlcic6IHRoaXMuZ2V0X2NvbmZpZygnbXBfbG9hZGVyJyl9KSxcbiAgICAgICAgbWFya2V0aW5nX3Byb3BlcnRpZXMsXG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10ucHJvcGVydGllcygpLFxuICAgICAgICB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMsXG4gICAgICAgIHRoaXMuZ2V0X3Nlc3Npb25fcmVjb3JkaW5nX3Byb3BlcnRpZXMoKSxcbiAgICAgICAgcHJvcGVydGllc1xuICAgICk7XG5cbiAgICB2YXIgcHJvcGVydHlfYmxhY2tsaXN0ID0gdGhpcy5nZXRfY29uZmlnKCdwcm9wZXJ0eV9ibGFja2xpc3QnKTtcbiAgICBpZiAoXy5pc0FycmF5KHByb3BlcnR5X2JsYWNrbGlzdCkpIHtcbiAgICAgICAgXy5lYWNoKHByb3BlcnR5X2JsYWNrbGlzdCwgZnVuY3Rpb24oYmxhY2tsaXN0ZWRfcHJvcCkge1xuICAgICAgICAgICAgZGVsZXRlIHByb3BlcnRpZXNbYmxhY2tsaXN0ZWRfcHJvcF07XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVwb3J0X2Vycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBwcm9wZXJ0eV9ibGFja2xpc3QgY29uZmlnOiAnICsgcHJvcGVydHlfYmxhY2tsaXN0KTtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgJ2V2ZW50JzogZXZlbnRfbmFtZSxcbiAgICAgICAgJ3Byb3BlcnRpZXMnOiBwcm9wZXJ0aWVzXG4gICAgfTtcbiAgICB2YXIgcmV0ID0gdGhpcy5fdHJhY2tfb3JfYmF0Y2goe1xuICAgICAgICB0eXBlOiAnZXZlbnRzJyxcbiAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgZW5kcG9pbnQ6IHRoaXMuZ2V0X2NvbmZpZygnYXBpX2hvc3QnKSArICcvJyArIHRoaXMuZ2V0X2NvbmZpZygnYXBpX3JvdXRlcycpWyd0cmFjayddLFxuICAgICAgICBiYXRjaGVyOiB0aGlzLnJlcXVlc3RfYmF0Y2hlcnMuZXZlbnRzLFxuICAgICAgICBzaG91bGRfc2VuZF9pbW1lZGlhdGVseTogc2hvdWxkX3NlbmRfaW1tZWRpYXRlbHksXG4gICAgICAgIHNlbmRfcmVxdWVzdF9vcHRpb25zOiBvcHRpb25zXG4gICAgfSwgY2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHJldDtcbn0pO1xuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBjdXJyZW50IHVzZXIgaW50byBvbmUvbWFueSBncm91cHMuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAgbWl4cGFuZWwuc2V0X2dyb3VwKCdjb21wYW55JywgWydtaXhwYW5lbCcsICdnb29nbGUnXSkgLy8gYW4gYXJyYXkgb2YgSURzXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpXG4gKiAgICAgIG1peHBhbmVsLnNldF9ncm91cCgnY29tcGFueScsIDEyODc0NjMxMilcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBfa2V5IEdyb3VwIGtleVxuICogQHBhcmFtIHtBcnJheXxTdHJpbmd8TnVtYmVyfSBncm91cF9pZHMgQW4gYXJyYXkgb2YgZ3JvdXAgSURzLCBvciBhIHNpbmd1bGFyIGdyb3VwIElEXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICpcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFfLmlzQXJyYXkoZ3JvdXBfaWRzKSkge1xuICAgICAgICBncm91cF9pZHMgPSBbZ3JvdXBfaWRzXTtcbiAgICB9XG4gICAgdmFyIHByb3AgPSB7fTtcbiAgICBwcm9wW2dyb3VwX2tleV0gPSBncm91cF9pZHM7XG4gICAgdGhpcy5yZWdpc3Rlcihwcm9wKTtcbiAgICByZXR1cm4gdGhpc1sncGVvcGxlJ10uc2V0KGdyb3VwX2tleSwgZ3JvdXBfaWRzLCBjYWxsYmFjayk7XG59KTtcblxuLyoqXG4gKiBBZGQgYSBuZXcgZ3JvdXAgZm9yIHRoaXMgdXNlci5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICBtaXhwYW5lbC5hZGRfZ3JvdXAoJ2NvbXBhbnknLCAnbWl4cGFuZWwnKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cF9rZXkgR3JvdXAga2V5XG4gKiBAcGFyYW0geyp9IGdyb3VwX2lkIEEgdmFsaWQgTWl4cGFuZWwgcHJvcGVydHkgdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmFkZF9ncm91cCA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24oZ3JvdXBfa2V5LCBncm91cF9pZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgb2xkX3ZhbHVlcyA9IHRoaXMuZ2V0X3Byb3BlcnR5KGdyb3VwX2tleSk7XG4gICAgdmFyIHByb3AgPSB7fTtcbiAgICBpZiAob2xkX3ZhbHVlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3BbZ3JvdXBfa2V5XSA9IFtncm91cF9pZF07XG4gICAgICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9sZF92YWx1ZXMuaW5kZXhPZihncm91cF9pZCkgPT09IC0xKSB7XG4gICAgICAgICAgICBvbGRfdmFsdWVzLnB1c2goZ3JvdXBfaWQpO1xuICAgICAgICAgICAgcHJvcFtncm91cF9rZXldID0gb2xkX3ZhbHVlcztcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXIocHJvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXNbJ3Blb3BsZSddLnVuaW9uKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFJlbW92ZSBhIGdyb3VwIGZyb20gdGhpcyB1c2VyLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnJlbW92ZV9ncm91cCgnY29tcGFueScsICdtaXhwYW5lbCcpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7Kn0gZ3JvdXBfaWQgQSB2YWxpZCBNaXhwYW5lbCBwcm9wZXJ0eSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIElmIHByb3ZpZGVkLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVtb3ZlX2dyb3VwID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihncm91cF9rZXksIGdyb3VwX2lkLCBjYWxsYmFjaykge1xuICAgIHZhciBvbGRfdmFsdWUgPSB0aGlzLmdldF9wcm9wZXJ0eShncm91cF9rZXkpO1xuICAgIC8vIGlmIHRoZSB2YWx1ZSBkb2Vzbid0IGV4aXN0LCB0aGUgcGVyc2lzdGVudCBzdG9yZSBpcyB1bmNoYW5nZWRcbiAgICBpZiAob2xkX3ZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIGlkeCA9IG9sZF92YWx1ZS5pbmRleE9mKGdyb3VwX2lkKTtcbiAgICAgICAgaWYgKGlkeCA+IC0xKSB7XG4gICAgICAgICAgICBvbGRfdmFsdWUuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyKHtncm91cF9rZXk6IG9sZF92YWx1ZX0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRfdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnVucmVnaXN0ZXIoZ3JvdXBfa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1sncGVvcGxlJ10ucmVtb3ZlKGdyb3VwX2tleSwgZ3JvdXBfaWQsIGNhbGxiYWNrKTtcbn0pO1xuXG4vKipcbiAqIFRyYWNrIGFuIGV2ZW50IHdpdGggc3BlY2lmaWMgZ3JvdXBzLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgIG1peHBhbmVsLnRyYWNrX3dpdGhfZ3JvdXBzKCdwdXJjaGFzZScsIHsncHJvZHVjdCc6ICdpcGhvbmUnfSwgeydVbml2ZXJzaXR5JzogWydVQ0InLCAnVUNMQSddfSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgKHNlZSBgbWl4cGFuZWwudHJhY2soKWApXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgQSBzZXQgb2YgcHJvcGVydGllcyB0byBpbmNsdWRlIHdpdGggdGhlIGV2ZW50IHlvdSdyZSBzZW5kaW5nIChzZWUgYG1peHBhbmVsLnRyYWNrKClgKVxuICogQHBhcmFtIHtPYmplY3Q9fSBncm91cHMgQW4gb2JqZWN0IG1hcHBpbmcgZ3JvdXAgbmFtZSBrZXlzIHRvIG9uZSBvciBtb3JlIHZhbHVlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBJZiBwcm92aWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIGFmdGVyIHRyYWNraW5nIHRoZSBldmVudC5cbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3dpdGhfZ3JvdXBzID0gYWRkT3B0T3V0Q2hlY2tNaXhwYW5lbExpYihmdW5jdGlvbihldmVudF9uYW1lLCBwcm9wZXJ0aWVzLCBncm91cHMsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRyYWNraW5nX3Byb3BzID0gXy5leHRlbmQoe30sIHByb3BlcnRpZXMgfHwge30pO1xuICAgIF8uZWFjaChncm91cHMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgaWYgKHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0cmFja2luZ19wcm9wc1trXSA9IHY7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy50cmFjayhldmVudF9uYW1lLCB0cmFja2luZ19wcm9wcywgY2FsbGJhY2spO1xufSk7XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fY3JlYXRlX21hcF9rZXkgPSBmdW5jdGlvbiAoZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHJldHVybiBncm91cF9rZXkgKyAnXycgKyBKU09OLnN0cmluZ2lmeShncm91cF9pZCk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX3JlbW92ZV9ncm91cF9mcm9tX2NhY2hlID0gZnVuY3Rpb24gKGdyb3VwX2tleSwgZ3JvdXBfaWQpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FjaGVkX2dyb3Vwc1t0aGlzLl9jcmVhdGVfbWFwX2tleShncm91cF9rZXksIGdyb3VwX2lkKV07XG59O1xuXG4vKipcbiAqIExvb2sgdXAgcmVmZXJlbmNlIHRvIGEgTWl4cGFuZWwgZ3JvdXBcbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgICAgbWl4cGFuZWwuZ2V0X2dyb3VwKGdyb3VwX2tleSwgZ3JvdXBfaWQpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGdyb3VwX2tleSBHcm91cCBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBncm91cF9pZCBBIHZhbGlkIE1peHBhbmVsIHByb3BlcnR5IHR5cGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEEgTWl4cGFuZWxHcm91cCBpZGVudGlmaWVyXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZ3JvdXAgPSBmdW5jdGlvbiAoZ3JvdXBfa2V5LCBncm91cF9pZCkge1xuICAgIHZhciBtYXBfa2V5ID0gdGhpcy5fY3JlYXRlX21hcF9rZXkoZ3JvdXBfa2V5LCBncm91cF9pZCk7XG4gICAgdmFyIGdyb3VwID0gdGhpcy5fY2FjaGVkX2dyb3Vwc1ttYXBfa2V5XTtcbiAgICBpZiAoZ3JvdXAgPT09IHVuZGVmaW5lZCB8fCBncm91cC5fZ3JvdXBfa2V5ICE9PSBncm91cF9rZXkgfHwgZ3JvdXAuX2dyb3VwX2lkICE9PSBncm91cF9pZCkge1xuICAgICAgICBncm91cCA9IG5ldyBNaXhwYW5lbEdyb3VwKCk7XG4gICAgICAgIGdyb3VwLl9pbml0KHRoaXMsIGdyb3VwX2tleSwgZ3JvdXBfaWQpO1xuICAgICAgICB0aGlzLl9jYWNoZWRfZ3JvdXBzW21hcF9rZXldID0gZ3JvdXA7XG4gICAgfVxuICAgIHJldHVybiBncm91cDtcbn07XG5cbi8qKlxuICogVHJhY2sgYSBkZWZhdWx0IE1peHBhbmVsIHBhZ2UgdmlldyBldmVudCwgd2hpY2ggaW5jbHVkZXMgZXh0cmEgZGVmYXVsdCBldmVudCBwcm9wZXJ0aWVzIHRvXG4gKiBpbXByb3ZlIHBhZ2UgdmlldyBkYXRhLlxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gdHJhY2sgYSBkZWZhdWx0ICRtcF93ZWJfcGFnZV92aWV3IGV2ZW50XG4gKiAgICAgbWl4cGFuZWwudHJhY2tfcGFnZXZpZXcoKTtcbiAqXG4gKiAgICAgLy8gdHJhY2sgYSBwYWdlIHZpZXcgZXZlbnQgd2l0aCBhZGRpdGlvbmFsIGV2ZW50IHByb3BlcnRpZXNcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J2FiX3Rlc3RfdmFyaWFudCc6ICdjYXJkLWxheW91dC1iJ30pO1xuICpcbiAqICAgICAvLyBleGFtcGxlIGFwcHJvYWNoIHRvIHRyYWNrIHBhZ2Ugdmlld3Mgb24gZGlmZmVyZW50IHBhZ2UgdHlwZXMgYXMgZXZlbnQgcHJvcGVydGllc1xuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsncGFnZSc6ICdwcmljaW5nJ30pO1xuICogICAgIG1peHBhbmVsLnRyYWNrX3BhZ2V2aWV3KHsncGFnZSc6ICdob21lcGFnZSd9KTtcbiAqXG4gKiAgICAgLy8gVU5DT01NT046IFRyYWNraW5nIGEgcGFnZSB2aWV3IGV2ZW50IHdpdGggYSBjdXN0b20gZXZlbnRfbmFtZSBvcHRpb24uIE5PVCBleHBlY3RlZCB0byBiZSB1c2VkIGZvclxuICogICAgIC8vIGluZGl2aWR1YWwgcGFnZXMgb24gdGhlIHNhbWUgc2l0ZSBvciBwcm9kdWN0LiBVc2UgY2FzZXMgZm9yIGN1c3RvbSBldmVudF9uYW1lIG1heSBiZSBwYWdlXG4gKiAgICAgLy8gdmlld3Mgb24gZGlmZmVyZW50IHByb2R1Y3RzIG9yIGludGVybmFsIGFwcGxpY2F0aW9ucyB0aGF0IGFyZSBjb25zaWRlcmVkIGNvbXBsZXRlbHkgc2VwYXJhdGVcbiAqICAgICBtaXhwYW5lbC50cmFja19wYWdldmlldyh7J3BhZ2UnOiAnY3VzdG9tZXItc2VhcmNoJ30sIHsnZXZlbnRfbmFtZSc6ICdbaW50ZXJuYWxdIEFkbWluIFBhZ2UgVmlldyd9KTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogVGhlIGBjb25maWcudHJhY2tfcGFnZXZpZXdgIG9wdGlvbiBmb3IgPGEgaHJlZj1cIiNtaXhwYW5lbGluaXRcIj5taXhwYW5lbC5pbml0KCk8L2E+XG4gKiBtYXkgYmUgdHVybmVkIG9uIGZvciB0cmFja2luZyBwYWdlIGxvYWRzIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogICAgIC8vIHRyYWNrIG9ubHkgcGFnZSBsb2Fkc1xuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiB0cnVlfSk7XG4gKlxuICogICAgIC8vIHRyYWNrIHdoZW4gdGhlIFVSTCBjaGFuZ2VzIGluIGFueSBtYW5uZXJcbiAqICAgICBtaXhwYW5lbC5pbml0KFBST0pFQ1RfVE9LRU4sIHt0cmFja19wYWdldmlldzogJ2Z1bGwtdXJsJ30pO1xuICpcbiAqICAgICAvLyB0cmFjayB3aGVuIHRoZSBVUkwgY2hhbmdlcywgaWdub3JpbmcgYW55IGNoYW5nZXMgaW4gdGhlIGhhc2ggcGFydFxuICogICAgIG1peHBhbmVsLmluaXQoUFJPSkVDVF9UT0tFTiwge3RyYWNrX3BhZ2V2aWV3OiAndXJsLXdpdGgtcGF0aC1hbmQtcXVlcnktc3RyaW5nJ30pO1xuICpcbiAqICAgICAvLyB0cmFjayB3aGVuIHRoZSBwYXRoIGNoYW5nZXMsIGlnbm9yaW5nIGFueSBxdWVyeSBwYXJhbWV0ZXIgb3IgaGFzaCBjaGFuZ2VzXG4gKiAgICAgbWl4cGFuZWwuaW5pdChQUk9KRUNUX1RPS0VOLCB7dHJhY2tfcGFnZXZpZXc6ICd1cmwtd2l0aC1wYXRoJ30pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllc10gQW4gb3B0aW9uYWwgc2V0IG9mIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0byBzZW5kIHdpdGggdGhlIHBhZ2UgdmlldyBldmVudFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBQYWdlIHZpZXcgdHJhY2tpbmcgb3B0aW9uc1xuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmV2ZW50X25hbWVdIC0gQWx0ZXJuYXRlIG5hbWUgZm9yIHRoZSB0cmFja2luZyBldmVudFxuICogQHJldHVybnMge0Jvb2xlYW58T2JqZWN0fSBJZiB0aGUgdHJhY2tpbmcgcmVxdWVzdCB3YXMgc3VjY2Vzc2Z1bGx5IGluaXRpYXRlZC9xdWV1ZWQsIGFuIG9iamVjdFxuICogd2l0aCB0aGUgdHJhY2tpbmcgcGF5bG9hZCBzZW50IHRvIHRoZSBBUEkgc2VydmVyIGlzIHJldHVybmVkOyBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19wYWdldmlldyA9IGFkZE9wdE91dENoZWNrTWl4cGFuZWxMaWIoZnVuY3Rpb24ocHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgZXZlbnRfbmFtZSA9IG9wdGlvbnNbJ2V2ZW50X25hbWUnXSB8fCAnJG1wX3dlYl9wYWdlX3ZpZXcnO1xuXG4gICAgdmFyIGRlZmF1bHRfcGFnZV9wcm9wZXJ0aWVzID0gXy5leHRlbmQoXG4gICAgICAgIF8uaW5mby5tcFBhZ2VWaWV3UHJvcGVydGllcygpLFxuICAgICAgICBfLmluZm8uY2FtcGFpZ25QYXJhbXMoKSxcbiAgICAgICAgXy5pbmZvLmNsaWNrUGFyYW1zKClcbiAgICApO1xuXG4gICAgdmFyIGV2ZW50X3Byb3BlcnRpZXMgPSBfLmV4dGVuZChcbiAgICAgICAge30sXG4gICAgICAgIGRlZmF1bHRfcGFnZV9wcm9wZXJ0aWVzLFxuICAgICAgICBwcm9wZXJ0aWVzXG4gICAgKTtcblxuICAgIHJldHVybiB0aGlzLnRyYWNrKGV2ZW50X25hbWUsIGV2ZW50X3Byb3BlcnRpZXMpO1xufSk7XG5cbi8qKlxuICogVHJhY2sgY2xpY2tzIG9uIGEgc2V0IG9mIGRvY3VtZW50IGVsZW1lbnRzLiBTZWxlY3RvciBtdXN0IGJlIGFcbiAqIHZhbGlkIHF1ZXJ5LiBFbGVtZW50cyBtdXN0IGV4aXN0IG9uIHRoZSBwYWdlIGF0IHRoZSB0aW1lIHRyYWNrX2xpbmtzIGlzIGNhbGxlZC5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHRyYWNrIGNsaWNrIGZvciBsaW5rIGlkICNuYXZcbiAqICAgICBtaXhwYW5lbC50cmFja19saW5rcygnI25hdicsICdDbGlja2VkIE5hdiBMaW5rJyk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB3YWl0IHVwIHRvIDMwMCBtcyBmb3IgdGhlIE1peHBhbmVsXG4gKiBzZXJ2ZXJzIHRvIHJlc3BvbmQuIElmIHRoZXkgaGF2ZSBub3QgcmVzcG9uZGVkIGJ5IHRoYXQgdGltZVxuICogaXQgd2lsbCBoZWFkIHRvIHRoZSBsaW5rIHdpdGhvdXQgZW5zdXJpbmcgdGhhdCB5b3VyIGV2ZW50XG4gKiBoYXMgYmVlbiB0cmFja2VkLiAgVG8gY29uZmlndXJlIHRoaXMgdGltZW91dCBwbGVhc2Ugc2VlIHRoZVxuICogc2V0X2NvbmZpZygpIGRvY3VtZW50YXRpb24gYmVsb3cuXG4gKlxuICogSWYgeW91IHBhc3MgYSBmdW5jdGlvbiBpbiBhcyB0aGUgcHJvcGVydGllcyBhcmd1bWVudCwgdGhlXG4gKiBmdW5jdGlvbiB3aWxsIHJlY2VpdmUgdGhlIERPTUVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gKiBldmVudCBhcyBhbiBhcmd1bWVudC4gIFlvdSBhcmUgZXhwZWN0ZWQgdG8gcmV0dXJuIGFuIG9iamVjdFxuICogZnJvbSB0aGUgZnVuY3Rpb247IGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gdGhpcyBvYmplY3RcbiAqIHdpbGwgYmUgc2VudCB0byBtaXhwYW5lbCBhcyBldmVudCBwcm9wZXJ0aWVzLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gcXVlcnkgQSB2YWxpZCBET00gcXVlcnksIGVsZW1lbnQgb3IgalF1ZXJ5LWVzcXVlIGxpc3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudF9uYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byB0cmFja1xuICogQHBhcmFtIHtPYmplY3R8RnVuY3Rpb259IFtwcm9wZXJ0aWVzXSBBIHByb3BlcnRpZXMgb2JqZWN0IG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRpY3Rpb25hcnkgb2YgcHJvcGVydGllcyB3aGVuIHBhc3NlZCBhIERPTUVsZW1lbnRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX2xpbmtzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWNrX2RvbS5jYWxsKHRoaXMsIExpbmtUcmFja2VyLCBhcmd1bWVudHMpO1xufTtcblxuLyoqXG4gKiBUcmFjayBmb3JtIHN1Ym1pc3Npb25zLiBTZWxlY3RvciBtdXN0IGJlIGEgdmFsaWQgcXVlcnkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0cmFjayBzdWJtaXNzaW9uIGZvciBmb3JtIGlkICdyZWdpc3RlcidcbiAqICAgICBtaXhwYW5lbC50cmFja19mb3JtcygnI3JlZ2lzdGVyJywgJ0NyZWF0ZWQgQWNjb3VudCcpO1xuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgd2FpdCB1cCB0byAzMDAgbXMgZm9yIHRoZSBtaXhwYW5lbFxuICogc2VydmVycyB0byByZXNwb25kLCBpZiB0aGV5IGhhdmUgbm90IHJlc3BvbmRlZCBieSB0aGF0IHRpbWVcbiAqIGl0IHdpbGwgaGVhZCB0byB0aGUgbGluayB3aXRob3V0IGVuc3VyaW5nIHRoYXQgeW91ciBldmVudFxuICogaGFzIGJlZW4gdHJhY2tlZC4gIFRvIGNvbmZpZ3VyZSB0aGlzIHRpbWVvdXQgcGxlYXNlIHNlZSB0aGVcbiAqIHNldF9jb25maWcoKSBkb2N1bWVudGF0aW9uIGJlbG93LlxuICpcbiAqIElmIHlvdSBwYXNzIGEgZnVuY3Rpb24gaW4gYXMgdGhlIHByb3BlcnRpZXMgYXJndW1lbnQsIHRoZVxuICogZnVuY3Rpb24gd2lsbCByZWNlaXZlIHRoZSBET01FbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICogZXZlbnQgYXMgYW4gYXJndW1lbnQuICBZb3UgYXJlIGV4cGVjdGVkIHRvIHJldHVybiBhbiBvYmplY3RcbiAqIGZyb20gdGhlIGZ1bmN0aW9uOyBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIHRoaXMgb2JqZWN0XG4gKiB3aWxsIGJlIHNlbnQgdG8gbWl4cGFuZWwgYXMgZXZlbnQgcHJvcGVydGllcy5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IHF1ZXJ5IEEgdmFsaWQgRE9NIHF1ZXJ5LCBlbGVtZW50IG9yIGpRdWVyeS1lc3F1ZSBsaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRfbmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBbcHJvcGVydGllc10gVGhpcyBjYW4gYmUgYSBzZXQgb2YgcHJvcGVydGllcywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgcHJvcGVydGllcyBhZnRlciBiZWluZyBwYXNzZWQgYSBET01FbGVtZW50XG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19mb3JtcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFja19kb20uY2FsbCh0aGlzLCBGb3JtVHJhY2tlciwgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogVGltZSBhbiBldmVudCBieSBpbmNsdWRpbmcgdGhlIHRpbWUgYmV0d2VlbiB0aGlzIGNhbGwgYW5kIGFcbiAqIGxhdGVyICd0cmFjaycgY2FsbCBmb3IgdGhlIHNhbWUgZXZlbnQgaW4gdGhlIHByb3BlcnRpZXMgc2VudFxuICogd2l0aCB0aGUgZXZlbnQuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyB0aW1lIGFuIGV2ZW50IG5hbWVkICdSZWdpc3RlcmVkJ1xuICogICAgIG1peHBhbmVsLnRpbWVfZXZlbnQoJ1JlZ2lzdGVyZWQnKTtcbiAqICAgICBtaXhwYW5lbC50cmFjaygnUmVnaXN0ZXJlZCcsIHsnR2VuZGVyJzogJ01hbGUnLCAnQWdlJzogMjF9KTtcbiAqXG4gKiBXaGVuIGNhbGxlZCBmb3IgYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWUsIHRoZSBuZXh0IHRyYWNrIGNhbGwgZm9yIHRoYXQgZXZlbnRcbiAqIG5hbWUgd2lsbCBpbmNsdWRlIHRoZSBlbGFwc2VkIHRpbWUgYmV0d2VlbiB0aGUgJ3RpbWVfZXZlbnQnIGFuZCAndHJhY2snXG4gKiBjYWxscy4gVGhpcyB2YWx1ZSBpcyBzdG9yZWQgYXMgc2Vjb25kcyBpbiB0aGUgJyRkdXJhdGlvbicgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50X25hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50LlxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUudGltZV9ldmVudCA9IGZ1bmN0aW9uKGV2ZW50X25hbWUpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZChldmVudF9uYW1lKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignTm8gZXZlbnQgbmFtZSBwcm92aWRlZCB0byBtaXhwYW5lbC50aW1lX2V2ZW50Jyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRfaXNfZGlzYWJsZWQoZXZlbnRfbmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10uc2V0X2V2ZW50X3RpbWVyKGV2ZW50X25hbWUsICBuZXcgRGF0ZSgpLmdldFRpbWUoKSk7XG59O1xuXG52YXIgUkVHSVNURVJfREVGQVVMVFMgPSB7XG4gICAgJ3BlcnNpc3RlbnQnOiB0cnVlXG59O1xuLyoqXG4gKiBIZWxwZXIgdG8gcGFyc2Ugb3B0aW9ucyBwYXJhbSBmb3IgcmVnaXN0ZXIgbWV0aG9kcywgbWFpbnRhaW5pbmdcbiAqIGxlZ2FjeSBzdXBwb3J0IGZvciBwbGFpbiBcImRheXNcIiBwYXJhbSBpbnN0ZWFkIG9mIG9wdGlvbnMgb2JqZWN0XG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXlzX29yX29wdGlvbnNdICdkYXlzJyBvcHRpb24gKE51bWJlciksIG9yIE9wdGlvbnMgb2JqZWN0IGZvciByZWdpc3RlciBtZXRob2RzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvcHRpb25zIG9iamVjdFxuICovXG52YXIgb3B0aW9uc19mb3JfcmVnaXN0ZXIgPSBmdW5jdGlvbihkYXlzX29yX29wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAoXy5pc09iamVjdChkYXlzX29yX29wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkYXlzX29yX29wdGlvbnM7XG4gICAgfSBlbHNlIGlmICghXy5pc1VuZGVmaW5lZChkYXlzX29yX29wdGlvbnMpKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7J2RheXMnOiBkYXlzX29yX29wdGlvbnN9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcmV0dXJuIF8uZXh0ZW5kKHt9LCBSRUdJU1RFUl9ERUZBVUxUUywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgc2V0IG9mIHN1cGVyIHByb3BlcnRpZXMsIHdoaWNoIGFyZSBpbmNsdWRlZCB3aXRoIGFsbFxuICogZXZlbnRzLiBUaGlzIHdpbGwgb3ZlcndyaXRlIHByZXZpb3VzIHN1cGVyIHByb3BlcnR5IHZhbHVlcy5cbiAqXG4gKiAjIyMgVXNhZ2U6XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyICdHZW5kZXInIGFzIGEgc3VwZXIgcHJvcGVydHlcbiAqICAgICBtaXhwYW5lbC5yZWdpc3Rlcih7J0dlbmRlcic6ICdGZW1hbGUnfSk7XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIHNldmVyYWwgc3VwZXIgcHJvcGVydGllcyB3aGVuIGEgdXNlciBzaWducyB1cFxuICogICAgIG1peHBhbmVsLnJlZ2lzdGVyKHtcbiAqICAgICAgICAgJ0VtYWlsJzogJ2pkb2VAZXhhbXBsZS5jb20nLFxuICogICAgICAgICAnQWNjb3VudCBUeXBlJzogJ0ZyZWUnXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIG9ubHkgZm9yIHRoZSBjdXJyZW50IHBhZ2Vsb2FkXG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXIoeydOYW1lJzogJ1BhdCd9LCB7cGVyc2lzdGVudDogZmFsc2V9KTtcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBBbiBhc3NvY2lhdGl2ZSBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIHN0b3JlIGFib3V0IHRoZSB1c2VyXG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IFtkYXlzX29yX29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0IG9yIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLmRheXNdIC0gbnVtYmVyIG9mIGRheXMgc2luY2UgdGhlIHVzZXIncyBsYXN0IHZpc2l0IHRvIHN0b3JlIHRoZSBzdXBlciBwcm9wZXJ0aWVzIChvbmx5IHZhbGlkIGZvciBwZXJzaXN0ZWQgcHJvcHMpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtkYXlzX29yX29wdGlvbnMucGVyc2lzdGVudD10cnVlXSAtIHdoZXRoZXIgdG8gcHV0IGluIHBlcnNpc3RlbnQgc3RvcmFnZSAoY29va2llL2xvY2FsU3RvcmFnZSlcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcHMsIGRheXNfb3Jfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9uc19mb3JfcmVnaXN0ZXIoZGF5c19vcl9vcHRpb25zKTtcbiAgICBpZiAob3B0aW9uc1sncGVyc2lzdGVudCddKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10ucmVnaXN0ZXIocHJvcHMsIG9wdGlvbnNbJ2RheXMnXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgXy5leHRlbmQodGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzLCBwcm9wcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIHNldCBvZiBzdXBlciBwcm9wZXJ0aWVzIG9ubHkgb25jZS4gVGhpcyB3aWxsIG5vdFxuICogb3ZlcndyaXRlIHByZXZpb3VzIHN1cGVyIHByb3BlcnR5IHZhbHVlcywgdW5saWtlIHJlZ2lzdGVyKCkuXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyByZWdpc3RlciBhIHN1cGVyIHByb3BlcnR5IGZvciB0aGUgZmlyc3QgdGltZSBvbmx5XG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXJfb25jZSh7XG4gKiAgICAgICAgICdGaXJzdCBMb2dpbiBEYXRlJzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gKiAgICAgfSk7XG4gKlxuICogICAgIC8vIHJlZ2lzdGVyIG9uY2UsIG9ubHkgZm9yIHRoZSBjdXJyZW50IHBhZ2Vsb2FkXG4gKiAgICAgbWl4cGFuZWwucmVnaXN0ZXJfb25jZSh7XG4gKiAgICAgICAgICdGaXJzdCBpbnRlcmFjdGlvbiB0aW1lJzogbmV3IERhdGUoKS50b0lTT1N0cmluZygpXG4gKiAgICAgfSwgJ05vbmUnLCB7cGVyc2lzdGVudDogZmFsc2V9KTtcbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogSWYgZGVmYXVsdF92YWx1ZSBpcyBzcGVjaWZpZWQsIGN1cnJlbnQgc3VwZXIgcHJvcGVydGllc1xuICogd2l0aCB0aGF0IHZhbHVlIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgQW4gYXNzb2NpYXRpdmUgYXJyYXkgb2YgcHJvcGVydGllcyB0byBzdG9yZSBhYm91dCB0aGUgdXNlclxuICogQHBhcmFtIHsqfSBbZGVmYXVsdF92YWx1ZV0gVmFsdWUgdG8gb3ZlcnJpZGUgaWYgYWxyZWFkeSBzZXQgaW4gc3VwZXIgcHJvcGVydGllcyAoZXg6ICdGYWxzZScpIERlZmF1bHQ6ICdOb25lJ1xuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBbZGF5c19vcl9vcHRpb25zXSBPcHRpb25zIG9iamVjdCBvciBudW1iZXIgb2YgZGF5cyBzaW5jZSB0aGUgdXNlcidzIGxhc3QgdmlzaXQgdG8gc3RvcmUgdGhlIHN1cGVyIHByb3BlcnRpZXMgKG9ubHkgdmFsaWQgZm9yIHBlcnNpc3RlZCBwcm9wcylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RheXNfb3Jfb3B0aW9ucy5kYXlzXSAtIG51bWJlciBvZiBkYXlzIHNpbmNlIHRoZSB1c2VyJ3MgbGFzdCB2aXNpdCB0byBzdG9yZSB0aGUgc3VwZXIgcHJvcGVydGllcyAob25seSB2YWxpZCBmb3IgcGVyc2lzdGVkIHByb3BzKVxuICogQHBhcmFtIHtib29sZWFufSBbZGF5c19vcl9vcHRpb25zLnBlcnNpc3RlbnQ9dHJ1ZV0gLSB3aGV0aGVyIHRvIHB1dCBpbiBwZXJzaXN0ZW50IHN0b3JhZ2UgKGNvb2tpZS9sb2NhbFN0b3JhZ2UpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlID0gZnVuY3Rpb24ocHJvcHMsIGRlZmF1bHRfdmFsdWUsIGRheXNfb3Jfb3B0aW9ucykge1xuICAgIHZhciBvcHRpb25zID0gb3B0aW9uc19mb3JfcmVnaXN0ZXIoZGF5c19vcl9vcHRpb25zKTtcbiAgICBpZiAob3B0aW9uc1sncGVyc2lzdGVudCddKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10ucmVnaXN0ZXJfb25jZShwcm9wcywgZGVmYXVsdF92YWx1ZSwgb3B0aW9uc1snZGF5cyddKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mKGRlZmF1bHRfdmFsdWUpID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgZGVmYXVsdF92YWx1ZSA9ICdOb25lJztcbiAgICAgICAgfVxuICAgICAgICBfLmVhY2gocHJvcHMsIGZ1bmN0aW9uKHZhbCwgcHJvcCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHMuaGFzT3duUHJvcGVydHkocHJvcCkgfHwgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzW3Byb3BdID09PSBkZWZhdWx0X3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnBlcnNpc3RlZF9zdXBlcnByb3BzW3Byb3BdID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERlbGV0ZSBhIHN1cGVyIHByb3BlcnR5IHN0b3JlZCB3aXRoIHRoZSBjdXJyZW50IHVzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBuYW1lIG9mIHRoZSBzdXBlciBwcm9wZXJ0eSB0byByZW1vdmVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucGVyc2lzdGVudD10cnVlXSAtIHdoZXRoZXIgdG8gbG9vayBpbiBwZXJzaXN0ZW50IHN0b3JhZ2UgKGNvb2tpZS9sb2NhbFN0b3JhZ2UpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS51bnJlZ2lzdGVyID0gZnVuY3Rpb24ocHJvcGVydHksIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9uc19mb3JfcmVnaXN0ZXIob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnNbJ3BlcnNpc3RlbnQnXSkge1xuICAgICAgICB0aGlzWydwZXJzaXN0ZW5jZSddLnVucmVnaXN0ZXIocHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnVucGVyc2lzdGVkX3N1cGVycHJvcHNbcHJvcGVydHldO1xuICAgIH1cbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fcmVnaXN0ZXJfc2luZ2xlID0gZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBwcm9wc1twcm9wXSA9IHZhbHVlO1xuICAgIHRoaXMucmVnaXN0ZXIocHJvcHMpO1xufTtcblxuLyoqXG4gKiBJZGVudGlmeSBhIHVzZXIgd2l0aCBhIHVuaXF1ZSBJRCB0byB0cmFjayB1c2VyIGFjdGl2aXR5IGFjcm9zc1xuICogZGV2aWNlcywgdGllIGEgdXNlciB0byB0aGVpciBldmVudHMsIGFuZCBjcmVhdGUgYSB1c2VyIHByb2ZpbGUuXG4gKiBJZiB5b3UgbmV2ZXIgY2FsbCB0aGlzIG1ldGhvZCwgdW5pcXVlIHZpc2l0b3JzIGFyZSB0cmFja2VkIHVzaW5nXG4gKiBhIFVVSUQgZ2VuZXJhdGVkIHRoZSBmaXJzdCB0aW1lIHRoZXkgdmlzaXQgdGhlIHNpdGUuXG4gKlxuICogQ2FsbCBpZGVudGlmeSB3aGVuIHlvdSBrbm93IHRoZSBpZGVudGl0eSBvZiB0aGUgY3VycmVudCB1c2VyLFxuICogdHlwaWNhbGx5IGFmdGVyIGxvZ2luIG9yIHNpZ251cC4gV2UgcmVjb21tZW5kIGFnYWluc3QgdXNpbmdcbiAqIGlkZW50aWZ5IGZvciBhbm9ueW1vdXMgdmlzaXRvcnMgdG8geW91ciBzaXRlLlxuICpcbiAqICMjIyBOb3RlczpcbiAqIElmIHlvdXIgcHJvamVjdCBoYXNcbiAqIDxhIGhyZWY9XCJodHRwczovL2hlbHAubWl4cGFuZWwuY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAzOTEzMzg1MVwiPklEIE1lcmdlPC9hPlxuICogZW5hYmxlZCwgdGhlIGlkZW50aWZ5IG1ldGhvZCB3aWxsIGNvbm5lY3QgcHJlLSBhbmRcbiAqIHBvc3QtYXV0aGVudGljYXRpb24gZXZlbnRzIHdoZW4gYXBwcm9wcmlhdGUuXG4gKlxuICogSWYgeW91ciBwcm9qZWN0IGRvZXMgbm90IGhhdmUgSUQgTWVyZ2UgZW5hYmxlZCwgaWRlbnRpZnkgd2lsbFxuICogY2hhbmdlIHRoZSB1c2VyJ3MgbG9jYWwgZGlzdGluY3RfaWQgdG8gdGhlIHVuaXF1ZSBJRCB5b3UgcGFzcy5cbiAqIEV2ZW50cyB0cmFja2VkIHByaW9yIHRvIGF1dGhlbnRpY2F0aW9uIHdpbGwgbm90IGJlIGNvbm5lY3RlZFxuICogdG8gdGhlIHNhbWUgdXNlciBpZGVudGl0eS4gSWYgSUQgTWVyZ2UgaXMgZGlzYWJsZWQsIGFsaWFzIGNhblxuICogYmUgdXNlZCB0byBjb25uZWN0IHByZS0gYW5kIHBvc3QtcmVnaXN0cmF0aW9uIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3VuaXF1ZV9pZF0gQSBzdHJpbmcgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIGEgdXNlci4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZGlzdGluY3RfaWQgY3VycmVudGx5IGluIHRoZSBwZXJzaXN0ZW50IHN0b3JlIChjb29raWUgb3IgbG9jYWxTdG9yYWdlKSB3aWxsIGJlIHVzZWQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5pZGVudGlmeSA9IGZ1bmN0aW9uKFxuICAgIG5ld19kaXN0aW5jdF9pZCwgX3NldF9jYWxsYmFjaywgX2FkZF9jYWxsYmFjaywgX2FwcGVuZF9jYWxsYmFjaywgX3NldF9vbmNlX2NhbGxiYWNrLCBfdW5pb25fY2FsbGJhY2ssIF91bnNldF9jYWxsYmFjaywgX3JlbW92ZV9jYWxsYmFja1xuKSB7XG4gICAgLy8gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICAgIC8vICBfc2V0X2NhbGxiYWNrOmZ1bmN0aW9uICBBIGNhbGxiYWNrIHRvIGJlIHJ1biBpZiBhbmQgd2hlbiB0aGUgUGVvcGxlIHNldCBxdWV1ZSBpcyBmbHVzaGVkXG4gICAgLy8gIF9hZGRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgYWRkIHF1ZXVlIGlzIGZsdXNoZWRcbiAgICAvLyAgX2FwcGVuZF9jYWxsYmFjazpmdW5jdGlvbiAgQSBjYWxsYmFjayB0byBiZSBydW4gaWYgYW5kIHdoZW4gdGhlIFBlb3BsZSBhcHBlbmQgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfc2V0X29uY2VfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgc2V0X29uY2UgcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfdW5pb25fY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgdW5pb24gcXVldWUgaXMgZmx1c2hlZFxuICAgIC8vICBfdW5zZXRfY2FsbGJhY2s6ZnVuY3Rpb24gIEEgY2FsbGJhY2sgdG8gYmUgcnVuIGlmIGFuZCB3aGVuIHRoZSBQZW9wbGUgdW5zZXQgcXVldWUgaXMgZmx1c2hlZFxuXG4gICAgdmFyIHByZXZpb3VzX2Rpc3RpbmN0X2lkID0gdGhpcy5nZXRfZGlzdGluY3RfaWQoKTtcbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICYmIHByZXZpb3VzX2Rpc3RpbmN0X2lkICE9PSBuZXdfZGlzdGluY3RfaWQpIHtcbiAgICAgICAgLy8gd2UgYWxsb3cgdGhlIGZvbGxvd2luZyBjb25kaXRpb24gaWYgcHJldmlvdXMgZGlzdGluY3RfaWQgaXMgc2FtZSBhcyBuZXdfZGlzdGluY3RfaWRcbiAgICAgICAgLy8gc28gdGhhdCB5b3UgY2FuIGZvcmNlIGZsdXNoIHBlb3BsZSB1cGRhdGVzIGZvciBhbm9ueW1vdXMgcHJvZmlsZXMuXG4gICAgICAgIGlmICh0eXBlb2YgbmV3X2Rpc3RpbmN0X2lkID09PSAnc3RyaW5nJyAmJiBuZXdfZGlzdGluY3RfaWQuaW5kZXhPZihERVZJQ0VfSURfUFJFRklYKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ2Rpc3RpbmN0X2lkIGNhbm5vdCBoYXZlICRkZXZpY2U6IHByZWZpeCcpO1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVnaXN0ZXIoeyckdXNlcl9pZCc6IG5ld19kaXN0aW5jdF9pZH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRfcHJvcGVydHkoJyRkZXZpY2VfaWQnKSkge1xuICAgICAgICAvLyBUaGUgcGVyc2lzdGVkIGRpc3RpbmN0IGlkIG1pZ2h0IG5vdCBhY3R1YWxseSBiZSBhIGRldmljZSBpZCBhdCBhbGxcbiAgICAgICAgLy8gaXQgbWlnaHQgYmUgYSBkaXN0aW5jdCBpZCBvZiB0aGUgdXNlciBmcm9tIGJlZm9yZVxuICAgICAgICB2YXIgZGV2aWNlX2lkID0gcHJldmlvdXNfZGlzdGluY3RfaWQ7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICAgICAnJGhhZF9wZXJzaXN0ZWRfZGlzdGluY3RfaWQnOiB0cnVlLFxuICAgICAgICAgICAgJyRkZXZpY2VfaWQnOiBkZXZpY2VfaWRcbiAgICAgICAgfSwgJycpO1xuICAgIH1cblxuICAgIC8vIGlkZW50aWZ5IG9ubHkgY2hhbmdlcyB0aGUgZGlzdGluY3QgaWQgaWYgaXQgZG9lc24ndCBtYXRjaCBlaXRoZXIgdGhlIGV4aXN0aW5nIG9yIHRoZSBhbGlhcztcbiAgICAvLyBpZiBpdCdzIG5ldywgYmxvdyBhd2F5IHRoZSBhbGlhcyBhcyB3ZWxsLlxuICAgIGlmIChuZXdfZGlzdGluY3RfaWQgIT09IHByZXZpb3VzX2Rpc3RpbmN0X2lkICYmIG5ld19kaXN0aW5jdF9pZCAhPT0gdGhpcy5nZXRfcHJvcGVydHkoQUxJQVNfSURfS0VZKSkge1xuICAgICAgICB0aGlzLnVucmVnaXN0ZXIoQUxJQVNfSURfS0VZKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlcih7J2Rpc3RpbmN0X2lkJzogbmV3X2Rpc3RpbmN0X2lkfSk7XG4gICAgfVxuICAgIHRoaXMuX2ZsYWdzLmlkZW50aWZ5X2NhbGxlZCA9IHRydWU7XG4gICAgLy8gRmx1c2ggYW55IHF1ZXVlZCB1cCBwZW9wbGUgcmVxdWVzdHNcbiAgICB0aGlzWydwZW9wbGUnXS5fZmx1c2goX3NldF9jYWxsYmFjaywgX2FkZF9jYWxsYmFjaywgX2FwcGVuZF9jYWxsYmFjaywgX3NldF9vbmNlX2NhbGxiYWNrLCBfdW5pb25fY2FsbGJhY2ssIF91bnNldF9jYWxsYmFjaywgX3JlbW92ZV9jYWxsYmFjayk7XG5cbiAgICAvLyBzZW5kIGFuICRpZGVudGlmeSBldmVudCBhbnkgdGltZSB0aGUgZGlzdGluY3RfaWQgaXMgY2hhbmdpbmcgLSBsb2dpYyBvbiB0aGUgc2VydmVyXG4gICAgLy8gd2lsbCBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdG8gZG8gYW55dGhpbmcgd2l0aCBpdC5cbiAgICBpZiAobmV3X2Rpc3RpbmN0X2lkICE9PSBwcmV2aW91c19kaXN0aW5jdF9pZCkge1xuICAgICAgICB0aGlzLnRyYWNrKCckaWRlbnRpZnknLCB7XG4gICAgICAgICAgICAnZGlzdGluY3RfaWQnOiBuZXdfZGlzdGluY3RfaWQsXG4gICAgICAgICAgICAnJGFub25fZGlzdGluY3RfaWQnOiBwcmV2aW91c19kaXN0aW5jdF9pZFxuICAgICAgICB9LCB7c2tpcF9ob29rczogdHJ1ZX0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogQ2xlYXJzIHN1cGVyIHByb3BlcnRpZXMgYW5kIGdlbmVyYXRlcyBhIG5ldyByYW5kb20gZGlzdGluY3RfaWQgZm9yIHRoaXMgaW5zdGFuY2UuXG4gKiBVc2VmdWwgZm9yIGNsZWFyaW5nIGRhdGEgd2hlbiBhIHVzZXIgbG9ncyBvdXQuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10uY2xlYXIoKTtcbiAgICB0aGlzLl9mbGFncy5pZGVudGlmeV9jYWxsZWQgPSBmYWxzZTtcbiAgICB2YXIgdXVpZCA9IF8uVVVJRCgpO1xuICAgIHRoaXMucmVnaXN0ZXJfb25jZSh7XG4gICAgICAgICdkaXN0aW5jdF9pZCc6IERFVklDRV9JRF9QUkVGSVggKyB1dWlkLFxuICAgICAgICAnJGRldmljZV9pZCc6IHV1aWRcbiAgICB9LCAnJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgZGlzdGluY3QgaWQgb2YgdGhlIHVzZXIuIFRoaXMgaXMgZWl0aGVyIHRoZSBpZCBhdXRvbWF0aWNhbGx5XG4gKiBnZW5lcmF0ZWQgYnkgdGhlIGxpYnJhcnkgb3IgdGhlIGlkIHRoYXQgaGFzIGJlZW4gcGFzc2VkIGJ5IGEgY2FsbCB0byBpZGVudGlmeSgpLlxuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBnZXRfZGlzdGluY3RfaWQoKSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgdGhlIE1peHBhbmVsIGxpYnJhcnkgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gKiBpbml0KCkgaGFzIGEgbG9hZGVkIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBoYW5kbGUgdGhpcyBhdXRvbWF0aWNhbGx5LiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gc2V0IGRpc3RpbmN0X2lkIGFmdGVyIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGhhcyBsb2FkZWRcbiAqICAgICBtaXhwYW5lbC5pbml0KCdZT1VSIFBST0pFQ1QgVE9LRU4nLCB7XG4gKiAgICAgICAgIGxvYWRlZDogZnVuY3Rpb24obWl4cGFuZWwpIHtcbiAqICAgICAgICAgICAgIGRpc3RpbmN0X2lkID0gbWl4cGFuZWwuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gKiAgICAgICAgIH1cbiAqICAgICB9KTtcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9kaXN0aW5jdF9pZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldF9wcm9wZXJ0eSgnZGlzdGluY3RfaWQnKTtcbn07XG5cbi8qKlxuICogVGhlIGFsaWFzIG1ldGhvZCBjcmVhdGVzIGFuIGFsaWFzIHdoaWNoIE1peHBhbmVsIHdpbGwgdXNlIHRvXG4gKiByZW1hcCBvbmUgaWQgdG8gYW5vdGhlci4gTXVsdGlwbGUgYWxpYXNlcyBjYW4gcG9pbnQgdG8gdGhlXG4gKiBzYW1lIGlkZW50aWZpZXIuXG4gKlxuICogVGhlIGZvbGxvd2luZyBpcyBhIHZhbGlkIHVzZSBvZiBhbGlhczpcbiAqXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld19pZCcsICdleGlzdGluZ19pZCcpO1xuICogICAgIC8vIFlvdSBjYW4gYWRkIG11bHRpcGxlIGlkIGFsaWFzZXMgdG8gdGhlIGV4aXN0aW5nIElEXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld2VyX2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKlxuICogQWxpYXNlcyBjYW4gYWxzbyBiZSBjaGFpbmVkIC0gdGhlIGZvbGxvd2luZyBpcyBhIHZhbGlkIGV4YW1wbGU6XG4gKlxuICogICAgIG1peHBhbmVsLmFsaWFzKCduZXdfaWQnLCAnZXhpc3RpbmdfaWQnKTtcbiAqICAgICAvLyBjaGFpbiBuZXdlcl9pZCAtIG5ld19pZCAtIGV4aXN0aW5nX2lkXG4gKiAgICAgbWl4cGFuZWwuYWxpYXMoJ25ld2VyX2lkJywgJ25ld19pZCcpO1xuICpcbiAqIEFsaWFzZXMgY2Fubm90IHBvaW50IHRvIG11bHRpcGxlIGlkZW50aWZpZXJzIC0gdGhlIGZvbGxvd2luZ1xuICogZXhhbXBsZSB3aWxsIG5vdCB3b3JrOlxuICpcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ2V4aXN0aW5nX2lkJyk7XG4gKiAgICAgLy8gdGhpcyBpcyBpbnZhbGlkIGFzICduZXdfaWQnIGFscmVhZHkgcG9pbnRzIHRvICdleGlzdGluZ19pZCdcbiAqICAgICBtaXhwYW5lbC5hbGlhcygnbmV3X2lkJywgJ25ld2VyX2lkJyk7XG4gKlxuICogIyMjIE5vdGVzOlxuICpcbiAqIElmIHlvdXIgcHJvamVjdCBkb2VzIG5vdCBoYXZlXG4gKiA8YSBocmVmPVwiaHR0cHM6Ly9oZWxwLm1peHBhbmVsLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMzkxMzM4NTFcIj5JRCBNZXJnZTwvYT5cbiAqIGVuYWJsZWQsIHRoZSBiZXN0IHByYWN0aWNlIGlzIHRvIGNhbGwgYWxpYXMgb25jZSB3aGVuIGEgdW5pcXVlXG4gKiBJRCBpcyBmaXJzdCBjcmVhdGVkIGZvciBhIHVzZXIgKGUuZy4sIHdoZW4gYSB1c2VyIGZpcnN0IHJlZ2lzdGVyc1xuICogZm9yIGFuIGFjY291bnQpLiBEbyBub3QgdXNlIGFsaWFzIG11bHRpcGxlIHRpbWVzIGZvciBhIHNpbmdsZVxuICogdXNlciB3aXRob3V0IElEIE1lcmdlIGVuYWJsZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFsaWFzIEEgdW5pcXVlIGlkZW50aWZpZXIgdGhhdCB5b3Ugd2FudCB0byB1c2UgZm9yIHRoaXMgdXNlciBpbiB0aGUgZnV0dXJlLlxuICogQHBhcmFtIHtTdHJpbmd9IFtvcmlnaW5hbF0gVGhlIGN1cnJlbnQgaWRlbnRpZmllciBiZWluZyB1c2VkIGZvciB0aGlzIHVzZXIuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5hbGlhcyA9IGZ1bmN0aW9uKGFsaWFzLCBvcmlnaW5hbCkge1xuICAgIC8vIElmIHRoZSAkcGVvcGxlX2Rpc3RpbmN0X2lkIGtleSBleGlzdHMgaW4gcGVyc2lzdGVuY2UsIHRoZXJlIGhhcyBiZWVuIGEgcHJldmlvdXNcbiAgICAvLyBtaXhwYW5lbC5wZW9wbGUuaWRlbnRpZnkoKSBjYWxsIG1hZGUgZm9yIHRoaXMgdXNlci4gSXQgaXMgVkVSWSBCQUQgdG8gbWFrZSBhbiBhbGlhcyB3aXRoXG4gICAgLy8gdGhpcyBJRCwgYXMgaXQgd2lsbCBkdXBsaWNhdGUgdXNlcnMuXG4gICAgaWYgKGFsaWFzID09PSB0aGlzLmdldF9wcm9wZXJ0eShQRU9QTEVfRElTVElOQ1RfSURfS0VZKSkge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcignQXR0ZW1wdGluZyB0byBjcmVhdGUgYWxpYXMgZm9yIGV4aXN0aW5nIFBlb3BsZSB1c2VyIC0gYWJvcnRpbmcuJyk7XG4gICAgICAgIHJldHVybiAtMjtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmIChfLmlzVW5kZWZpbmVkKG9yaWdpbmFsKSkge1xuICAgICAgICBvcmlnaW5hbCA9IHRoaXMuZ2V0X2Rpc3RpbmN0X2lkKCk7XG4gICAgfVxuICAgIGlmIChhbGlhcyAhPT0gb3JpZ2luYWwpIHtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJfc2luZ2xlKEFMSUFTX0lEX0tFWSwgYWxpYXMpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFjaygnJGNyZWF0ZV9hbGlhcycsIHtcbiAgICAgICAgICAgICdhbGlhcyc6IGFsaWFzLFxuICAgICAgICAgICAgJ2Rpc3RpbmN0X2lkJzogb3JpZ2luYWxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgc2tpcF9ob29rczogdHJ1ZVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIEZsdXNoIHRoZSBwZW9wbGUgcXVldWVcbiAgICAgICAgICAgIF90aGlzLmlkZW50aWZ5KGFsaWFzKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXBvcnRfZXJyb3IoJ2FsaWFzIG1hdGNoZXMgY3VycmVudCBkaXN0aW5jdF9pZCAtIHNraXBwaW5nIGFwaSBjYWxsLicpO1xuICAgICAgICB0aGlzLmlkZW50aWZ5KGFsaWFzKTtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJvdmlkZSBhIHN0cmluZyB0byByZWNvZ25pemUgdGhlIHVzZXIgYnkuIFRoZSBzdHJpbmcgcGFzc2VkIHRvXG4gKiB0aGlzIG1ldGhvZCB3aWxsIGFwcGVhciBpbiB0aGUgTWl4cGFuZWwgU3RyZWFtcyBwcm9kdWN0IHJhdGhlclxuICogdGhhbiBhbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBuYW1lLiBOYW1lIHRhZ3MgZG8gbm90IGhhdmUgdG9cbiAqIGJlIHVuaXF1ZS5cbiAqXG4gKiBUaGlzIHZhbHVlIHdpbGwgb25seSBiZSBpbmNsdWRlZCBpbiBTdHJlYW1zIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVfdGFnIEEgaHVtYW4gcmVhZGFibGUgbmFtZSBmb3IgdGhlIHVzZXJcbiAqIEBkZXByZWNhdGVkXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5uYW1lX3RhZyA9IGZ1bmN0aW9uKG5hbWVfdGFnKSB7XG4gICAgdGhpcy5fcmVnaXN0ZXJfc2luZ2xlKCdtcF9uYW1lX3RhZycsIG5hbWVfdGFnKTtcbn07XG5cbi8qKlxuICogVXBkYXRlIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgbWl4cGFuZWwgbGlicmFyeSBpbnN0YW5jZS5cbiAqXG4gKiBUaGUgZGVmYXVsdCBjb25maWcgaXM6XG4gKlxuICogICAgIHtcbiAqICAgICAgIC8vIGhvc3QgZm9yIHJlcXVlc3RzIChjdXN0b21pemFibGUgZm9yIGUuZy4gYSBsb2NhbCBwcm94eSlcbiAqICAgICAgIGFwaV9ob3N0OiAnaHR0cHM6Ly9hcGktanMubWl4cGFuZWwuY29tJyxcbiAqXG4gKiAgICAgICAvLyBlbmRwb2ludHMgZm9yIGRpZmZlcmVudCB0eXBlcyBvZiByZXF1ZXN0c1xuICogICAgICAgYXBpX3JvdXRlczoge1xuICogICAgICAgICB0cmFjazogJ3RyYWNrLycsXG4gKiAgICAgICAgIGVuZ2FnZTogJ2VuZ2FnZS8nLFxuICogICAgICAgICBncm91cHM6ICdncm91cHMvJyxcbiAqICAgICAgIH1cbiAqXG4gKiAgICAgICAvLyBIVFRQIG1ldGhvZCBmb3IgdHJhY2tpbmcgcmVxdWVzdHNcbiAqICAgICAgIGFwaV9tZXRob2Q6ICdQT1NUJ1xuICpcbiAqICAgICAgIC8vIHRyYW5zcG9ydCBmb3Igc2VuZGluZyByZXF1ZXN0cyAoJ1hIUicgb3IgJ3NlbmRCZWFjb24nKVxuICogICAgICAgLy8gTkI6IHNlbmRCZWFjb24gc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3Igc2NlbmFyaW9zIHN1Y2ggYXNcbiAqICAgICAgIC8vIHBhZ2UgdW5sb2FkIHdoZXJlIGEgXCJiZXN0LWVmZm9ydFwiIGF0dGVtcHQgdG8gc2VuZCBpc1xuICogICAgICAgLy8gYWNjZXB0YWJsZTsgdGhlIHNlbmRCZWFjb24gQVBJIGRvZXMgbm90IHN1cHBvcnQgY2FsbGJhY2tzXG4gKiAgICAgICAvLyBvciBhbnkgd2F5IHRvIGtub3cgdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdC4gTWl4cGFuZWxcbiAqICAgICAgIC8vIHRyYWNraW5nIHZpYSBzZW5kQmVhY29uIHdpbGwgbm90IHN1cHBvcnQgYW55IGV2ZW50LVxuICogICAgICAgLy8gYmF0Y2hpbmcgb3IgcmV0cnkgbWVjaGFuaXNtcy5cbiAqICAgICAgIGFwaV90cmFuc3BvcnQ6ICdYSFInXG4gKlxuICogICAgICAgLy8gcmVxdWVzdC1iYXRjaGluZy9xdWV1ZWluZy9yZXRyeVxuICogICAgICAgYmF0Y2hfcmVxdWVzdHM6IHRydWUsXG4gKlxuICogICAgICAgLy8gbWF4aW11bSBudW1iZXIgb2YgZXZlbnRzL3VwZGF0ZXMgdG8gc2VuZCBpbiBhIHNpbmdsZVxuICogICAgICAgLy8gbmV0d29yayByZXF1ZXN0XG4gKiAgICAgICBiYXRjaF9zaXplOiA1MCxcbiAqXG4gKiAgICAgICAvLyBtaWxsaXNlY29uZHMgdG8gd2FpdCBiZXR3ZWVuIHNlbmRpbmcgYmF0Y2ggcmVxdWVzdHNcbiAqICAgICAgIGJhdGNoX2ZsdXNoX2ludGVydmFsX21zOiA1MDAwLFxuICpcbiAqICAgICAgIC8vIG1pbGxpc2Vjb25kcyB0byB3YWl0IGZvciBuZXR3b3JrIHJlc3BvbnNlcyB0byBiYXRjaCByZXF1ZXN0c1xuICogICAgICAgLy8gYmVmb3JlIHRoZXkgYXJlIGNvbnNpZGVyZWQgdGltZWQtb3V0IGFuZCByZXRyaWVkXG4gKiAgICAgICBiYXRjaF9yZXF1ZXN0X3RpbWVvdXRfbXM6IDkwMDAwLFxuICpcbiAqICAgICAgIC8vIG92ZXJyaWRlIHZhbHVlIGZvciBjb29raWUgZG9tYWluLCBvbmx5IHVzZWZ1bCBmb3IgZW5zdXJpbmdcbiAqICAgICAgIC8vIGNvcnJlY3QgY3Jvc3Mtc3ViZG9tYWluIGNvb2tpZXMgb24gdW51c3VhbCBkb21haW5zIGxpa2VcbiAqICAgICAgIC8vIHN1YmRvbWFpbi5tYWluc2l0ZS5hdm9jYXQuZnI7IE5CIHRoaXMgY2Fubm90IGJlIHVzZWQgdG9cbiAqICAgICAgIC8vIHNldCBjb29raWVzIG9uIGEgZGlmZmVyZW50IGRvbWFpbiB0aGFuIHRoZSBjdXJyZW50IG9yaWdpblxuICogICAgICAgY29va2llX2RvbWFpbjogJydcbiAqXG4gKiAgICAgICAvLyBzdXBlciBwcm9wZXJ0aWVzIGNvb2tpZSBleHBpcmF0aW9uIChpbiBkYXlzKVxuICogICAgICAgY29va2llX2V4cGlyYXRpb246IDM2NVxuICpcbiAqICAgICAgIC8vIGlmIHRydWUsIGNvb2tpZSB3aWxsIGJlIHNldCB3aXRoIFNhbWVTaXRlPU5vbmU7IFNlY3VyZVxuICogICAgICAgLy8gdGhpcyBpcyBvbmx5IHVzZWZ1bCBpbiBzcGVjaWFsIHNpdHVhdGlvbnMsIGxpa2UgZW1iZWRkZWRcbiAqICAgICAgIC8vIDNyZC1wYXJ0eSBpZnJhbWVzIHRoYXQgc2V0IHVwIGEgTWl4cGFuZWwgaW5zdGFuY2VcbiAqICAgICAgIGNyb3NzX3NpdGVfY29va2llOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIHN1cGVyIHByb3BlcnRpZXMgc3BhbiBzdWJkb21haW5zXG4gKiAgICAgICBjcm9zc19zdWJkb21haW5fY29va2llOiB0cnVlXG4gKlxuICogICAgICAgLy8gZGVidWcgbW9kZVxuICogICAgICAgZGVidWc6IGZhbHNlXG4gKlxuICogICAgICAgLy8gaWYgdGhpcyBpcyB0cnVlLCB0aGUgbWl4cGFuZWwgY29va2llIG9yIGxvY2FsU3RvcmFnZSBlbnRyeVxuICogICAgICAgLy8gd2lsbCBiZSBkZWxldGVkLCBhbmQgbm8gdXNlciBwZXJzaXN0ZW5jZSB3aWxsIHRha2UgcGxhY2VcbiAqICAgICAgIGRpc2FibGVfcGVyc2lzdGVuY2U6IGZhbHNlXG4gKlxuICogICAgICAgLy8gaWYgdGhpcyBpcyB0cnVlLCBNaXhwYW5lbCB3aWxsIGF1dG9tYXRpY2FsbHkgZGV0ZXJtaW5lXG4gKiAgICAgICAvLyBDaXR5LCBSZWdpb24gYW5kIENvdW50cnkgZGF0YSB1c2luZyB0aGUgSVAgYWRkcmVzcyBvZlxuICogICAgICAgLy90aGUgY2xpZW50XG4gKiAgICAgICBpcDogdHJ1ZVxuICpcbiAqICAgICAgIC8vIG9wdCB1c2VycyBvdXQgb2YgdHJhY2tpbmcgYnkgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSBieSBkZWZhdWx0XG4gKiAgICAgICBvcHRfb3V0X3RyYWNraW5nX2J5X2RlZmF1bHQ6IGZhbHNlXG4gKlxuICogICAgICAgLy8gb3B0IHVzZXJzIG91dCBvZiBicm93c2VyIGRhdGEgc3RvcmFnZSBieSB0aGlzIE1peHBhbmVsIGluc3RhbmNlIGJ5IGRlZmF1bHRcbiAqICAgICAgIG9wdF9vdXRfcGVyc2lzdGVuY2VfYnlfZGVmYXVsdDogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBwZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCBieSBvcHQtaW4vb3B0LW91dCBtZXRob2RzIC0gY29va2llXG4gKiAgICAgICAvLyBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqICAgICAgIG9wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZTogJ2xvY2FsU3RvcmFnZSdcbiAqXG4gKiAgICAgICAvLyBjdXN0b21pemUgdGhlIG5hbWUgb2YgY29va2llL2xvY2FsU3RvcmFnZSBzZXQgYnkgb3B0LWluL29wdC1vdXQgbWV0aG9kc1xuICogICAgICAgb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4OiBudWxsXG4gKlxuICogICAgICAgLy8gdHlwZSBvZiBwZXJzaXN0ZW50IHN0b3JlIGZvciBzdXBlciBwcm9wZXJ0aWVzIChjb29raWUvXG4gKiAgICAgICAvLyBsb2NhbFN0b3JhZ2UpIGlmIHNldCB0byAnbG9jYWxTdG9yYWdlJywgYW55IGV4aXN0aW5nXG4gKiAgICAgICAvLyBtaXhwYW5lbCBjb29raWUgdmFsdWUgd2l0aCB0aGUgc2FtZSBwZXJzaXN0ZW5jZV9uYW1lXG4gKiAgICAgICAvLyB3aWxsIGJlIHRyYW5zZmVycmVkIHRvIGxvY2FsU3RvcmFnZSBhbmQgZGVsZXRlZFxuICogICAgICAgcGVyc2lzdGVuY2U6ICdjb29raWUnXG4gKlxuICogICAgICAgLy8gbmFtZSBmb3Igc3VwZXIgcHJvcGVydGllcyBwZXJzaXN0ZW50IHN0b3JlXG4gKiAgICAgICBwZXJzaXN0ZW5jZV9uYW1lOiAnJ1xuICpcbiAqICAgICAgIC8vIG5hbWVzIG9mIHByb3BlcnRpZXMvc3VwZXJwcm9wZXJ0aWVzIHdoaWNoIHNob3VsZCBuZXZlclxuICogICAgICAgLy8gYmUgc2VudCB3aXRoIHRyYWNrKCkgY2FsbHNcbiAqICAgICAgIHByb3BlcnR5X2JsYWNrbGlzdDogW11cbiAqXG4gKiAgICAgICAvLyBpZiB0aGlzIGlzIHRydWUsIG1peHBhbmVsIGNvb2tpZXMgd2lsbCBiZSBtYXJrZWQgYXNcbiAqICAgICAgIC8vIHNlY3VyZSwgbWVhbmluZyB0aGV5IHdpbGwgb25seSBiZSB0cmFuc21pdHRlZCBvdmVyIGh0dHBzXG4gKiAgICAgICBzZWN1cmVfY29va2llOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIGRpc2FibGVzIGVucmljaGluZyB1c2VyIHByb2ZpbGVzIHdpdGggZmlyc3QgdG91Y2ggbWFya2V0aW5nIGRhdGFcbiAqICAgICAgIHNraXBfZmlyc3RfdG91Y2hfbWFya2V0aW5nOiBmYWxzZVxuICpcbiAqICAgICAgIC8vIHRoZSBhbW91bnQgb2YgdGltZSB0cmFja19saW5rcyB3aWxsXG4gKiAgICAgICAvLyB3YWl0IGZvciBNaXhwYW5lbCdzIHNlcnZlcnMgdG8gcmVzcG9uZFxuICogICAgICAgdHJhY2tfbGlua3NfdGltZW91dDogMzAwXG4gKlxuICogICAgICAgLy8gYWRkcyBhbnkgVVRNIHBhcmFtZXRlcnMgYW5kIGNsaWNrIElEcyBwcmVzZW50IG9uIHRoZSBwYWdlIHRvIGFueSBldmVudHMgZmlyZWRcbiAqICAgICAgIHRyYWNrX21hcmtldGluZzogdHJ1ZVxuICpcbiAqICAgICAgIC8vIGVuYWJsZXMgYXV0b21hdGljIHBhZ2UgdmlldyB0cmFja2luZyB1c2luZyBkZWZhdWx0IHBhZ2UgdmlldyBldmVudHMgdGhyb3VnaFxuICogICAgICAgLy8gdGhlIHRyYWNrX3BhZ2V2aWV3KCkgbWV0aG9kXG4gKiAgICAgICB0cmFja19wYWdldmlldzogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBpZiB5b3Ugc2V0IHVwZ3JhZGUgdG8gYmUgdHJ1ZSwgdGhlIGxpYnJhcnkgd2lsbCBjaGVjayBmb3JcbiAqICAgICAgIC8vIGEgY29va2llIGZyb20gb3VyIG9sZCBqcyBsaWJyYXJ5IGFuZCBpbXBvcnQgc3VwZXJcbiAqICAgICAgIC8vIHByb3BlcnRpZXMgZnJvbSBpdCwgdGhlbiB0aGUgb2xkIGNvb2tpZSBpcyBkZWxldGVkXG4gKiAgICAgICAvLyBUaGUgdXBncmFkZSBjb25maWcgb3B0aW9uIG9ubHkgd29ya3MgaW4gdGhlIGluaXRpYWxpemF0aW9uLFxuICogICAgICAgLy8gc28gbWFrZSBzdXJlIHlvdSBzZXQgaXQgd2hlbiB5b3UgY3JlYXRlIHRoZSBsaWJyYXJ5LlxuICogICAgICAgdXBncmFkZTogZmFsc2VcbiAqXG4gKiAgICAgICAvLyBleHRyYSBIVFRQIHJlcXVlc3QgaGVhZGVycyB0byBzZXQgZm9yIGVhY2ggQVBJIHJlcXVlc3QsIGluXG4gKiAgICAgICAvLyB0aGUgZm9ybWF0IHsnSGVhZGVyLU5hbWUnOiB2YWx1ZX1cbiAqICAgICAgIHhocl9oZWFkZXJzOiB7fVxuICpcbiAqICAgICAgIC8vIHdoZXRoZXIgdG8gaWdub3JlIG9yIHJlc3BlY3QgdGhlIHdlYiBicm93c2VyJ3MgRG8gTm90IFRyYWNrIHNldHRpbmdcbiAqICAgICAgIGlnbm9yZV9kbnQ6IGZhbHNlXG4gKiAgICAgfVxuICpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIEEgZGljdGlvbmFyeSBvZiBuZXcgY29uZmlndXJhdGlvbiB2YWx1ZXMgdG8gdXBkYXRlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfY29uZmlnID0gZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgaWYgKF8uaXNPYmplY3QoY29uZmlnKSkge1xuICAgICAgICBfLmV4dGVuZCh0aGlzWydjb25maWcnXSwgY29uZmlnKTtcblxuICAgICAgICB2YXIgbmV3X2JhdGNoX3NpemUgPSBjb25maWdbJ2JhdGNoX3NpemUnXTtcbiAgICAgICAgaWYgKG5ld19iYXRjaF9zaXplKSB7XG4gICAgICAgICAgICBfLmVhY2godGhpcy5yZXF1ZXN0X2JhdGNoZXJzLCBmdW5jdGlvbihiYXRjaGVyKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlci5yZXNldEJhdGNoU2l6ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuZ2V0X2NvbmZpZygncGVyc2lzdGVuY2VfbmFtZScpKSB7XG4gICAgICAgICAgICB0aGlzWydjb25maWcnXVsncGVyc2lzdGVuY2VfbmFtZSddID0gdGhpc1snY29uZmlnJ11bJ2Nvb2tpZV9uYW1lJ107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmdldF9jb25maWcoJ2Rpc2FibGVfcGVyc2lzdGVuY2UnKSkge1xuICAgICAgICAgICAgdGhpc1snY29uZmlnJ11bJ2Rpc2FibGVfcGVyc2lzdGVuY2UnXSA9IHRoaXNbJ2NvbmZpZyddWydkaXNhYmxlX2Nvb2tpZSddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXNbJ3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10udXBkYXRlX2NvbmZpZyh0aGlzWydjb25maWcnXSk7XG4gICAgICAgIH1cbiAgICAgICAgQ29uZmlnLkRFQlVHID0gQ29uZmlnLkRFQlVHIHx8IHRoaXMuZ2V0X2NvbmZpZygnZGVidWcnKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIHJldHVybnMgdGhlIGN1cnJlbnQgY29uZmlnIG9iamVjdCBmb3IgdGhlIGxpYnJhcnkuXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfY29uZmlnID0gZnVuY3Rpb24ocHJvcF9uYW1lKSB7XG4gICAgcmV0dXJuIHRoaXNbJ2NvbmZpZyddW3Byb3BfbmFtZV07XG59O1xuXG4vKipcbiAqIEZldGNoIGEgaG9vayBmdW5jdGlvbiBmcm9tIGNvbmZpZywgd2l0aCBzYWZlIGRlZmF1bHQsIGFuZCBydW4gaXRcbiAqIGFnYWluc3QgdGhlIGdpdmVuIGFyZ3VtZW50c1xuICogQHBhcmFtIHtzdHJpbmd9IGhvb2tfbmFtZSB3aGljaCBob29rIHRvIHJldHJpZXZlXG4gKiBAcmV0dXJucyB7YW55fG51bGx9IHJldHVybiB2YWx1ZSBvZiB1c2VyLXByb3ZpZGVkIGhvb2ssIG9yIG51bGwgaWYgbm90aGluZyB3YXMgcmV0dXJuZWRcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLl9ydW5faG9vayA9IGZ1bmN0aW9uKGhvb2tfbmFtZSkge1xuICAgIHZhciByZXQgPSAodGhpc1snY29uZmlnJ11bJ2hvb2tzJ11baG9va19uYW1lXSB8fCBJREVOVElUWV9GVU5DKS5hcHBseSh0aGlzLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICh0eXBlb2YgcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLnJlcG9ydF9lcnJvcihob29rX25hbWUgKyAnIGhvb2sgZGlkIG5vdCByZXR1cm4gYSB2YWx1ZScpO1xuICAgICAgICByZXQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgc3VwZXIgcHJvcGVydHkgbmFtZWQgcHJvcGVydHlfbmFtZS4gSWYgbm8gc3VjaFxuICogcHJvcGVydHkgaXMgc2V0LCBnZXRfcHJvcGVydHkoKSB3aWxsIHJldHVybiB0aGUgdW5kZWZpbmVkIHZhbHVlLlxuICpcbiAqICMjIyBOb3RlczpcbiAqXG4gKiBnZXRfcHJvcGVydHkoKSBjYW4gb25seSBiZSBjYWxsZWQgYWZ0ZXIgdGhlIE1peHBhbmVsIGxpYnJhcnkgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gKiBpbml0KCkgaGFzIGEgbG9hZGVkIGZ1bmN0aW9uIGF2YWlsYWJsZSB0byBoYW5kbGUgdGhpcyBhdXRvbWF0aWNhbGx5LiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gZ3JhYiB2YWx1ZSBmb3IgJ3VzZXJfaWQnIGFmdGVyIHRoZSBtaXhwYW5lbCBsaWJyYXJ5IGhhcyBsb2FkZWRcbiAqICAgICBtaXhwYW5lbC5pbml0KCdZT1VSIFBST0pFQ1QgVE9LRU4nLCB7XG4gKiAgICAgICAgIGxvYWRlZDogZnVuY3Rpb24obWl4cGFuZWwpIHtcbiAqICAgICAgICAgICAgIHVzZXJfaWQgPSBtaXhwYW5lbC5nZXRfcHJvcGVydHkoJ3VzZXJfaWQnKTtcbiAqICAgICAgICAgfVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eV9uYW1lIFRoZSBuYW1lIG9mIHRoZSBzdXBlciBwcm9wZXJ0eSB5b3Ugd2FudCB0byByZXRyaWV2ZVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Byb3BlcnR5ID0gZnVuY3Rpb24ocHJvcGVydHlfbmFtZSkge1xuICAgIHJldHVybiB0aGlzWydwZXJzaXN0ZW5jZSddLmxvYWRfcHJvcChbcHJvcGVydHlfbmFtZV0pO1xufTtcblxuTWl4cGFuZWxMaWIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hbWUgPSB0aGlzLmdldF9jb25maWcoJ25hbWUnKTtcbiAgICBpZiAobmFtZSAhPT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7XG4gICAgICAgIG5hbWUgPSBQUklNQVJZX0lOU1RBTkNFX05BTUUgKyAnLicgKyBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn07XG5cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZXZlbnRfaXNfZGlzYWJsZWQgPSBmdW5jdGlvbihldmVudF9uYW1lKSB7XG4gICAgcmV0dXJuIF8uaXNCbG9ja2VkVUEodXNlckFnZW50KSB8fFxuICAgICAgICB0aGlzLl9mbGFncy5kaXNhYmxlX2FsbF9ldmVudHMgfHxcbiAgICAgICAgXy5pbmNsdWRlKHRoaXMuX19kaXNhYmxlZF9ldmVudHMsIGV2ZW50X25hbWUpO1xufTtcblxuLy8gcGVyZm9ybSBzb21lIGhvdXNla2VlcGluZyBhcm91bmQgR0RQUiBvcHQtaW4vb3V0IHN0YXRlXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc19sb2NhbFN0b3JhZ2VfcmVxdWVzdGVkID0gdGhpcy5nZXRfY29uZmlnKCdvcHRfb3V0X3RyYWNraW5nX3BlcnNpc3RlbmNlX3R5cGUnKSA9PT0gJ2xvY2FsU3RvcmFnZSc7XG5cbiAgICAvLyB0cnkgdG8gY29udmVydCBvcHQtaW4vb3V0IGNvb2tpZXMgdG8gbG9jYWxTdG9yYWdlIGlmIHBvc3NpYmxlXG4gICAgaWYgKGlzX2xvY2FsU3RvcmFnZV9yZXF1ZXN0ZWQgJiYgXy5sb2NhbFN0b3JhZ2UuaXNfc3VwcG9ydGVkKCkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc19vcHRlZF9pbl90cmFja2luZygpICYmIHRoaXMuaGFzX29wdGVkX2luX3RyYWNraW5nKHsncGVyc2lzdGVuY2VfdHlwZSc6ICdjb29raWUnfSkpIHtcbiAgICAgICAgICAgIHRoaXMub3B0X2luX3RyYWNraW5nKHsnZW5hYmxlX3BlcnNpc3RlbmNlJzogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpICYmIHRoaXMuaGFzX29wdGVkX291dF90cmFja2luZyh7J3BlcnNpc3RlbmNlX3R5cGUnOiAnY29va2llJ30pKSB7XG4gICAgICAgICAgICB0aGlzLm9wdF9vdXRfdHJhY2tpbmcoeydjbGVhcl9wZXJzaXN0ZW5jZSc6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhcl9vcHRfaW5fb3V0X3RyYWNraW5nKHtcbiAgICAgICAgICAgICdwZXJzaXN0ZW5jZV90eXBlJzogJ2Nvb2tpZScsXG4gICAgICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gY2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgYWxyZWFkeSBvcHRlZCBvdXQgLSBpZiBzbywgY2xlYXIgJiBkaXNhYmxlIHBlcnNpc3RlbmNlXG4gICAgaWYgKHRoaXMuaGFzX29wdGVkX291dF90cmFja2luZygpKSB7XG4gICAgICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKHsnY2xlYXJfcGVyc2lzdGVuY2UnOiB0cnVlfSk7XG5cbiAgICAvLyBjaGVjayB3aGV0aGVyIHdlIHNob3VsZCBvcHQgb3V0IGJ5IGRlZmF1bHRcbiAgICAvLyBub3RlOiB3ZSBkb24ndCBjbGVhciBwZXJzaXN0ZW5jZSBoZXJlIGJ5IGRlZmF1bHQgc2luY2Ugb3B0LW91dCBkZWZhdWx0IHN0YXRlIGlzIG9mdGVuXG4gICAgLy8gICAgICAgdXNlZCBhcyBhbiBpbml0aWFsIHN0YXRlIHdoaWxlIEdEUFIgaW5mb3JtYXRpb24gaXMgYmVpbmcgY29sbGVjdGVkXG4gICAgfSBlbHNlIGlmICghdGhpcy5oYXNfb3B0ZWRfaW5fdHJhY2tpbmcoKSAmJiAoXG4gICAgICAgIHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19ieV9kZWZhdWx0JykgfHwgXy5jb29raWUuZ2V0KCdtcF9vcHRvdXQnKVxuICAgICkpIHtcbiAgICAgICAgXy5jb29raWUucmVtb3ZlKCdtcF9vcHRvdXQnKTtcbiAgICAgICAgdGhpcy5vcHRfb3V0X3RyYWNraW5nKHtcbiAgICAgICAgICAgICdjbGVhcl9wZXJzaXN0ZW5jZSc6IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF9wZXJzaXN0ZW5jZV9ieV9kZWZhdWx0JylcbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBFbmFibGUgb3IgZGlzYWJsZSBwZXJzaXN0ZW5jZSBiYXNlZCBvbiBvcHRpb25zXG4gKiBvbmx5IGVuYWJsZS9kaXNhYmxlIGlmIHBlcnNpc3RlbmNlIGlzIG5vdCBhbHJlYWR5IGluIHRoaXMgc3RhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2xlYXJfcGVyc2lzdGVuY2VdIElmIHRydWUsIHdpbGwgZGVsZXRlIGFsbCBkYXRhIHN0b3JlZCBieSB0aGUgc2RrIGluIHBlcnNpc3RlbmNlIGFuZCBkaXNhYmxlIGl0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZV9wZXJzaXN0ZW5jZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIGRpc2FibGVkO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnNbJ2NsZWFyX3BlcnNpc3RlbmNlJ10pIHtcbiAgICAgICAgZGlzYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucyAmJiBvcHRpb25zWydlbmFibGVfcGVyc2lzdGVuY2UnXSkge1xuICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0X2NvbmZpZygnZGlzYWJsZV9wZXJzaXN0ZW5jZScpICYmIHRoaXNbJ3BlcnNpc3RlbmNlJ10uZGlzYWJsZWQgIT09IGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXNbJ3BlcnNpc3RlbmNlJ10uc2V0X2Rpc2FibGVkKGRpc2FibGVkKTtcbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgdGhpcy5zdG9wX2JhdGNoX3NlbmRlcnMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBvbmx5IHN0YXJ0IGJhdGNoZXJzIGFmdGVyIG9wdC1pbiBpZiB0aGV5IGhhdmUgcHJldmlvdXNseSBiZWVuIHN0YXJ0ZWRcbiAgICAgICAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgdW5pbnRlbnRpb25hbGx5IHN0YXJ0aW5nIHVwIGJhdGNoaW5nIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICBpZiAodGhpcy5fYmF0Y2hlcnNfd2VyZV9zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0X2JhdGNoX3NlbmRlcnMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIGNhbGwgYSBiYXNlIGdkcHIgZnVuY3Rpb24gYWZ0ZXIgY29uc3RydWN0aW5nIHRoZSBhcHByb3ByaWF0ZSB0b2tlbiBhbmQgb3B0aW9ucyBhcmdzXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuX2dkcHJfY2FsbF9mdW5jID0gZnVuY3Rpb24oZnVuYywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICd0cmFjayc6IF8uYmluZCh0aGlzLnRyYWNrLCB0aGlzKSxcbiAgICAgICAgJ3BlcnNpc3RlbmNlX3R5cGUnOiB0aGlzLmdldF9jb25maWcoJ29wdF9vdXRfdHJhY2tpbmdfcGVyc2lzdGVuY2VfdHlwZScpLFxuICAgICAgICAnY29va2llX3ByZWZpeCc6IHRoaXMuZ2V0X2NvbmZpZygnb3B0X291dF90cmFja2luZ19jb29raWVfcHJlZml4JyksXG4gICAgICAgICdjb29raWVfZXhwaXJhdGlvbic6IHRoaXMuZ2V0X2NvbmZpZygnY29va2llX2V4cGlyYXRpb24nKSxcbiAgICAgICAgJ2Nyb3NzX3NpdGVfY29va2llJzogdGhpcy5nZXRfY29uZmlnKCdjcm9zc19zaXRlX2Nvb2tpZScpLFxuICAgICAgICAnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZScpLFxuICAgICAgICAnY29va2llX2RvbWFpbic6IHRoaXMuZ2V0X2NvbmZpZygnY29va2llX2RvbWFpbicpLFxuICAgICAgICAnc2VjdXJlX2Nvb2tpZSc6IHRoaXMuZ2V0X2NvbmZpZygnc2VjdXJlX2Nvb2tpZScpLFxuICAgICAgICAnaWdub3JlX2RudCc6IHRoaXMuZ2V0X2NvbmZpZygnaWdub3JlX2RudCcpXG4gICAgfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBpZiBsb2NhbFN0b3JhZ2UgY2FuIGJlIHVzZWQgZm9yIHJlY29yZGluZyBvcHQgb3V0IHN0YXR1cywgZmFsbCBiYWNrIHRvIGNvb2tpZSBpZiBub3RcbiAgICBpZiAoIV8ubG9jYWxTdG9yYWdlLmlzX3N1cHBvcnRlZCgpKSB7XG4gICAgICAgIG9wdGlvbnNbJ3BlcnNpc3RlbmNlX3R5cGUnXSA9ICdjb29raWUnO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jKHRoaXMuZ2V0X2NvbmZpZygndG9rZW4nKSwge1xuICAgICAgICB0cmFjazogb3B0aW9uc1sndHJhY2snXSxcbiAgICAgICAgdHJhY2tFdmVudE5hbWU6IG9wdGlvbnNbJ3RyYWNrX2V2ZW50X25hbWUnXSxcbiAgICAgICAgdHJhY2tQcm9wZXJ0aWVzOiBvcHRpb25zWyd0cmFja19wcm9wZXJ0aWVzJ10sXG4gICAgICAgIHBlcnNpc3RlbmNlVHlwZTogb3B0aW9uc1sncGVyc2lzdGVuY2VfdHlwZSddLFxuICAgICAgICBwZXJzaXN0ZW5jZVByZWZpeDogb3B0aW9uc1snY29va2llX3ByZWZpeCddLFxuICAgICAgICBjb29raWVEb21haW46IG9wdGlvbnNbJ2Nvb2tpZV9kb21haW4nXSxcbiAgICAgICAgY29va2llRXhwaXJhdGlvbjogb3B0aW9uc1snY29va2llX2V4cGlyYXRpb24nXSxcbiAgICAgICAgY3Jvc3NTaXRlQ29va2llOiBvcHRpb25zWydjcm9zc19zaXRlX2Nvb2tpZSddLFxuICAgICAgICBjcm9zc1N1YmRvbWFpbkNvb2tpZTogb3B0aW9uc1snY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZSddLFxuICAgICAgICBzZWN1cmVDb29raWU6IG9wdGlvbnNbJ3NlY3VyZV9jb29raWUnXSxcbiAgICAgICAgaWdub3JlRG50OiBvcHRpb25zWydpZ25vcmVfZG50J11cbiAgICB9KTtcbn07XG5cbi8qKlxuICogT3B0IHRoZSB1c2VyIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBvcHQgdXNlciBpblxuICogICAgIG1peHBhbmVsLm9wdF9pbl90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBvcHQgdXNlciBpbiB3aXRoIHNwZWNpZmljIGV2ZW50IG5hbWUsIHByb3BlcnRpZXMsIGNvb2tpZSBjb25maWd1cmF0aW9uXG4gKiAgICAgbWl4cGFuZWwub3B0X2luX3RyYWNraW5nKHtcbiAqICAgICAgICAgdHJhY2tfZXZlbnRfbmFtZTogJ1VzZXIgb3B0ZWQgaW4nLFxuICogICAgICAgICB0cmFja19ldmVudF9wcm9wZXJ0aWVzOiB7XG4gKiAgICAgICAgICAgICAnRW1haWwnOiAnamRvZUBleGFtcGxlLmNvbSdcbiAqICAgICAgICAgfSxcbiAqICAgICAgICAgY29va2llX2V4cGlyYXRpb246IDMwLFxuICogICAgICAgICBzZWN1cmVfY29va2llOiB0cnVlXG4gKiAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2YgY29uZmlnIG9wdGlvbnMgdG8gb3ZlcnJpZGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLnRyYWNrXSBGdW5jdGlvbiB1c2VkIGZvciB0cmFja2luZyBhIE1peHBhbmVsIGV2ZW50IHRvIHJlY29yZCB0aGUgb3B0LWluIGFjdGlvbiAoZGVmYXVsdCBpcyB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgdHJhY2sgbWV0aG9kKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnRyYWNrX2V2ZW50X25hbWU9JG9wdF9pbl0gRXZlbnQgbmFtZSB0byBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnRyYWNrX3Byb3BlcnRpZXNdIFNldCBvZiBwcm9wZXJ0aWVzIHRvIGJlIHRyYWNrZWQgYWxvbmcgd2l0aCB0aGUgb3B0LWluIGFjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5lbmFibGVfcGVyc2lzdGVuY2U9dHJ1ZV0gSWYgdHJ1ZSwgd2lsbCByZS1lbmFibGUgc2RrIHBlcnNpc3RlbmNlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvb2tpZV9leHBpcmF0aW9uXSBOdW1iZXIgb2YgZGF5cyB1bnRpbCB0aGUgb3B0LWluIGNvb2tpZSBleHBpcmVzIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX2RvbWFpbl0gQ3VzdG9tIGNvb2tpZSBkb21haW4gKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc2l0ZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXNpdGUtZW5hYmxlZCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zdWJkb21haW5fY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zdWJkb21haW4gb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlY3VyZV9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIHNlY3VyZSBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLm9wdF9pbl90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMob3B0SW4sIG9wdGlvbnMpO1xuICAgIHRoaXMuX2dkcHJfdXBkYXRlX3BlcnNpc3RlbmNlKG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBPcHQgdGhlIHVzZXIgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICAvLyBvcHQgdXNlciBvdXRcbiAqICAgICBtaXhwYW5lbC5vcHRfb3V0X3RyYWNraW5nKCk7XG4gKlxuICogICAgIC8vIG9wdCB1c2VyIG91dCB3aXRoIGRpZmZlcmVudCBjb29raWUgY29uZmlndXJhdGlvbiBmcm9tIE1peHBhbmVsIGluc3RhbmNlXG4gKiAgICAgbWl4cGFuZWwub3B0X291dF90cmFja2luZyh7XG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmRlbGV0ZV91c2VyPXRydWVdIElmIHRydWUsIHdpbGwgZGVsZXRlIHRoZSBjdXJyZW50bHkgaWRlbnRpZmllZCB1c2VyJ3MgcHJvZmlsZSBhbmQgY2xlYXIgYWxsIGNoYXJnZXMgYWZ0ZXIgb3B0aW5nIHRoZSB1c2VyIG91dFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jbGVhcl9wZXJzaXN0ZW5jZT10cnVlXSBJZiB0cnVlLCB3aWxsIGRlbGV0ZSBhbGwgZGF0YSBzdG9yZWQgYnkgdGhlIHNkayBpbiBwZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnBlcnNpc3RlbmNlX3R5cGU9bG9jYWxTdG9yYWdlXSBQZXJzaXN0ZW5jZSBtZWNoYW5pc20gdXNlZCAtIGNvb2tpZSBvciBsb2NhbFN0b3JhZ2UgLSBmYWxscyBiYWNrIHRvIGNvb2tpZSBpZiBsb2NhbFN0b3JhZ2UgaXMgdW5hdmFpbGFibGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfcHJlZml4PV9fbXBfb3B0X2luX291dF0gQ3VzdG9tIHByZWZpeCB0byBiZSB1c2VkIGluIHRoZSBjb29raWUvbG9jYWxzdG9yYWdlIG5hbWVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb29raWVfZXhwaXJhdGlvbl0gTnVtYmVyIG9mIGRheXMgdW50aWwgdGhlIG9wdC1pbiBjb29raWUgZXhwaXJlcyAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9kb21haW5dIEN1c3RvbSBjb29raWUgZG9tYWluIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3NpdGVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBjcm9zcy1zaXRlLWVuYWJsZWQgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY3Jvc3Nfc3ViZG9tYWluX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc3ViZG9tYWluIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zZWN1cmVfY29va2llXSBXaGV0aGVyIHRoZSBvcHQtaW4gY29va2llIGlzIHNldCBhcyBzZWN1cmUgb3Igbm90IChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKi9cbk1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfb3V0X3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfLmV4dGVuZCh7XG4gICAgICAgICdjbGVhcl9wZXJzaXN0ZW5jZSc6IHRydWUsXG4gICAgICAgICdkZWxldGVfdXNlcic6IHRydWVcbiAgICB9LCBvcHRpb25zKTtcblxuICAgIC8vIGRlbGV0ZSB1c2VyIGFuZCBjbGVhciBjaGFyZ2VzIHNpbmNlIHRoZXNlIG1ldGhvZHMgbWF5IGJlIGRpc2FibGVkIGJ5IG9wdC1vdXRcbiAgICBpZiAob3B0aW9uc1snZGVsZXRlX3VzZXInXSAmJiB0aGlzWydwZW9wbGUnXSAmJiB0aGlzWydwZW9wbGUnXS5faWRlbnRpZnlfY2FsbGVkKCkpIHtcbiAgICAgICAgdGhpc1sncGVvcGxlJ10uZGVsZXRlX3VzZXIoKTtcbiAgICAgICAgdGhpc1sncGVvcGxlJ10uY2xlYXJfY2hhcmdlcygpO1xuICAgIH1cblxuICAgIHRoaXMuX2dkcHJfY2FsbF9mdW5jKG9wdE91dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2Uob3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIHVzZXIgaGFzIG9wdGVkIGluIHRvIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICB2YXIgaGFzX29wdGVkX2luID0gbWl4cGFuZWwuaGFzX29wdGVkX2luX3RyYWNraW5nKCk7XG4gKiAgICAgLy8gdXNlIGhhc19vcHRlZF9pbiB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGN1cnJlbnQgb3B0LWluIHN0YXR1c1xuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX2luX3RyYWNraW5nID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9nZHByX2NhbGxfZnVuYyhoYXNPcHRlZEluLCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgdXNlciBoYXMgb3B0ZWQgb3V0IG9mIGRhdGEgdHJhY2tpbmcgYW5kIGNvb2tpZXMvbG9jYWxzdG9yYWdlIGZvciB0aGlzIE1peHBhbmVsIGluc3RhbmNlXG4gKlxuICogIyMjIFVzYWdlOlxuICpcbiAqICAgICB2YXIgaGFzX29wdGVkX291dCA9IG1peHBhbmVsLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcoKTtcbiAqICAgICAvLyB1c2UgaGFzX29wdGVkX291dCB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucGVyc2lzdGVuY2VfdHlwZT1sb2NhbFN0b3JhZ2VdIFBlcnNpc3RlbmNlIG1lY2hhbmlzbSB1c2VkIC0gY29va2llIG9yIGxvY2FsU3RvcmFnZSAtIGZhbGxzIGJhY2sgdG8gY29va2llIGlmIGxvY2FsU3RvcmFnZSBpcyB1bmF2YWlsYWJsZVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNvb2tpZV9wcmVmaXg9X19tcF9vcHRfaW5fb3V0XSBDdXN0b20gcHJlZml4IHRvIGJlIHVzZWQgaW4gdGhlIGNvb2tpZS9sb2NhbHN0b3JhZ2UgbmFtZVxuICogQHJldHVybnMge2Jvb2xlYW59IGN1cnJlbnQgb3B0LW91dCBzdGF0dXNcbiAqL1xuTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9vdXRfdHJhY2tpbmcgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dkcHJfY2FsbF9mdW5jKGhhc09wdGVkT3V0LCBvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQ2xlYXIgdGhlIHVzZXIncyBvcHQgaW4vb3V0IHN0YXR1cyBvZiBkYXRhIHRyYWNraW5nIGFuZCBjb29raWVzL2xvY2Fsc3RvcmFnZSBmb3IgdGhpcyBNaXhwYW5lbCBpbnN0YW5jZVxuICpcbiAqICMjIyBVc2FnZTpcbiAqXG4gKiAgICAgLy8gY2xlYXIgdXNlcidzIG9wdC1pbi9vdXQgc3RhdHVzXG4gKiAgICAgbWl4cGFuZWwuY2xlYXJfb3B0X2luX291dF90cmFja2luZygpO1xuICpcbiAqICAgICAvLyBjbGVhciB1c2VyJ3Mgb3B0LWluL291dCBzdGF0dXMgd2l0aCBzcGVjaWZpYyBjb29raWUgY29uZmlndXJhdGlvbiAtIHNob3VsZCBtYXRjaFxuICogICAgIC8vIGNvbmZpZ3VyYXRpb24gdXNlZCB3aGVuIG9wdF9pbl90cmFja2luZy9vcHRfb3V0X3RyYWNraW5nIG1ldGhvZHMgd2VyZSBjYWxsZWQuXG4gKiAgICAgbWl4cGFuZWwuY2xlYXJfb3B0X2luX291dF90cmFja2luZyh7XG4gKiAgICAgICAgIGNvb2tpZV9leHBpcmF0aW9uOiAzMCxcbiAqICAgICAgICAgc2VjdXJlX2Nvb2tpZTogdHJ1ZVxuICogICAgIH0pO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQSBkaWN0aW9uYXJ5IG9mIGNvbmZpZyBvcHRpb25zIHRvIG92ZXJyaWRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmVuYWJsZV9wZXJzaXN0ZW5jZT10cnVlXSBJZiB0cnVlLCB3aWxsIHJlLWVuYWJsZSBzZGsgcGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wZXJzaXN0ZW5jZV90eXBlPWxvY2FsU3RvcmFnZV0gUGVyc2lzdGVuY2UgbWVjaGFuaXNtIHVzZWQgLSBjb29raWUgb3IgbG9jYWxTdG9yYWdlIC0gZmFsbHMgYmFjayB0byBjb29raWUgaWYgbG9jYWxTdG9yYWdlIGlzIHVuYXZhaWxhYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuY29va2llX3ByZWZpeD1fX21wX29wdF9pbl9vdXRdIEN1c3RvbSBwcmVmaXggdG8gYmUgdXNlZCBpbiB0aGUgY29va2llL2xvY2Fsc3RvcmFnZSBuYW1lXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29va2llX2V4cGlyYXRpb25dIE51bWJlciBvZiBkYXlzIHVudGlsIHRoZSBvcHQtaW4gY29va2llIGV4cGlyZXMgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5jb29raWVfZG9tYWluXSBDdXN0b20gY29va2llIGRvbWFpbiAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5jcm9zc19zaXRlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgY3Jvc3Mtc2l0ZS1lbmFibGVkIChvdmVycmlkZXMgdmFsdWUgc3BlY2lmaWVkIGluIHRoaXMgTWl4cGFuZWwgaW5zdGFuY2UncyBjb25maWcpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmNyb3NzX3N1YmRvbWFpbl9jb29raWVdIFdoZXRoZXIgdGhlIG9wdC1pbiBjb29raWUgaXMgc2V0IGFzIGNyb3NzLXN1YmRvbWFpbiBvciBub3QgKG92ZXJyaWRlcyB2YWx1ZSBzcGVjaWZpZWQgaW4gdGhpcyBNaXhwYW5lbCBpbnN0YW5jZSdzIGNvbmZpZylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VjdXJlX2Nvb2tpZV0gV2hldGhlciB0aGUgb3B0LWluIGNvb2tpZSBpcyBzZXQgYXMgc2VjdXJlIG9yIG5vdCAob3ZlcnJpZGVzIHZhbHVlIHNwZWNpZmllZCBpbiB0aGlzIE1peHBhbmVsIGluc3RhbmNlJ3MgY29uZmlnKVxuICovXG5NaXhwYW5lbExpYi5wcm90b3R5cGUuY2xlYXJfb3B0X2luX291dF90cmFja2luZyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gXy5leHRlbmQoe1xuICAgICAgICAnZW5hYmxlX3BlcnNpc3RlbmNlJzogdHJ1ZVxuICAgIH0sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fZ2Rwcl9jYWxsX2Z1bmMoY2xlYXJPcHRJbk91dCwgb3B0aW9ucyk7XG4gICAgdGhpcy5fZ2Rwcl91cGRhdGVfcGVyc2lzdGVuY2Uob3B0aW9ucyk7XG59O1xuXG5NaXhwYW5lbExpYi5wcm90b3R5cGUucmVwb3J0X2Vycm9yID0gZnVuY3Rpb24obXNnLCBlcnIpIHtcbiAgICBjb25zb2xlJDEuZXJyb3IuYXBwbHkoY29uc29sZSQxLmVycm9yLCBhcmd1bWVudHMpO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghZXJyICYmICEobXNnIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgICBtc2cgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldF9jb25maWcoJ2Vycm9yX3JlcG9ydGVyJykobXNnLCBlcnIpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUkMS5lcnJvcihlcnIpO1xuICAgIH1cbn07XG5cbi8vIEVYUE9SVFMgKGZvciBjbG9zdXJlIGNvbXBpbGVyKVxuXG4vLyBNaXhwYW5lbExpYiBFeHBvcnRzXG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2luaXQnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5pbml0O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZXNldCddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVzZXQ7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2Rpc2FibGUnXSAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5kaXNhYmxlO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0aW1lX2V2ZW50J10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudGltZV9ldmVudDtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2snXSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0cmFja19saW5rcyddICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudHJhY2tfbGlua3M7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX2Zvcm1zJ10gICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja19mb3Jtcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsndHJhY2tfcGFnZXZpZXcnXSAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnRyYWNrX3BhZ2V2aWV3O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydyZWdpc3RlciddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUucmVnaXN0ZXI7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlZ2lzdGVyX29uY2UnXSAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZWdpc3Rlcl9vbmNlO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd1bnJlZ2lzdGVyJ10gICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudW5yZWdpc3Rlcjtcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaWRlbnRpZnknXSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmlkZW50aWZ5O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydhbGlhcyddICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuYWxpYXM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ25hbWVfdGFnJ10gICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5uYW1lX3RhZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc2V0X2NvbmZpZyddICAgICAgICAgICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnNldF9jb25maWc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9jb25maWcnXSAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfY29uZmlnO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfcHJvcGVydHknXSAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X3Byb3BlcnR5O1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydnZXRfZGlzdGluY3RfaWQnXSAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuZ2V0X2Rpc3RpbmN0X2lkO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWyd0b1N0cmluZyddICAgICAgICAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUudG9TdHJpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ29wdF9vdXRfdHJhY2tpbmcnXSAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5vcHRfb3V0X3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydvcHRfaW5fdHJhY2tpbmcnXSAgICAgICAgICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUub3B0X2luX3RyYWNraW5nO1xuTWl4cGFuZWxMaWIucHJvdG90eXBlWydoYXNfb3B0ZWRfb3V0X3RyYWNraW5nJ10gICAgICAgICAgICAgPSBNaXhwYW5lbExpYi5wcm90b3R5cGUuaGFzX29wdGVkX291dF90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnaGFzX29wdGVkX2luX3RyYWNraW5nJ10gICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmhhc19vcHRlZF9pbl90cmFja2luZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnY2xlYXJfb3B0X2luX291dF90cmFja2luZyddICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmNsZWFyX29wdF9pbl9vdXRfdHJhY2tpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3NldF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zZXRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2FkZF9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5hZGRfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3JlbW92ZV9ncm91cCddICAgICAgICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5yZW1vdmVfZ3JvdXA7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3RyYWNrX3dpdGhfZ3JvdXBzJ10gICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS50cmFja193aXRoX2dyb3Vwcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RhcnRfYmF0Y2hfc2VuZGVycyddICAgICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0YXJ0X2JhdGNoX3NlbmRlcnM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0b3BfYmF0Y2hfc2VuZGVycyddICAgICAgICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdG9wX2JhdGNoX3NlbmRlcnM7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ3N0YXJ0X3Nlc3Npb25fcmVjb3JkaW5nJ10gICAgICAgICAgICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5zdGFydF9zZXNzaW9uX3JlY29yZGluZztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnc3RvcF9zZXNzaW9uX3JlY29yZGluZyddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLnN0b3Bfc2Vzc2lvbl9yZWNvcmRpbmc7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ2dldF9zZXNzaW9uX3JlY29yZGluZ19wcm9wZXJ0aWVzJ10gICA9IE1peHBhbmVsTGliLnByb3RvdHlwZS5nZXRfc2Vzc2lvbl9yZWNvcmRpbmdfcHJvcGVydGllcztcbk1peHBhbmVsTGliLnByb3RvdHlwZVsnZ2V0X3Nlc3Npb25fcmVwbGF5X3VybCddICAgICAgICAgICAgID0gTWl4cGFuZWxMaWIucHJvdG90eXBlLmdldF9zZXNzaW9uX3JlcGxheV91cmw7XG5NaXhwYW5lbExpYi5wcm90b3R5cGVbJ0RFRkFVTFRfQVBJX1JPVVRFUyddICAgICAgICAgICAgICAgICA9IERFRkFVTFRfQVBJX1JPVVRFUztcblxuLy8gTWl4cGFuZWxQZXJzaXN0ZW5jZSBFeHBvcnRzXG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsncHJvcGVydGllcyddICAgICAgICAgICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5wcm9wZXJ0aWVzO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3VwZGF0ZV9zZWFyY2hfa2V5d29yZCddID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3NlYXJjaF9rZXl3b3JkO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ3VwZGF0ZV9yZWZlcnJlcl9pbmZvJ10gID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUudXBkYXRlX3JlZmVycmVyX2luZm87XG5NaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZVsnZ2V0X2Nyb3NzX3N1YmRvbWFpbiddICAgPSBNaXhwYW5lbFBlcnNpc3RlbmNlLnByb3RvdHlwZS5nZXRfY3Jvc3Nfc3ViZG9tYWluO1xuTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGVbJ2NsZWFyJ10gICAgICAgICAgICAgICAgID0gTWl4cGFuZWxQZXJzaXN0ZW5jZS5wcm90b3R5cGUuY2xlYXI7XG5cblxudmFyIGluc3RhbmNlcyA9IHt9O1xudmFyIGV4dGVuZF9tcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGFkZCBhbGwgdGhlIHN1YiBtaXhwYW5lbCBpbnN0YW5jZXNcbiAgICBfLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbihpbnN0YW5jZSwgbmFtZSkge1xuICAgICAgICBpZiAobmFtZSAhPT0gUFJJTUFSWV9JTlNUQU5DRV9OQU1FKSB7IG1peHBhbmVsX21hc3RlcltuYW1lXSA9IGluc3RhbmNlOyB9XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgcHJpdmF0ZSBmdW5jdGlvbnMgYXMgX1xuICAgIG1peHBhbmVsX21hc3RlclsnXyddID0gXztcbn07XG5cbnZhciBvdmVycmlkZV9tcF9pbml0X2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAvLyB3ZSBvdmVycmlkZSB0aGUgc25pcHBldHMgaW5pdCBmdW5jdGlvbiB0byBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgYVxuICAgIC8vIHVzZXIgaW5pdGlhbGl6ZXMgdGhlIG1peHBhbmVsIGxpYnJhcnkgYWZ0ZXIgdGhlIHNjcmlwdCBsb2FkcyAmIHJ1bnNcbiAgICBtaXhwYW5lbF9tYXN0ZXJbJ2luaXQnXSA9IGZ1bmN0aW9uKHRva2VuLCBjb25maWcsIG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgYSBzdWIgbGlicmFyeVxuICAgICAgICAgICAgaWYgKCFtaXhwYW5lbF9tYXN0ZXJbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXJbbmFtZV0gPSBpbnN0YW5jZXNbbmFtZV0gPSBjcmVhdGVfbXBsaWIodG9rZW4sIGNvbmZpZywgbmFtZSk7XG4gICAgICAgICAgICAgICAgbWl4cGFuZWxfbWFzdGVyW25hbWVdLl9sb2FkZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtaXhwYW5lbF9tYXN0ZXJbbmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBtaXhwYW5lbF9tYXN0ZXI7XG5cbiAgICAgICAgICAgIGlmIChpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSkge1xuICAgICAgICAgICAgICAgIC8vIG1haW4gbWl4cGFuZWwgbGliIGFscmVhZHkgaW5pdGlhbGl6ZWRcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tQUklNQVJZX0lOU1RBTkNFX05BTUVdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgIC8vIGludGlhbGl6ZSB0aGUgbWFpbiBtaXhwYW5lbCBsaWJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGNyZWF0ZV9tcGxpYih0b2tlbiwgY29uZmlnLCBQUklNQVJZX0lOU1RBTkNFX05BTUUpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlLl9sb2FkZWQoKTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbUFJJTUFSWV9JTlNUQU5DRV9OQU1FXSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtaXhwYW5lbF9tYXN0ZXIgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIGlmIChpbml0X3R5cGUgPT09IElOSVRfU05JUFBFVCkge1xuICAgICAgICAgICAgICAgIHdpbltQUklNQVJZX0lOU1RBTkNFX05BTUVdID0gbWl4cGFuZWxfbWFzdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXh0ZW5kX21wKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxudmFyIGFkZF9kb21fbG9hZGVkX2hhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBDcm9zcyBicm93c2VyIERPTSBMb2FkZWQgc3VwcG9ydFxuICAgIGZ1bmN0aW9uIGRvbV9sb2FkZWRfaGFuZGxlcigpIHtcbiAgICAgICAgLy8gZnVuY3Rpb24gZmxhZyBzaW5jZSB3ZSBvbmx5IHdhbnQgdG8gZXhlY3V0ZSB0aGlzIG9uY2VcbiAgICAgICAgaWYgKGRvbV9sb2FkZWRfaGFuZGxlci5kb25lKSB7IHJldHVybjsgfVxuICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgRE9NX0xPQURFRCA9IHRydWU7XG4gICAgICAgIEVOUVVFVUVfUkVRVUVTVFMgPSBmYWxzZTtcblxuICAgICAgICBfLmVhY2goaW5zdGFuY2VzLCBmdW5jdGlvbihpbnN0KSB7XG4gICAgICAgICAgICBpbnN0Ll9kb21fbG9hZGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRvX3Njcm9sbF9jaGVjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsKCdsZWZ0Jyk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChkb19zY3JvbGxfY2hlY2ssIDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9tX2xvYWRlZF9oYW5kbGVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGRvY3VtZW50JDEuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBpZiAoZG9jdW1lbnQkMS5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAvLyBzYWZhcmkgNCBjYW4gZmlyZSB0aGUgRE9NQ29udGVudExvYWRlZCBldmVudCBiZWZvcmUgbG9hZGluZyBhbGxcbiAgICAgICAgICAgIC8vIGV4dGVybmFsIEpTIChpbmNsdWRpbmcgdGhpcyBmaWxlKS4geW91IHdpbGwgc2VlIHNvbWUgY29weXBhc3RhXG4gICAgICAgICAgICAvLyBvbiB0aGUgaW50ZXJuZXQgdGhhdCBjaGVja3MgZm9yICdjb21wbGV0ZScgYW5kICdsb2FkZWQnLCBidXRcbiAgICAgICAgICAgIC8vICdsb2FkZWQnIGlzIGFuIElFIHRoaW5nXG4gICAgICAgICAgICBkb21fbG9hZGVkX2hhbmRsZXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50JDEuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRvbV9sb2FkZWRfaGFuZGxlciwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudCQxLmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIC8vIElFXG4gICAgICAgIGRvY3VtZW50JDEuYXR0YWNoRXZlbnQoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIGRvbV9sb2FkZWRfaGFuZGxlcik7XG5cbiAgICAgICAgLy8gY2hlY2sgdG8gbWFrZSBzdXJlIHdlIGFybid0IGluIGEgZnJhbWVcbiAgICAgICAgdmFyIHRvcGxldmVsID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0b3BsZXZlbCA9IHdpbi5mcmFtZUVsZW1lbnQgPT09IG51bGw7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvY3VtZW50JDEuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICYmIHRvcGxldmVsKSB7XG4gICAgICAgICAgICBkb19zY3JvbGxfY2hlY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZhbGxiYWNrIGhhbmRsZXIsIGFsd2F5cyB3aWxsIHdvcmtcbiAgICBfLnJlZ2lzdGVyX2V2ZW50KHdpbiwgJ2xvYWQnLCBkb21fbG9hZGVkX2hhbmRsZXIsIHRydWUpO1xufTtcblxuZnVuY3Rpb24gaW5pdF9hc19tb2R1bGUoYnVuZGxlX2xvYWRlcikge1xuICAgIGxvYWRfZXh0cmFfYnVuZGxlID0gYnVuZGxlX2xvYWRlcjtcbiAgICBpbml0X3R5cGUgPSBJTklUX01PRFVMRTtcbiAgICBtaXhwYW5lbF9tYXN0ZXIgPSBuZXcgTWl4cGFuZWxMaWIoKTtcblxuICAgIG92ZXJyaWRlX21wX2luaXRfZnVuYygpO1xuICAgIG1peHBhbmVsX21hc3RlclsnaW5pdCddKCk7XG4gICAgYWRkX2RvbV9sb2FkZWRfaGFuZGxlcigpO1xuXG4gICAgcmV0dXJuIG1peHBhbmVsX21hc3Rlcjtcbn1cblxuLy8gRm9yIGxvYWRpbmcgc2VwYXJhdGUgYnVuZGxlcyBhc3luY2hyb25vdXNseSB2aWEgc2NyaXB0IHRhZ1xuXG4vLyBGb3IgYnVpbGRzIHRoYXQgaGF2ZSBldmVyeXRoaW5nIGluIG9uZSBidW5kbGUsIG5vIGV4dHJhIHdvcmsuXG5mdW5jdGlvbiBsb2FkTm9vcCAoX3NyYywgb25sb2FkKSB7XG4gICAgb25sb2FkKCk7XG59XG5cbi8qIGVzbGludCBjYW1lbGNhc2U6IFwib2ZmXCIgKi9cblxudmFyIG1peHBhbmVsID0gaW5pdF9hc19tb2R1bGUobG9hZE5vb3ApO1xuXG5leHBvcnQgeyBtaXhwYW5lbCBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/mixpanel-browser/dist/mixpanel.module.js\n");

/***/ })

};
;